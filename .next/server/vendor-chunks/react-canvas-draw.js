"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-canvas-draw";
exports.ids = ["vendor-chunks/react-canvas-draw"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-canvas-draw/es/coordinateSystem.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-canvas-draw/es/coordinateSystem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDENTITY: () => (/* binding */ IDENTITY),\n/* harmony export */   \"default\": () => (/* binding */ CoordinateSystem)\n/* harmony export */ });\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @type {ViewPoint}\n */\nvar NULL_VIEW_POINT = Object.freeze({\n  x: 0,\n  y: 0,\n  untransformedX: 0,\n  untransformedY: 0\n});\n/**\n * @type {CanvasBounds}\n */\n\nvar NULL_BOUNDS = Object.freeze({\n  canvasWidth: 0,\n  canvasHeight: 0,\n  left: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  viewMin: NULL_VIEW_POINT,\n  viewMax: NULL_VIEW_POINT\n});\n/**\n * The identity matrix (a transform that results in view coordinates that are\n * identical to relative client coordinates).\n * @type {Matrix}\n */\n\nvar IDENTITY = Object.freeze({\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0\n});\n\nfunction valueOrDefault(value, defaultValue) {\n  if (value === null || typeof value === \"undefined\") {\n    return defaultValue;\n  } else {\n    return value;\n  }\n}\n/**\n * Facilitates calculation and manipulation of a zoom-and-pannable view within a\n * canvas.\n */\n\n\nvar CoordinateSystem = /*#__PURE__*/function () {\n  /**\n   * @typedef Extents\n   * @property {number} min the minimal value in the range\n   * @property {number} max the maximal value in the range\n   */\n\n  /**\n   * @typedef Size\n   * @property {number} width the span of the element's horizontal axis\n   * @property {number} height the span of the element's vertical axis\n   */\n\n  /**\n   * @param {Object} parameters the initialization parameters for this instance.\n   * @param {Extents} parameters.scaleExtents the minimum and maximum allowable scale factor.\n   * @param {Sizee} parameters.documentSize the width and height of the document, in client space.\n   */\n  function CoordinateSystem(_ref) {\n    var _this = this;\n\n    var scaleExtents = _ref.scaleExtents,\n        documentSize = _ref.documentSize;\n\n    _defineProperty(this, \"_scaleExtents\", void 0);\n\n    _defineProperty(this, \"_documentSize\", void 0);\n\n    _defineProperty(this, \"_canvas\", null);\n\n    _defineProperty(this, \"_view\", {\n      scale: 1.0,\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(this, \"_viewChangeListeners\", new Set());\n\n    _defineProperty(this, \"setScale\", function (scale) {\n      _this.setView({\n        scale: scale\n      });\n    });\n\n    _defineProperty(this, \"clampView\", function (_ref2) {\n      var scale = _ref2.scale,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$scaleExtents = _this.scaleExtents,\n          min = _this$scaleExtents.min,\n          max = _this$scaleExtents.max;\n      var _this$documentSize = _this.documentSize,\n          width = _this$documentSize.width,\n          height = _this$documentSize.height;\n\n      var _ref3 = _this.canvasRect || NULL_BOUNDS,\n          left = _ref3.left,\n          top = _ref3.top,\n          right = _ref3.right,\n          bottom = _ref3.bottom;\n\n      var canvasWidth = right - left;\n      var canvasHeight = bottom - top;\n      var maxx = canvasWidth / 2;\n      var minx = -(width * _this._view.scale - canvasWidth / 2);\n      var maxy = canvasHeight / 2;\n      var miny = -(height * _this._view.scale - canvasHeight / 2); // Clamp values to acceptible range.\n\n      return {\n        scale: Math.min(Math.max(scale, min), max),\n        x: Math.min(Math.max(x, minx), maxx),\n        y: Math.min(Math.max(y, miny), maxy)\n      };\n    });\n\n    _defineProperty(this, \"resetView\", function () {\n      _this.setView({\n        scale: 1.0,\n        x: 0,\n        y: 0\n      });\n    });\n\n    _defineProperty(this, \"setView\", function (view) {\n      var newView = _this.clampView(_extends({}, _this._view, view || {}));\n\n      var _this$_view = _this._view,\n          scale = _this$_view.scale,\n          x = _this$_view.x,\n          y = _this$_view.y; // Only trigger if the view actually changed.\n\n      if (newView.scale !== scale || newView.x !== x || newView.y !== y) {\n        _this._view = newView;\n\n        _this._viewChangeListeners.forEach(function (listener) {\n          return listener && listener(newView);\n        });\n      }\n\n      return _extends({}, _this._view);\n    });\n\n    _defineProperty(this, \"scaleAtClientPoint\", function (deltaScale, clientPoint) {\n      var viewPt = _this.clientPointToViewPoint(clientPoint);\n\n      var newView = _this.clampView(_extends({}, _this._view, {\n        scale: _this._view.scale + deltaScale\n      }));\n\n      var clientPtPostScale = _this.viewPointToClientPoint(viewPt, newView);\n\n      newView.x = _this._view.x - (clientPtPostScale.clientX - clientPoint.clientX);\n      newView.y = _this._view.y - (clientPtPostScale.clientY - clientPoint.clientY);\n      return _this.setView(newView);\n    });\n\n    _defineProperty(this, \"clientPointToViewPoint\", function (_ref4, view) {\n      var clientX = _ref4.clientX,\n          clientY = _ref4.clientY;\n\n      if (view === void 0) {\n        view = _this._view;\n      }\n\n      var _ref5 = _this.canvasRect || NULL_BOUNDS,\n          left = _ref5.left,\n          top = _ref5.top;\n\n      var relativeClientX = clientX - left;\n      var relativeClientY = clientY - top;\n      return {\n        x: (relativeClientX - view.x) / view.scale,\n        y: (relativeClientY - view.y) / view.scale,\n        relativeClientX: relativeClientX,\n        relativeClientY: relativeClientY\n      };\n    });\n\n    _defineProperty(this, \"viewPointToClientPoint\", function (_ref6, view) {\n      var x = _ref6.x,\n          y = _ref6.y;\n\n      if (view === void 0) {\n        view = _this._view;\n      }\n\n      var _ref7 = _this.canvasRect || NULL_BOUNDS,\n          left = _ref7.left,\n          top = _ref7.top;\n\n      var relativeX = x * view.scale + view.x;\n      var relativeY = y * view.scale + view.y;\n      var clientX = relativeX + left;\n      var clientY = relativeY + top;\n      return {\n        clientX: clientX,\n        clientY: clientY,\n        relativeX: relativeX,\n        relativeY: relativeY,\n        x: clientX,\n        y: clientY\n      };\n    });\n\n    _defineProperty(this, \"attachViewChangeListener\", function (listener) {\n      _this._viewChangeListeners.add(listener);\n    });\n\n    this._scaleExtents = scaleExtents;\n    this._documentSize = documentSize;\n  }\n  /**\n   * @type {Extents}\n   */\n\n\n  _createClass(CoordinateSystem, [{\n    key: \"canvas\",\n\n    /**\n     * @returns {Canvas} the canvas currently associated with this instance.\n     */\n    get: function get() {\n      return this._canvas;\n    }\n    /**\n     * Updates the canvas for this coordinate system and recalculates the view.\n     * @param {Canvas} canvas the new canvas to associate with this instance.\n     */\n    ,\n    set: function set(canvas) {\n      this._canvas = canvas;\n      this.setView();\n    }\n    /**\n     * @returns {number} the current zoom factor\n     */\n\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return this._view.scale;\n    }\n    /**\n     * Sets the zoom factor (clamped by the scale extents) and updates the view.\n     * @param {number} the new zoom factor\n     */\n\n  }, {\n    key: \"x\",\n\n    /**\n     * @returns {number} the horizontal component of the current pan offset\n     */\n    get: function get() {\n      return this._view.x;\n    }\n    /**\n     * Sets the horizontal pan offset (clamped by the document extents) and\n     * updates the view.\n     * @param {number} x the new offset\n     */\n    ,\n    set: function set(x) {\n      this.setView({\n        x: x\n      });\n    }\n    /**\n     * @retruns {number} the vertical component of the current pan offset\n     */\n\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this._view.y;\n    }\n    /**\n     * Sets the vertical pan offset (clamped by the document extents) and\n     * updates the view.\n     * @param {number} y the new offset\n     */\n    ,\n    set: function set(y) {\n      this.setView({\n        y: y\n      });\n    }\n    /**\n     * @returns {View} a copy of this instance's current view state.\n     */\n\n  }, {\n    key: \"view\",\n    get: function get() {\n      return _extends({}, this._view);\n    }\n    /**\n     * @returns {Extents} a copy of the scale extents currently applied to this\n     * instance.\n     */\n\n  }, {\n    key: \"scaleExtents\",\n    get: function get() {\n      return _extends({}, this._scaleExtents);\n    }\n    /**\n     * Updates the minimum and maximum scale and resets the view transform if it\n     * is outside the new extents.\n     * @param {Extents} extents the new scale extents.\n     */\n    ,\n    set: function set(_ref8) {\n      var min = _ref8.min,\n          max = _ref8.max;\n      this._scaleExtents = {\n        min: min,\n        max: max\n      };\n      this.setView();\n    }\n    /**\n     * @returns {Size} the current document size (used to constrain the pan\n     * offset).\n     */\n\n  }, {\n    key: \"documentSize\",\n    get: function get() {\n      return _extends({}, this._documentSize);\n    }\n    /**\n     * Sets the document size and recalculates the view if it is outside the new\n     * bounds.\n     * @param {Size} size the new document size.\n     */\n    ,\n    set: function set(_ref9) {\n      var width = _ref9.width,\n          height = _ref9.height;\n      this._documentSize = {\n        width: width,\n        height: height\n      };\n      this.setView();\n    }\n    /**\n     * A view matrix expressing a series of transformations.\n     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform\n     * @typedef Matrix\n     * @property {number} a horizontal scaling factor (1 == unscaled)\n     * @property {number} b vertical skewing factor (0 == unskewed)\n     * @property {number} c horizontal skewing factor (0 == unskewed)\n     * @property {number} d vertical scaling factor (1 == unscaled)\n     * @property {number} e horizontal translation (0 == untranslated)\n     * @property {number} f vertical translation (0 == untranslated)\n     */\n\n    /**\n     * @returns {Matrix} this coordinate system's current transformation matrix\n     */\n\n  }, {\n    key: \"transformMatrix\",\n    get: function get() {\n      //\n      return {\n        a: this._view.scale,\n        // horizontal scaling\n        b: 0,\n        // vertical skewing\n        c: 0,\n        // horizontal skewing\n        d: this._view.scale,\n        // vertical scaling\n        e: this._view.x,\n        f: this._view.y\n      };\n    }\n    /**\n     * An object expressing the bounds of a canvas object in terms of the\n     * coordinate system.\n     * @typedef CanvasBounds\n     * @property {number} left the left edge of the canvas in client space\n     * @property {number} right the right edge of the canvas in client space\n     * @property {number} top the top edge of the canvas in client space\n     * @property {number} bottom the bottom edge of the canvas in client space\n     * @property {number} canvasWidth the width of the canvas in client space\n     * @property {number} canvasHeight the height of the canvas in client space\n     * @property {ViewPoint} viewMin the top-left corner of the canvas in view space\n     * @property {ViewPoint} viewMax the bottom-right corner of the canvas in view space\n     */\n\n    /**\n     * @returns {CanvasBounds | undefined} the boundaries of the canvas linked to\n     * this coordinate system, or undefined if no canvas is set.\n     */\n\n  }, {\n    key: \"canvasBounds\",\n    get: function get() {\n      if (this._canvas) {\n        var _this$_canvas$getBoun = this._canvas.getBoundingClientRect(),\n            left = _this$_canvas$getBoun.left,\n            top = _this$_canvas$getBoun.top,\n            right = _this$_canvas$getBoun.right,\n            bottom = _this$_canvas$getBoun.bottom;\n\n        return {\n          viewMin: this.clientPointToViewPoint({\n            clientX: left,\n            clientY: top\n          }),\n          viewMax: this.clientPointToViewPoint({\n            clientX: right,\n            clientY: bottom\n          }),\n          left: left,\n          top: top,\n          right: right,\n          bottom: bottom,\n          canvasWidth: this._canvas.width,\n          canvasHeight: this._canvas.height\n        };\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * @private\n     * @return {{left: number, top: number} | undefined}\n     */\n\n  }, {\n    key: \"canvasRect\",\n    get: function get() {\n      if (this.canvas) {\n        return this.canvas.getBoundingClientRect();\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Calculates a variant of the given view clamped according to the scale and\n     * document bounds. Does not modify this instance.\n     * @param {View} view the view constraints to clamp.\n     * @returns {View} a new view object representing the constrained input.\n     */\n\n  }]);\n\n  return CoordinateSystem;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvY29vcmRpbmF0ZVN5c3RlbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHNCQUFzQixnREFBZ0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7O0FBRXBSLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE0sNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsV0FBVztBQUM3Qjs7QUFFQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2Qjs7QUFFQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsdXRvLWxlYXJuaW5nLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWNhbnZhcy1kcmF3L2VzL2Nvb3JkaW5hdGVTeXN0ZW0uanM/YjA1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQHR5cGUge1ZpZXdQb2ludH1cbiAqL1xudmFyIE5VTExfVklFV19QT0lOVCA9IE9iamVjdC5mcmVlemUoe1xuICB4OiAwLFxuICB5OiAwLFxuICB1bnRyYW5zZm9ybWVkWDogMCxcbiAgdW50cmFuc2Zvcm1lZFk6IDBcbn0pO1xuLyoqXG4gKiBAdHlwZSB7Q2FudmFzQm91bmRzfVxuICovXG5cbnZhciBOVUxMX0JPVU5EUyA9IE9iamVjdC5mcmVlemUoe1xuICBjYW52YXNXaWR0aDogMCxcbiAgY2FudmFzSGVpZ2h0OiAwLFxuICBsZWZ0OiAwLFxuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIHZpZXdNaW46IE5VTExfVklFV19QT0lOVCxcbiAgdmlld01heDogTlVMTF9WSUVXX1BPSU5UXG59KTtcbi8qKlxuICogVGhlIGlkZW50aXR5IG1hdHJpeCAoYSB0cmFuc2Zvcm0gdGhhdCByZXN1bHRzIGluIHZpZXcgY29vcmRpbmF0ZXMgdGhhdCBhcmVcbiAqIGlkZW50aWNhbCB0byByZWxhdGl2ZSBjbGllbnQgY29vcmRpbmF0ZXMpLlxuICogQHR5cGUge01hdHJpeH1cbiAqL1xuXG5leHBvcnQgdmFyIElERU5USVRZID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGE6IDEsXG4gIGI6IDAsXG4gIGM6IDAsXG4gIGQ6IDEsXG4gIGU6IDAsXG4gIGY6IDBcbn0pO1xuXG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBGYWNpbGl0YXRlcyBjYWxjdWxhdGlvbiBhbmQgbWFuaXB1bGF0aW9uIG9mIGEgem9vbS1hbmQtcGFubmFibGUgdmlldyB3aXRoaW4gYVxuICogY2FudmFzLlxuICovXG5cblxudmFyIENvb3JkaW5hdGVTeXN0ZW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGVkZWYgRXh0ZW50c1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluIHRoZSBtaW5pbWFsIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4IHRoZSBtYXhpbWFsIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYgU2l6ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggdGhlIHNwYW4gb2YgdGhlIGVsZW1lbnQncyBob3Jpem9udGFsIGF4aXNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCB0aGUgc3BhbiBvZiB0aGUgZWxlbWVudCdzIHZlcnRpY2FsIGF4aXNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIHRoZSBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0V4dGVudHN9IHBhcmFtZXRlcnMuc2NhbGVFeHRlbnRzIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGFsbG93YWJsZSBzY2FsZSBmYWN0b3IuXG4gICAqIEBwYXJhbSB7U2l6ZWV9IHBhcmFtZXRlcnMuZG9jdW1lbnRTaXplIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgaW4gY2xpZW50IHNwYWNlLlxuICAgKi9cbiAgZnVuY3Rpb24gQ29vcmRpbmF0ZVN5c3RlbShfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzY2FsZUV4dGVudHMgPSBfcmVmLnNjYWxlRXh0ZW50cyxcbiAgICAgICAgZG9jdW1lbnRTaXplID0gX3JlZi5kb2N1bWVudFNpemU7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2NhbGVFeHRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG9jdW1lbnRTaXplXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FudmFzXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZpZXdcIiwge1xuICAgICAgc2NhbGU6IDEuMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdmlld0NoYW5nZUxpc3RlbmVyc1wiLCBuZXcgU2V0KCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0U2NhbGVcIiwgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBfdGhpcy5zZXRWaWV3KHtcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsYW1wVmlld1wiLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBzY2FsZSA9IF9yZWYyLnNjYWxlLFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55O1xuICAgICAgdmFyIF90aGlzJHNjYWxlRXh0ZW50cyA9IF90aGlzLnNjYWxlRXh0ZW50cyxcbiAgICAgICAgICBtaW4gPSBfdGhpcyRzY2FsZUV4dGVudHMubWluLFxuICAgICAgICAgIG1heCA9IF90aGlzJHNjYWxlRXh0ZW50cy5tYXg7XG4gICAgICB2YXIgX3RoaXMkZG9jdW1lbnRTaXplID0gX3RoaXMuZG9jdW1lbnRTaXplLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkZG9jdW1lbnRTaXplLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJGRvY3VtZW50U2l6ZS5oZWlnaHQ7XG5cbiAgICAgIHZhciBfcmVmMyA9IF90aGlzLmNhbnZhc1JlY3QgfHwgTlVMTF9CT1VORFMsXG4gICAgICAgICAgbGVmdCA9IF9yZWYzLmxlZnQsXG4gICAgICAgICAgdG9wID0gX3JlZjMudG9wLFxuICAgICAgICAgIHJpZ2h0ID0gX3JlZjMucmlnaHQsXG4gICAgICAgICAgYm90dG9tID0gX3JlZjMuYm90dG9tO1xuXG4gICAgICB2YXIgY2FudmFzV2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgdmFyIG1heHggPSBjYW52YXNXaWR0aCAvIDI7XG4gICAgICB2YXIgbWlueCA9IC0od2lkdGggKiBfdGhpcy5fdmlldy5zY2FsZSAtIGNhbnZhc1dpZHRoIC8gMik7XG4gICAgICB2YXIgbWF4eSA9IGNhbnZhc0hlaWdodCAvIDI7XG4gICAgICB2YXIgbWlueSA9IC0oaGVpZ2h0ICogX3RoaXMuX3ZpZXcuc2NhbGUgLSBjYW52YXNIZWlnaHQgLyAyKTsgLy8gQ2xhbXAgdmFsdWVzIHRvIGFjY2VwdGlibGUgcmFuZ2UuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBNYXRoLm1pbihNYXRoLm1heChzY2FsZSwgbWluKSwgbWF4KSxcbiAgICAgICAgeDogTWF0aC5taW4oTWF0aC5tYXgoeCwgbWlueCksIG1heHgpLFxuICAgICAgICB5OiBNYXRoLm1pbihNYXRoLm1heCh5LCBtaW55KSwgbWF4eSlcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNldFZpZXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0Vmlldyh7XG4gICAgICAgIHNjYWxlOiAxLjAsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0Vmlld1wiLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgdmFyIG5ld1ZpZXcgPSBfdGhpcy5jbGFtcFZpZXcoX2V4dGVuZHMoe30sIF90aGlzLl92aWV3LCB2aWV3IHx8IHt9KSk7XG5cbiAgICAgIHZhciBfdGhpcyRfdmlldyA9IF90aGlzLl92aWV3LFxuICAgICAgICAgIHNjYWxlID0gX3RoaXMkX3ZpZXcuc2NhbGUsXG4gICAgICAgICAgeCA9IF90aGlzJF92aWV3LngsXG4gICAgICAgICAgeSA9IF90aGlzJF92aWV3Lnk7IC8vIE9ubHkgdHJpZ2dlciBpZiB0aGUgdmlldyBhY3R1YWxseSBjaGFuZ2VkLlxuXG4gICAgICBpZiAobmV3Vmlldy5zY2FsZSAhPT0gc2NhbGUgfHwgbmV3Vmlldy54ICE9PSB4IHx8IG5ld1ZpZXcueSAhPT0geSkge1xuICAgICAgICBfdGhpcy5fdmlldyA9IG5ld1ZpZXc7XG5cbiAgICAgICAgX3RoaXMuX3ZpZXdDaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXIgJiYgbGlzdGVuZXIobmV3Vmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIF90aGlzLl92aWV3KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjYWxlQXRDbGllbnRQb2ludFwiLCBmdW5jdGlvbiAoZGVsdGFTY2FsZSwgY2xpZW50UG9pbnQpIHtcbiAgICAgIHZhciB2aWV3UHQgPSBfdGhpcy5jbGllbnRQb2ludFRvVmlld1BvaW50KGNsaWVudFBvaW50KTtcblxuICAgICAgdmFyIG5ld1ZpZXcgPSBfdGhpcy5jbGFtcFZpZXcoX2V4dGVuZHMoe30sIF90aGlzLl92aWV3LCB7XG4gICAgICAgIHNjYWxlOiBfdGhpcy5fdmlldy5zY2FsZSArIGRlbHRhU2NhbGVcbiAgICAgIH0pKTtcblxuICAgICAgdmFyIGNsaWVudFB0UG9zdFNjYWxlID0gX3RoaXMudmlld1BvaW50VG9DbGllbnRQb2ludCh2aWV3UHQsIG5ld1ZpZXcpO1xuXG4gICAgICBuZXdWaWV3LnggPSBfdGhpcy5fdmlldy54IC0gKGNsaWVudFB0UG9zdFNjYWxlLmNsaWVudFggLSBjbGllbnRQb2ludC5jbGllbnRYKTtcbiAgICAgIG5ld1ZpZXcueSA9IF90aGlzLl92aWV3LnkgLSAoY2xpZW50UHRQb3N0U2NhbGUuY2xpZW50WSAtIGNsaWVudFBvaW50LmNsaWVudFkpO1xuICAgICAgcmV0dXJuIF90aGlzLnNldFZpZXcobmV3Vmlldyk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRQb2ludFRvVmlld1BvaW50XCIsIGZ1bmN0aW9uIChfcmVmNCwgdmlldykge1xuICAgICAgdmFyIGNsaWVudFggPSBfcmVmNC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmNC5jbGllbnRZO1xuXG4gICAgICBpZiAodmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZpZXcgPSBfdGhpcy5fdmlldztcbiAgICAgIH1cblxuICAgICAgdmFyIF9yZWY1ID0gX3RoaXMuY2FudmFzUmVjdCB8fCBOVUxMX0JPVU5EUyxcbiAgICAgICAgICBsZWZ0ID0gX3JlZjUubGVmdCxcbiAgICAgICAgICB0b3AgPSBfcmVmNS50b3A7XG5cbiAgICAgIHZhciByZWxhdGl2ZUNsaWVudFggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIHZhciByZWxhdGl2ZUNsaWVudFkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHJlbGF0aXZlQ2xpZW50WCAtIHZpZXcueCkgLyB2aWV3LnNjYWxlLFxuICAgICAgICB5OiAocmVsYXRpdmVDbGllbnRZIC0gdmlldy55KSAvIHZpZXcuc2NhbGUsXG4gICAgICAgIHJlbGF0aXZlQ2xpZW50WDogcmVsYXRpdmVDbGllbnRYLFxuICAgICAgICByZWxhdGl2ZUNsaWVudFk6IHJlbGF0aXZlQ2xpZW50WVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdQb2ludFRvQ2xpZW50UG9pbnRcIiwgZnVuY3Rpb24gKF9yZWY2LCB2aWV3KSB7XG4gICAgICB2YXIgeCA9IF9yZWY2LngsXG4gICAgICAgICAgeSA9IF9yZWY2Lnk7XG5cbiAgICAgIGlmICh2aWV3ID09PSB2b2lkIDApIHtcbiAgICAgICAgdmlldyA9IF90aGlzLl92aWV3O1xuICAgICAgfVxuXG4gICAgICB2YXIgX3JlZjcgPSBfdGhpcy5jYW52YXNSZWN0IHx8IE5VTExfQk9VTkRTLFxuICAgICAgICAgIGxlZnQgPSBfcmVmNy5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF9yZWY3LnRvcDtcblxuICAgICAgdmFyIHJlbGF0aXZlWCA9IHggKiB2aWV3LnNjYWxlICsgdmlldy54O1xuICAgICAgdmFyIHJlbGF0aXZlWSA9IHkgKiB2aWV3LnNjYWxlICsgdmlldy55O1xuICAgICAgdmFyIGNsaWVudFggPSByZWxhdGl2ZVggKyBsZWZ0O1xuICAgICAgdmFyIGNsaWVudFkgPSByZWxhdGl2ZVkgKyB0b3A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBjbGllbnRZLFxuICAgICAgICByZWxhdGl2ZVg6IHJlbGF0aXZlWCxcbiAgICAgICAgcmVsYXRpdmVZOiByZWxhdGl2ZVksXG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdHRhY2hWaWV3Q2hhbmdlTGlzdGVuZXJcIiwgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBfdGhpcy5fdmlld0NoYW5nZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2NhbGVFeHRlbnRzID0gc2NhbGVFeHRlbnRzO1xuICAgIHRoaXMuX2RvY3VtZW50U2l6ZSA9IGRvY3VtZW50U2l6ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0V4dGVudHN9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvb3JkaW5hdGVTeXN0ZW0sIFt7XG4gICAga2V5OiBcImNhbnZhc1wiLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0NhbnZhc30gdGhlIGNhbnZhcyBjdXJyZW50bHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYW52YXMgZm9yIHRoaXMgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHJlY2FsY3VsYXRlcyB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzIHRoZSBuZXcgY2FudmFzIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNhbnZhcykge1xuICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5zZXRWaWV3KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IHpvb20gZmFjdG9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gZmFjdG9yIChjbGFtcGVkIGJ5IHRoZSBzY2FsZSBleHRlbnRzKSBhbmQgdXBkYXRlcyB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhlIG5ldyB6b29tIGZhY3RvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwieFwiLFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIGhvcml6b250YWwgY29tcG9uZW50IG9mIHRoZSBjdXJyZW50IHBhbiBvZmZzZXRcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3Lng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhvcml6b250YWwgcGFuIG9mZnNldCAoY2xhbXBlZCBieSB0aGUgZG9jdW1lbnQgZXh0ZW50cykgYW5kXG4gICAgICogdXBkYXRlcyB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB0aGUgbmV3IG9mZnNldFxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICB0aGlzLnNldFZpZXcoe1xuICAgICAgICB4OiB4XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHJ1bnMge251bWJlcn0gdGhlIHZlcnRpY2FsIGNvbXBvbmVudCBvZiB0aGUgY3VycmVudCBwYW4gb2Zmc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlldy55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2ZXJ0aWNhbCBwYW4gb2Zmc2V0IChjbGFtcGVkIGJ5IHRoZSBkb2N1bWVudCBleHRlbnRzKSBhbmRcbiAgICAgKiB1cGRhdGVzIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IHRoZSBuZXcgb2Zmc2V0XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHkpIHtcbiAgICAgIHRoaXMuc2V0Vmlldyh7XG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Vmlld30gYSBjb3B5IG9mIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IHZpZXcgc3RhdGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRoaXMuX3ZpZXcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXh0ZW50c30gYSBjb3B5IG9mIHRoZSBzY2FsZSBleHRlbnRzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoaXNcbiAgICAgKiBpbnN0YW5jZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNjYWxlRXh0ZW50c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLl9zY2FsZUV4dGVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjYWxlIGFuZCByZXNldHMgdGhlIHZpZXcgdHJhbnNmb3JtIGlmIGl0XG4gICAgICogaXMgb3V0c2lkZSB0aGUgbmV3IGV4dGVudHMuXG4gICAgICogQHBhcmFtIHtFeHRlbnRzfSBleHRlbnRzIHRoZSBuZXcgc2NhbGUgZXh0ZW50cy5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoX3JlZjgpIHtcbiAgICAgIHZhciBtaW4gPSBfcmVmOC5taW4sXG4gICAgICAgICAgbWF4ID0gX3JlZjgubWF4O1xuICAgICAgdGhpcy5fc2NhbGVFeHRlbnRzID0ge1xuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICAgIH07XG4gICAgICB0aGlzLnNldFZpZXcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NpemV9IHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUgKHVzZWQgdG8gY29uc3RyYWluIHRoZSBwYW5cbiAgICAgKiBvZmZzZXQpLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9jdW1lbnRTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRoaXMuX2RvY3VtZW50U2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRvY3VtZW50IHNpemUgYW5kIHJlY2FsY3VsYXRlcyB0aGUgdmlldyBpZiBpdCBpcyBvdXRzaWRlIHRoZSBuZXdcbiAgICAgKiBib3VuZHMuXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBuZXcgZG9jdW1lbnQgc2l6ZS5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoX3JlZjkpIHtcbiAgICAgIHZhciB3aWR0aCA9IF9yZWY5LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWY5LmhlaWdodDtcbiAgICAgIHRoaXMuX2RvY3VtZW50U2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0VmlldygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHZpZXcgbWF0cml4IGV4cHJlc3NpbmcgYSBzZXJpZXMgb2YgdHJhbnNmb3JtYXRpb25zLlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0VHJhbnNmb3JtXG4gICAgICogQHR5cGVkZWYgTWF0cml4XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGEgaG9yaXpvbnRhbCBzY2FsaW5nIGZhY3RvciAoMSA9PSB1bnNjYWxlZClcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYiB2ZXJ0aWNhbCBza2V3aW5nIGZhY3RvciAoMCA9PSB1bnNrZXdlZClcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYyBob3Jpem9udGFsIHNrZXdpbmcgZmFjdG9yICgwID09IHVuc2tld2VkKVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkIHZlcnRpY2FsIHNjYWxpbmcgZmFjdG9yICgxID09IHVuc2NhbGVkKVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlIGhvcml6b250YWwgdHJhbnNsYXRpb24gKDAgPT0gdW50cmFuc2xhdGVkKVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmIHZlcnRpY2FsIHRyYW5zbGF0aW9uICgwID09IHVudHJhbnNsYXRlZClcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IHRoaXMgY29vcmRpbmF0ZSBzeXN0ZW0ncyBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtTWF0cml4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvL1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogdGhpcy5fdmlldy5zY2FsZSxcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBzY2FsaW5nXG4gICAgICAgIGI6IDAsXG4gICAgICAgIC8vIHZlcnRpY2FsIHNrZXdpbmdcbiAgICAgICAgYzogMCxcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBza2V3aW5nXG4gICAgICAgIGQ6IHRoaXMuX3ZpZXcuc2NhbGUsXG4gICAgICAgIC8vIHZlcnRpY2FsIHNjYWxpbmdcbiAgICAgICAgZTogdGhpcy5fdmlldy54LFxuICAgICAgICBmOiB0aGlzLl92aWV3LnlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBleHByZXNzaW5nIHRoZSBib3VuZHMgb2YgYSBjYW52YXMgb2JqZWN0IGluIHRlcm1zIG9mIHRoZVxuICAgICAqIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIEB0eXBlZGVmIENhbnZhc0JvdW5kc1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGNhbnZhcyBpbiBjbGllbnQgc3BhY2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmlnaHQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNhbnZhcyBpbiBjbGllbnQgc3BhY2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdG9wIHRoZSB0b3AgZWRnZSBvZiB0aGUgY2FudmFzIGluIGNsaWVudCBzcGFjZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3R0b20gdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBjYW52YXMgaW4gY2xpZW50IHNwYWNlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbnZhc1dpZHRoIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGluIGNsaWVudCBzcGFjZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYW52YXNIZWlnaHQgdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGluIGNsaWVudCBzcGFjZVxuICAgICAqIEBwcm9wZXJ0eSB7Vmlld1BvaW50fSB2aWV3TWluIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcyBpbiB2aWV3IHNwYWNlXG4gICAgICogQHByb3BlcnR5IHtWaWV3UG9pbnR9IHZpZXdNYXggdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgdGhlIGNhbnZhcyBpbiB2aWV3IHNwYWNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzQm91bmRzIHwgdW5kZWZpbmVkfSB0aGUgYm91bmRhcmllcyBvZiB0aGUgY2FudmFzIGxpbmtlZCB0b1xuICAgICAqIHRoaXMgY29vcmRpbmF0ZSBzeXN0ZW0sIG9yIHVuZGVmaW5lZCBpZiBubyBjYW52YXMgaXMgc2V0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FudmFzQm91bmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAgIHZhciBfdGhpcyRfY2FudmFzJGdldEJvdW4gPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBsZWZ0ID0gX3RoaXMkX2NhbnZhcyRnZXRCb3VuLmxlZnQsXG4gICAgICAgICAgICB0b3AgPSBfdGhpcyRfY2FudmFzJGdldEJvdW4udG9wLFxuICAgICAgICAgICAgcmlnaHQgPSBfdGhpcyRfY2FudmFzJGdldEJvdW4ucmlnaHQsXG4gICAgICAgICAgICBib3R0b20gPSBfdGhpcyRfY2FudmFzJGdldEJvdW4uYm90dG9tO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld01pbjogdGhpcy5jbGllbnRQb2ludFRvVmlld1BvaW50KHtcbiAgICAgICAgICAgIGNsaWVudFg6IGxlZnQsXG4gICAgICAgICAgICBjbGllbnRZOiB0b3BcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB2aWV3TWF4OiB0aGlzLmNsaWVudFBvaW50VG9WaWV3UG9pbnQoe1xuICAgICAgICAgICAgY2xpZW50WDogcmlnaHQsXG4gICAgICAgICAgICBjbGllbnRZOiBib3R0b21cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICBjYW52YXNXaWR0aDogdGhpcy5fY2FudmFzLndpZHRoLFxuICAgICAgICAgIGNhbnZhc0hlaWdodDogdGhpcy5fY2FudmFzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0gfCB1bmRlZmluZWR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYW52YXNSZWN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhIHZhcmlhbnQgb2YgdGhlIGdpdmVuIHZpZXcgY2xhbXBlZCBhY2NvcmRpbmcgdG8gdGhlIHNjYWxlIGFuZFxuICAgICAqIGRvY3VtZW50IGJvdW5kcy4gRG9lcyBub3QgbW9kaWZ5IHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtWaWV3fSB2aWV3IHRoZSB2aWV3IGNvbnN0cmFpbnRzIHRvIGNsYW1wLlxuICAgICAqIEByZXR1cm5zIHtWaWV3fSBhIG5ldyB2aWV3IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbnN0cmFpbmVkIGlucHV0LlxuICAgICAqL1xuXG4gIH1dKTtcblxuICByZXR1cm4gQ29vcmRpbmF0ZVN5c3RlbTtcbn0oKTtcblxuZXhwb3J0IHsgQ29vcmRpbmF0ZVN5c3RlbSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-canvas-draw/es/coordinateSystem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-canvas-draw/es/drawImage.js":
/*!********************************************************!*\
  !*** ./node_modules/react-canvas-draw/es/drawImage.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ drawImageProp)\n/* harmony export */ });\n/** \n * Original from: https://stackoverflow.com/questions/21961839/simulation-background-size-cover-in-canvas\n * Original By Ken Fyrstenberg Nilsen\n * \n * Note: img must be fully loaded or have correct width & height set.\n */\nfunction drawImageProp(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      ctx = _ref.ctx,\n      img = _ref.img,\n      x = _ref.x,\n      y = _ref.y,\n      w = _ref.w,\n      h = _ref.h,\n      offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY;\n\n  // Defaults\n  if (typeof x !== \"number\") x = 0;\n  if (typeof y !== \"number\") y = 0;\n  if (typeof w !== \"number\") w = ctx.canvas.width;\n  if (typeof h !== \"number\") h = ctx.canvas.height;\n  if (typeof offsetX !== \"number\") offsetX = 0.5;\n  if (typeof offsetY !== \"number\") offsetY = 0.5; // keep bounds [0.0, 1.0]\n\n  if (offsetX < 0) offsetX = 0;\n  if (offsetY < 0) offsetY = 0;\n  if (offsetX > 1) offsetX = 1;\n  if (offsetY > 1) offsetY = 1;\n  var iw = img.width,\n      ih = img.height,\n      r = Math.min(w / iw, h / ih),\n      nw = iw * r,\n      // new prop. width\n  nh = ih * r,\n      // new prop. height\n  cx,\n      cy,\n      cw,\n      ch,\n      ar = 1; // decide which gap to fill\n\n  if (nw < w) ar = w / nw;\n  if (Math.abs(ar - 1) < 1e-14 && nh < h) ar = h / nh; // updated\n\n  nw *= ar;\n  nh *= ar; // calc source rectangle\n\n  cw = iw / (nw / w);\n  ch = ih / (nh / h);\n  cx = (iw - cw) * offsetX;\n  cy = (ih - ch) * offsetY; // make sure source rectangle is valid\n\n  if (cx < 0) cx = 0;\n  if (cy < 0) cy = 0;\n  if (cw > iw) cw = iw;\n  if (ch > ih) ch = ih; // fill image in dest. rectangle\n\n  ctx.drawImage(img, cx, cy, cw, ch, x, y, w, h);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvZHJhd0ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGx1dG8tbGVhcm5pbmcvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvZHJhd0ltYWdlLmpzPzVjM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFxuICogT3JpZ2luYWwgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE5NjE4Mzkvc2ltdWxhdGlvbi1iYWNrZ3JvdW5kLXNpemUtY292ZXItaW4tY2FudmFzXG4gKiBPcmlnaW5hbCBCeSBLZW4gRnlyc3RlbmJlcmcgTmlsc2VuXG4gKiBcbiAqIE5vdGU6IGltZyBtdXN0IGJlIGZ1bGx5IGxvYWRlZCBvciBoYXZlIGNvcnJlY3Qgd2lkdGggJiBoZWlnaHQgc2V0LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmF3SW1hZ2VQcm9wKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBjdHggPSBfcmVmLmN0eCxcbiAgICAgIGltZyA9IF9yZWYuaW1nLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB3ID0gX3JlZi53LFxuICAgICAgaCA9IF9yZWYuaCxcbiAgICAgIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZO1xuXG4gIC8vIERlZmF1bHRzXG4gIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIikgeCA9IDA7XG4gIGlmICh0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikgeSA9IDA7XG4gIGlmICh0eXBlb2YgdyAhPT0gXCJudW1iZXJcIikgdyA9IGN0eC5jYW52YXMud2lkdGg7XG4gIGlmICh0eXBlb2YgaCAhPT0gXCJudW1iZXJcIikgaCA9IGN0eC5jYW52YXMuaGVpZ2h0O1xuICBpZiAodHlwZW9mIG9mZnNldFggIT09IFwibnVtYmVyXCIpIG9mZnNldFggPSAwLjU7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0WSAhPT0gXCJudW1iZXJcIikgb2Zmc2V0WSA9IDAuNTsgLy8ga2VlcCBib3VuZHMgWzAuMCwgMS4wXVxuXG4gIGlmIChvZmZzZXRYIDwgMCkgb2Zmc2V0WCA9IDA7XG4gIGlmIChvZmZzZXRZIDwgMCkgb2Zmc2V0WSA9IDA7XG4gIGlmIChvZmZzZXRYID4gMSkgb2Zmc2V0WCA9IDE7XG4gIGlmIChvZmZzZXRZID4gMSkgb2Zmc2V0WSA9IDE7XG4gIHZhciBpdyA9IGltZy53aWR0aCxcbiAgICAgIGloID0gaW1nLmhlaWdodCxcbiAgICAgIHIgPSBNYXRoLm1pbih3IC8gaXcsIGggLyBpaCksXG4gICAgICBudyA9IGl3ICogcixcbiAgICAgIC8vIG5ldyBwcm9wLiB3aWR0aFxuICBuaCA9IGloICogcixcbiAgICAgIC8vIG5ldyBwcm9wLiBoZWlnaHRcbiAgY3gsXG4gICAgICBjeSxcbiAgICAgIGN3LFxuICAgICAgY2gsXG4gICAgICBhciA9IDE7IC8vIGRlY2lkZSB3aGljaCBnYXAgdG8gZmlsbFxuXG4gIGlmIChudyA8IHcpIGFyID0gdyAvIG53O1xuICBpZiAoTWF0aC5hYnMoYXIgLSAxKSA8IDFlLTE0ICYmIG5oIDwgaCkgYXIgPSBoIC8gbmg7IC8vIHVwZGF0ZWRcblxuICBudyAqPSBhcjtcbiAgbmggKj0gYXI7IC8vIGNhbGMgc291cmNlIHJlY3RhbmdsZVxuXG4gIGN3ID0gaXcgLyAobncgLyB3KTtcbiAgY2ggPSBpaCAvIChuaCAvIGgpO1xuICBjeCA9IChpdyAtIGN3KSAqIG9mZnNldFg7XG4gIGN5ID0gKGloIC0gY2gpICogb2Zmc2V0WTsgLy8gbWFrZSBzdXJlIHNvdXJjZSByZWN0YW5nbGUgaXMgdmFsaWRcblxuICBpZiAoY3ggPCAwKSBjeCA9IDA7XG4gIGlmIChjeSA8IDApIGN5ID0gMDtcbiAgaWYgKGN3ID4gaXcpIGN3ID0gaXc7XG4gIGlmIChjaCA+IGloKSBjaCA9IGloOyAvLyBmaWxsIGltYWdlIGluIGRlc3QuIHJlY3RhbmdsZVxuXG4gIGN0eC5kcmF3SW1hZ2UoaW1nLCBjeCwgY3ksIGN3LCBjaCwgeCwgeSwgdywgaCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-canvas-draw/es/drawImage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-canvas-draw/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-canvas-draw/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CanvasDraw)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var lazy_brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lazy-brush */ \"(ssr)/./node_modules/lazy-brush/lib/index.js\");\n/* harmony import */ var catenary_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! catenary-curve */ \"(ssr)/./node_modules/catenary-curve/lib/index.js\");\n/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resize-observer-polyfill */ \"(ssr)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\");\n/* harmony import */ var _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coordinateSystem */ \"(ssr)/./node_modules/react-canvas-draw/es/coordinateSystem.js\");\n/* harmony import */ var _drawImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawImage */ \"(ssr)/./node_modules/react-canvas-draw/es/drawImage.js\");\n/* harmony import */ var _interactionStateMachine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interactionStateMachine */ \"(ssr)/./node_modules/react-canvas-draw/es/interactionStateMachine.js\");\n/* harmony import */ var _makePassiveEventOption__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./makePassiveEventOption */ \"(ssr)/./node_modules/react-canvas-draw/es/makePassiveEventOption.js\");\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\nfunction midPointBtw(p1, p2) {\n  return {\n    x: p1.x + (p2.x - p1.x) / 2,\n    y: p1.y + (p2.y - p1.y) / 2\n  };\n}\n\nvar canvasStyle = {\n  display: \"block\",\n  position: \"absolute\"\n}; // The order of these is important: grid > drawing > temp > interface\n\nvar canvasTypes = [\"grid\", \"drawing\", \"temp\", \"interface\"];\nvar dimensionsPropTypes =  true ? prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string)]) : 0;\nvar boundsProp =  true ? prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({\n  min: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired,\n  max: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number).isRequired\n}) : 0;\n\nvar CanvasDraw = /*#__PURE__*/function (_PureComponent) {\n  _inheritsLoose(CanvasDraw, _PureComponent);\n\n  ///// public API /////////////////////////////////////////////////////////////\n  function CanvasDraw(props) {\n    var _this;\n\n    _this = _PureComponent.call(this, props) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"undo\", function () {\n      var lines = [];\n\n      if (_this.lines.length) {\n        lines = _this.lines.slice(0, -1);\n      } else if (_this.erasedLines.length) {\n        lines = _this.erasedLines.pop();\n      }\n\n      _this.clearExceptErasedLines();\n\n      _this.simulateDrawingLines({\n        lines: lines,\n        immediate: true\n      });\n\n      _this.triggerOnChange();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"eraseAll\", function () {\n      _this.erasedLines.push([].concat(_this.lines));\n\n      _this.clearExceptErasedLines();\n\n      _this.triggerOnChange();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clear\", function () {\n      _this.erasedLines = [];\n\n      _this.clearExceptErasedLines();\n\n      _this.resetView();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"resetView\", function () {\n      return _this.coordSystem.resetView();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setView\", function (view) {\n      return _this.coordSystem.setView(view);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getSaveData\", function () {\n      // Construct and return the stringified saveData object\n      return JSON.stringify({\n        lines: _this.lines,\n        width: _this.props.canvasWidth,\n        height: _this.props.canvasHeight\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getDataURL\", function (fileType, useBgImage, backgroundColour) {\n      // Get a reference to the \"drawing\" layer of the canvas\n      var canvasToExport = _this.canvas.drawing;\n      var context = canvasToExport.getContext(\"2d\"); //cache height and width\n\n      var width = canvasToExport.width;\n      var height = canvasToExport.height; //get the current ImageData for the canvas\n\n      var storedImageData = context.getImageData(0, 0, width, height); //store the current globalCompositeOperation\n\n      var compositeOperation = context.globalCompositeOperation; //set to draw behind current content\n\n      context.globalCompositeOperation = \"destination-over\"; // If \"useBgImage\" has been set to true, this takes precedence over the background colour parameter\n\n      if (useBgImage) {\n        if (!_this.props.imgSrc) return \"Background image source not set\"; // Write the background image\n\n        _this.drawImage();\n      } else if (backgroundColour != null) {\n        //set background color\n        context.fillStyle = backgroundColour; //fill entire canvas with background colour\n\n        context.fillRect(0, 0, width, height);\n      } // If the file type has not been specified, default to PNG\n\n\n      if (!fileType) fileType = \"png\"; // Export the canvas to data URL\n\n      var imageData = canvasToExport.toDataURL(\"image/\" + fileType); //clear the canvas\n\n      context.clearRect(0, 0, width, height); //restore it with original / cached ImageData\n\n      context.putImageData(storedImageData, 0, 0); //reset the globalCompositeOperation to what it was\n\n      context.globalCompositeOperation = compositeOperation;\n      return imageData;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"loadSaveData\", function (saveData, immediate) {\n      if (immediate === void 0) {\n        immediate = _this.props.immediateLoading;\n      }\n\n      if (typeof saveData !== \"string\") {\n        throw new Error(\"saveData needs to be of type string!\");\n      }\n\n      var _JSON$parse = JSON.parse(saveData),\n          lines = _JSON$parse.lines,\n          width = _JSON$parse.width,\n          height = _JSON$parse.height;\n\n      if (!lines || typeof lines.push !== \"function\") {\n        throw new Error(\"saveData.lines needs to be an array!\");\n      }\n\n      _this.clear();\n\n      if (width === _this.props.canvasWidth && height === _this.props.canvasHeight) {\n        _this.simulateDrawingLines({\n          lines: lines,\n          immediate: immediate\n        });\n      } else {\n        // we need to rescale the lines based on saved & current dimensions\n        var scaleX = _this.props.canvasWidth / width;\n        var scaleY = _this.props.canvasHeight / height;\n        var scaleAvg = (scaleX + scaleY) / 2;\n\n        _this.simulateDrawingLines({\n          lines: lines.map(function (line) {\n            return _extends({}, line, {\n              points: line.points.map(function (p) {\n                return {\n                  x: p.x * scaleX,\n                  y: p.y * scaleY\n                };\n              }),\n              brushRadius: line.brushRadius * scaleAvg\n            });\n          }),\n          immediate: immediate\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function () {\n      _this.canvasObserver.unobserve(_this.canvasContainer);\n\n      _this.canvas[\"interface\"] && _this.canvas[\"interface\"].removeEventListener(\"wheel\", _this.handleWheel);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleWheel\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleMouseWheel(e, _assertThisInitialized(_this));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawStart\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawStart(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawMove\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawMove(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawEnd\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawEnd(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"applyView\", function () {\n      if (!_this.ctx.drawing) {\n        return;\n      }\n\n      canvasTypes.map(function (name) {\n        return _this.ctx[name];\n      }).forEach(function (ctx) {\n        _this.clearWindow(ctx);\n\n        var m = _this.coordSystem.transformMatrix;\n        ctx.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);\n      });\n\n      if (!_this.deferRedrawOnViewChange) {\n        _this.drawGrid(_this.ctx.grid);\n\n        _this.redrawImage();\n\n        _this.loop({\n          once: true\n        });\n\n        var lines = _this.lines;\n        _this.lines = [];\n\n        _this.simulateDrawingLines({\n          lines: lines,\n          immediate: true\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleCanvasResize\", function (entries) {\n      var saveData = _this.getSaveData();\n\n      _this.deferRedrawOnViewChange = true;\n\n      try {\n        for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {\n          var entry = _step.value;\n          var _entry$contentRect = entry.contentRect,\n              width = _entry$contentRect.width,\n              height = _entry$contentRect.height;\n\n          _this.setCanvasSize(_this.canvas[\"interface\"], width, height);\n\n          _this.setCanvasSize(_this.canvas.drawing, width, height);\n\n          _this.setCanvasSize(_this.canvas.temp, width, height);\n\n          _this.setCanvasSize(_this.canvas.grid, width, height);\n\n          _this.coordSystem.documentSize = {\n            width: width,\n            height: height\n          };\n\n          _this.drawGrid(_this.ctx.grid);\n\n          _this.drawImage();\n\n          _this.loop({\n            once: true\n          });\n        }\n\n        _this.loadSaveData(saveData, true);\n      } finally {\n        _this.deferRedrawOnViewChange = false;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clampPointToDocument\", function (point) {\n      if (_this.props.clampLinesToDocument) {\n        return {\n          x: Math.max(Math.min(point.x, _this.props.canvasWidth), 0),\n          y: Math.max(Math.min(point.y, _this.props.canvasHeight), 0)\n        };\n      } else {\n        return point;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"redrawImage\", function () {\n      _this.image && _this.image.complete && (0,_drawImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n        ctx: _this.ctx.grid,\n        img: _this.image\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"simulateDrawingLines\", function (_ref) {\n      var lines = _ref.lines,\n          immediate = _ref.immediate;\n      // Simulate live-drawing of the loaded lines\n      // TODO use a generator\n      var curTime = 0;\n      var timeoutGap = immediate ? 0 : _this.props.loadTimeOffset;\n      lines.forEach(function (line) {\n        var points = line.points,\n            brushColor = line.brushColor,\n            brushRadius = line.brushRadius; // Draw all at once if immediate flag is set, instead of using setTimeout\n\n        if (immediate) {\n          // Draw the points\n          _this.drawPoints({\n            points: points,\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          }); // Save line with the drawn points\n\n\n          _this.points = points;\n\n          _this.saveLine({\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          });\n\n          return;\n        } // Use timeout to draw\n\n\n        var _loop = function _loop(i) {\n          curTime += timeoutGap;\n          window.setTimeout(function () {\n            _this.drawPoints({\n              points: points.slice(0, i + 1),\n              brushColor: brushColor,\n              brushRadius: brushRadius\n            });\n          }, curTime);\n        };\n\n        for (var i = 1; i < points.length; i++) {\n          _loop(i);\n        }\n\n        curTime += timeoutGap;\n        window.setTimeout(function () {\n          // Save this line with its props instead of this.props\n          _this.points = points;\n\n          _this.saveLine({\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          });\n        }, curTime);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setCanvasSize\", function (canvas, width, height) {\n      canvas.width = width;\n      canvas.height = height;\n      canvas.style.width = width;\n      canvas.style.height = height;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawPoints\", function (_ref2) {\n      var points = _ref2.points,\n          brushColor = _ref2.brushColor,\n          brushRadius = _ref2.brushRadius;\n      _this.ctx.temp.lineJoin = \"round\";\n      _this.ctx.temp.lineCap = \"round\";\n      _this.ctx.temp.strokeStyle = brushColor;\n\n      _this.clearWindow(_this.ctx.temp);\n\n      _this.ctx.temp.lineWidth = brushRadius * 2;\n      var p1 = points[0];\n      var p2 = points[1];\n\n      _this.ctx.temp.moveTo(p2.x, p2.y);\n\n      _this.ctx.temp.beginPath();\n\n      for (var i = 1, len = points.length; i < len; i++) {\n        // we pick the point between pi+1 & pi+2 as the\n        // end point and p1 as our control point\n        var midPoint = midPointBtw(p1, p2);\n\n        _this.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n\n        p1 = points[i];\n        p2 = points[i + 1];\n      } // Draw last line as a straight line while\n      // we wait for the next point to be able to calculate\n      // the bezier control point\n\n\n      _this.ctx.temp.lineTo(p1.x, p1.y);\n\n      _this.ctx.temp.stroke();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"saveLine\", function (_temp) {\n      var _ref3 = _temp === void 0 ? {} : _temp,\n          brushColor = _ref3.brushColor,\n          brushRadius = _ref3.brushRadius;\n\n      if (_this.points.length < 2) return; // Save as new line\n\n      _this.lines.push({\n        points: [].concat(_this.points),\n        brushColor: brushColor || _this.props.brushColor,\n        brushRadius: brushRadius || _this.props.brushRadius\n      }); // Reset points array\n\n\n      _this.points.length = 0; // Copy the line to the drawing canvas\n\n      _this.inClientSpace([_this.ctx.drawing, _this.ctx.temp], function () {\n        _this.ctx.drawing.drawImage(_this.canvas.temp, 0, 0, _this.canvas.drawing.width, _this.canvas.drawing.height);\n      }); // Clear the temporary line-drawing canvas\n\n\n      _this.clearWindow(_this.ctx.temp);\n\n      _this.triggerOnChange();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"triggerOnChange\", function () {\n      _this.props.onChange && _this.props.onChange(_assertThisInitialized(_this));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearWindow\", function (ctx) {\n      _this.inClientSpace([ctx], function () {\n        return ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearExceptErasedLines\", function () {\n      _this.lines = [];\n      _this.valuesChanged = true;\n\n      _this.clearWindow(_this.ctx.drawing);\n\n      _this.clearWindow(_this.ctx.temp);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"loop\", function (_temp2) {\n      var _ref4 = _temp2 === void 0 ? {} : _temp2,\n          _ref4$once = _ref4.once,\n          once = _ref4$once === void 0 ? false : _ref4$once;\n\n      if (_this.mouseHasMoved || _this.valuesChanged) {\n        var pointer = _this.lazy.getPointerCoordinates();\n\n        var brush = _this.lazy.getBrushCoordinates();\n\n        _this.drawInterface(_this.ctx[\"interface\"], pointer, brush);\n\n        _this.mouseHasMoved = false;\n        _this.valuesChanged = false;\n      }\n\n      if (!once) {\n        window.requestAnimationFrame(function () {\n          _this.loop();\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"inClientSpace\", function (ctxs, action) {\n      ctxs.forEach(function (ctx) {\n        ctx.save();\n        ctx.setTransform(_coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.a, _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.b, _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.c, _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.d, _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.e, _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__.IDENTITY.f);\n      });\n\n      try {\n        action();\n      } finally {\n        ctxs.forEach(function (ctx) {\n          return ctx.restore();\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawImage\", function () {\n      if (!_this.props.imgSrc) return; // Load the image\n\n      _this.image = new Image(); // Prevent SecurityError \"Tainted canvases may not be exported.\" #70\n\n      _this.image.crossOrigin = \"anonymous\"; // Draw the image once loaded\n\n      _this.image.onload = _this.redrawImage;\n      _this.image.src = _this.props.imgSrc;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawGrid\", function (ctx) {\n      if (_this.props.hideGrid) return;\n\n      _this.clearWindow(ctx);\n\n      var gridSize = 25;\n      var _this$coordSystem$can = _this.coordSystem.canvasBounds,\n          viewMin = _this$coordSystem$can.viewMin,\n          viewMax = _this$coordSystem$can.viewMax;\n      var minx = Math.floor(viewMin.x / gridSize - 1) * gridSize;\n      var miny = Math.floor(viewMin.y / gridSize - 1) * gridSize;\n      var maxx = viewMax.x + gridSize;\n      var maxy = viewMax.y + gridSize;\n      ctx.beginPath();\n      ctx.setLineDash([5, 1]);\n      ctx.setLineDash([]);\n      ctx.strokeStyle = _this.props.gridColor;\n      ctx.lineWidth = _this.props.gridLineWidth;\n\n      if (!_this.props.hideGridX) {\n        var countX = minx;\n        var gridSizeX = _this.props.gridSizeX;\n\n        while (countX < maxx) {\n          countX += gridSizeX;\n          ctx.moveTo(countX, miny);\n          ctx.lineTo(countX, maxy);\n        }\n\n        ctx.stroke();\n      }\n\n      if (!_this.props.hideGridY) {\n        var countY = miny;\n        var gridSizeY = _this.props.gridSizeY;\n\n        while (countY < maxy) {\n          countY += gridSizeY;\n          ctx.moveTo(minx, countY);\n          ctx.lineTo(maxx, countY);\n        }\n\n        ctx.stroke();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawInterface\", function (ctx, pointer, brush) {\n      if (_this.props.hideInterface) return;\n\n      _this.clearWindow(ctx); // Draw brush preview\n\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.brushColor;\n      ctx.arc(brush.x, brush.y, _this.props.brushRadius, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw mouse point (the one directly at the cursor)\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw catenary\n\n      if (_this.lazy.isEnabled()) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.lineCap = \"round\";\n        ctx.setLineDash([2, 4]);\n        ctx.strokeStyle = _this.props.catenaryColor;\n\n        _this.catenary.drawToCanvas(_this.ctx[\"interface\"], brush, pointer, _this.chainLength);\n\n        ctx.stroke();\n      } // Draw brush point (the one in the middle of the brush preview)\n\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\n      ctx.fill();\n    });\n\n    _this.canvas = {};\n    _this.ctx = {};\n    _this.catenary = new catenary_curve__WEBPACK_IMPORTED_MODULE_2__.Catenary();\n    _this.points = [];\n    _this.lines = [];\n    _this.erasedLines = [];\n    _this.mouseHasMoved = true;\n    _this.valuesChanged = true;\n    _this.isDrawing = false;\n    _this.isPressing = false;\n    _this.deferRedrawOnViewChange = false;\n    _this.interactionSM = new _interactionStateMachine__WEBPACK_IMPORTED_MODULE_6__.DefaultState();\n    _this.coordSystem = new _coordinateSystem__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n      scaleExtents: props.zoomExtents,\n      documentSize: {\n        width: props.canvasWidth,\n        height: props.canvasHeight\n      }\n    });\n\n    _this.coordSystem.attachViewChangeListener(_this.applyView.bind(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n\n  var _proto = CanvasDraw.prototype;\n\n  ///// private API ////////////////////////////////////////////////////////////\n  ///// React Lifecycle\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    this.lazy = new lazy_brush__WEBPACK_IMPORTED_MODULE_1__.LazyBrush({\n      radius: this.props.lazyRadius * window.devicePixelRatio,\n      enabled: true,\n      initialPoint: {\n        x: window.innerWidth / 2,\n        y: window.innerHeight / 2\n      }\n    });\n    this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n    this.canvasObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_3__[\"default\"](function (entries, observer) {\n      return _this2.handleCanvasResize(entries, observer);\n    });\n    this.canvasObserver.observe(this.canvasContainer);\n    this.drawImage();\n    this.loop();\n    window.setTimeout(function () {\n      var initX = window.innerWidth / 2;\n      var initY = window.innerHeight / 2;\n\n      _this2.lazy.update({\n        x: initX - _this2.chainLength / 4,\n        y: initY\n      }, {\n        both: true\n      });\n\n      _this2.lazy.update({\n        x: initX + _this2.chainLength / 4,\n        y: initY\n      }, {\n        both: false\n      });\n\n      _this2.mouseHasMoved = true;\n      _this2.valuesChanged = true;\n\n      _this2.clearExceptErasedLines(); // Load saveData from prop if it exists\n\n\n      if (_this2.props.saveData) {\n        _this2.loadSaveData(_this2.props.saveData);\n      }\n    }, 100); // Attach our wheel event listener here instead of in the render so that we can specify a non-passive listener.\n    // This is necessary to prevent the default event action on chrome.\n    // https://github.com/facebook/react/issues/14856\n\n    this.canvas[\"interface\"] && this.canvas[\"interface\"].addEventListener(\"wheel\", this.handleWheel, (0,_makePassiveEventOption__WEBPACK_IMPORTED_MODULE_7__[\"default\"])());\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.lazyRadius !== this.props.lazyRadius) {\n      // Set new lazyRadius values\n      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n      this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);\n    }\n\n    if (prevProps.saveData !== this.props.saveData) {\n      this.loadSaveData(this.props.saveData);\n    }\n\n    if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {\n      // Signal this.loop function that values changed\n      this.valuesChanged = true;\n    }\n\n    this.coordSystem.scaleExtents = this.props.zoomExtents;\n\n    if (!this.props.enablePanAndZoom) {\n      this.coordSystem.resetView();\n    }\n\n    if (prevProps.imgSrc !== this.props.imgSrc) {\n      this.drawImage();\n    }\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n      className: this.props.className,\n      style: _extends({\n        display: \"block\",\n        background: this.props.backgroundColor,\n        touchAction: \"none\",\n        width: this.props.canvasWidth,\n        height: this.props.canvasHeight\n      }, this.props.style),\n      ref: function ref(container) {\n        if (container) {\n          _this3.canvasContainer = container;\n        }\n      }\n    }, canvasTypes.map(function (name) {\n      var isInterface = name === \"interface\";\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"canvas\", {\n        key: name,\n        ref: function ref(canvas) {\n          if (canvas) {\n            _this3.canvas[name] = canvas;\n            _this3.ctx[name] = canvas.getContext(\"2d\");\n\n            if (isInterface) {\n              _this3.coordSystem.canvas = canvas;\n            }\n          }\n        },\n        style: _extends({}, canvasStyle),\n        onMouseDown: isInterface ? _this3.handleDrawStart : undefined,\n        onMouseMove: isInterface ? _this3.handleDrawMove : undefined,\n        onMouseUp: isInterface ? _this3.handleDrawEnd : undefined,\n        onMouseOut: isInterface ? _this3.handleDrawEnd : undefined,\n        onTouchStart: isInterface ? _this3.handleDrawStart : undefined,\n        onTouchMove: isInterface ? _this3.handleDrawMove : undefined,\n        onTouchEnd: isInterface ? _this3.handleDrawEnd : undefined,\n        onTouchCancel: isInterface ? _this3.handleDrawEnd : undefined\n      });\n    }));\n  } ///// Event Handlers\n  ;\n\n  return CanvasDraw;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n\n_defineProperty(CanvasDraw, \"defaultProps\", {\n  onChange: null,\n  loadTimeOffset: 5,\n  lazyRadius: 12,\n  brushRadius: 10,\n  brushColor: \"#444\",\n  catenaryColor: \"#0a0302\",\n  gridColor: \"rgba(150,150,150,0.17)\",\n  backgroundColor: \"#FFF\",\n  hideGrid: false,\n  canvasWidth: 400,\n  canvasHeight: 400,\n  disabled: false,\n  imgSrc: \"\",\n  saveData: \"\",\n  immediateLoading: false,\n  hideInterface: false,\n  gridSizeX: 25,\n  gridSizeY: 25,\n  gridLineWidth: 0.5,\n  hideGridX: false,\n  hideGridY: false,\n  enablePanAndZoom: false,\n  mouseZoomFactor: 0.01,\n  zoomExtents: {\n    min: 0.33,\n    max: 3\n  },\n  clampLinesToDocument: false\n});\n\n\nCanvasDraw.propTypes =  true ? {\n  onChange: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),\n  loadTimeOffset: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  lazyRadius: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  brushRadius: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  brushColor: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  catenaryColor: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  gridColor: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  backgroundColor: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  hideGrid: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  canvasWidth: dimensionsPropTypes,\n  canvasHeight: dimensionsPropTypes,\n  disabled: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  imgSrc: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  saveData: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),\n  immediateLoading: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  hideInterface: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  gridSizeX: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  gridSizeY: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  gridLineWidth: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  hideGridX: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  hideGridY: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  enablePanAndZoom: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),\n  mouseZoomFactor: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),\n  zoomExtents: boundsProp,\n  clampLinesToDocument: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool)\n} : 0;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOERBQThELFFBQVEsbUVBQW1FLHdIQUF3SCxnQkFBZ0IsV0FBVyxxQkFBcUIsNEJBQTRCLGNBQWMsU0FBUyxtQ0FBbUMsZ0tBQWdLLDJCQUEyQjs7QUFFbGtCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SyxzQkFBc0IsZ0RBQWdELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCOztBQUVwUix3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUV2SjtBQUNWO0FBQ0k7QUFDRztBQUNZO0FBQ1U7QUFDNUI7QUFDcUI7QUFDSzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEIsS0FBcUMsR0FBRywyREFBbUIsRUFBRSwwREFBZ0IsRUFBRSwwREFBZ0IsS0FBSyxDQUFFO0FBQ2hJLGlCQUFpQixLQUFxQyxHQUFHLHVEQUFlO0FBQ3hFLE9BQU8sMERBQWdCO0FBQ3ZCLE9BQU8sMERBQWdCO0FBQ3ZCLENBQUMsSUFBSSxDQUFFOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQSwwQ0FBMEM7O0FBRTFDLHVFQUF1RTs7QUFFdkUsaUVBQWlFOztBQUVqRSw2REFBNkQ7O0FBRTdEO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBLFFBQVE7QUFDUjtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSxRQUFROzs7QUFHUix1Q0FBdUM7O0FBRXZDLHFFQUFxRTs7QUFFckUsOENBQThDOztBQUU5QyxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhFQUE4RSw0QkFBNEI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2Q0FBNkMsc0RBQVM7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7OztBQUdkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7OztBQUdWLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLE9BQU8sR0FBRzs7O0FBR1Y7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBUSxJQUFJLHVEQUFRLElBQUksdURBQVEsSUFBSSx1REFBUSxJQUFJLHVEQUFRLElBQUksdURBQVE7QUFDN0YsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUNBQXVDOztBQUV2QyxpQ0FBaUM7O0FBRWpDLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsOEJBQThCOzs7QUFHOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUJBQXlCLG9EQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQVk7QUFDMUMsNEJBQTRCLHlEQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsZ0VBQWM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLHVDQUF1Qzs7O0FBR3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUssUUFBUTtBQUNiO0FBQ0E7O0FBRUEscUdBQXFHLG1FQUFzQjtBQUMzSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QiwwREFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiwwREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRWdDO0FBQ2pDLHVCQUF1QixLQUFxQztBQUM1RCxZQUFZLHdEQUFjO0FBQzFCLGtCQUFrQiwwREFBZ0I7QUFDbEMsY0FBYywwREFBZ0I7QUFDOUIsZUFBZSwwREFBZ0I7QUFDL0IsY0FBYywwREFBZ0I7QUFDOUIsaUJBQWlCLDBEQUFnQjtBQUNqQyxhQUFhLDBEQUFnQjtBQUM3QixtQkFBbUIsMERBQWdCO0FBQ25DLFlBQVksd0RBQWM7QUFDMUI7QUFDQTtBQUNBLFlBQVksd0RBQWM7QUFDMUIsVUFBVSwwREFBZ0I7QUFDMUIsWUFBWSwwREFBZ0I7QUFDNUIsb0JBQW9CLHdEQUFjO0FBQ2xDLGlCQUFpQix3REFBYztBQUMvQixhQUFhLDBEQUFnQjtBQUM3QixhQUFhLDBEQUFnQjtBQUM3QixpQkFBaUIsMERBQWdCO0FBQ2pDLGFBQWEsd0RBQWM7QUFDM0IsYUFBYSx3REFBYztBQUMzQixvQkFBb0Isd0RBQWM7QUFDbEMsbUJBQW1CLDBEQUFnQjtBQUNuQztBQUNBLHdCQUF3Qix3REFBYztBQUN0QyxFQUFFLEVBQUUsQ0FBRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsdXRvLWxlYXJuaW5nLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWNhbnZhcy1kcmF3L2VzL2luZGV4LmpzPzRmNjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgcmV0dXJuIGl0Lm5leHQuYmluZChpdCk7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBMYXp5QnJ1c2ggfSBmcm9tIFwibGF6eS1icnVzaFwiO1xuaW1wb3J0IHsgQ2F0ZW5hcnkgfSBmcm9tIFwiY2F0ZW5hcnktY3VydmVcIjtcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tIFwicmVzaXplLW9ic2VydmVyLXBvbHlmaWxsXCI7XG5pbXBvcnQgQ29vcmRpbmF0ZVN5c3RlbSwgeyBJREVOVElUWSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVTeXN0ZW1cIjtcbmltcG9ydCBkcmF3SW1hZ2UgZnJvbSBcIi4vZHJhd0ltYWdlXCI7XG5pbXBvcnQgeyBEZWZhdWx0U3RhdGUgfSBmcm9tIFwiLi9pbnRlcmFjdGlvblN0YXRlTWFjaGluZVwiO1xuaW1wb3J0IG1ha2VQYXNzaXZlRXZlbnRPcHRpb24gZnJvbSBcIi4vbWFrZVBhc3NpdmVFdmVudE9wdGlvblwiO1xuXG5mdW5jdGlvbiBtaWRQb2ludEJ0dyhwMSwgcDIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgKHAyLnggLSBwMS54KSAvIDIsXG4gICAgeTogcDEueSArIChwMi55IC0gcDEueSkgLyAyXG4gIH07XG59XG5cbnZhciBjYW52YXNTdHlsZSA9IHtcbiAgZGlzcGxheTogXCJibG9ja1wiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG59OyAvLyBUaGUgb3JkZXIgb2YgdGhlc2UgaXMgaW1wb3J0YW50OiBncmlkID4gZHJhd2luZyA+IHRlbXAgPiBpbnRlcmZhY2VcblxudmFyIGNhbnZhc1R5cGVzID0gW1wiZ3JpZFwiLCBcImRyYXdpbmdcIiwgXCJ0ZW1wXCIsIFwiaW50ZXJmYWNlXCJdO1xudmFyIGRpbWVuc2lvbnNQcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkgOiB7fTtcbnZhciBib3VuZHNQcm9wID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUHJvcFR5cGVzLnNoYXBlKHtcbiAgbWluOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIG1heDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG59KSA6IHt9O1xuXG52YXIgQ2FudmFzRHJhdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2FudmFzRHJhdywgX1B1cmVDb21wb25lbnQpO1xuXG4gIC8vLy8vIHB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmdW5jdGlvbiBDYW52YXNEcmF3KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUHVyZUNvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInVuZG9cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxpbmVzID0gW107XG5cbiAgICAgIGlmIChfdGhpcy5saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgbGluZXMgPSBfdGhpcy5saW5lcy5zbGljZSgwLCAtMSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLmVyYXNlZExpbmVzLmxlbmd0aCkge1xuICAgICAgICBsaW5lcyA9IF90aGlzLmVyYXNlZExpbmVzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGVhckV4Y2VwdEVyYXNlZExpbmVzKCk7XG5cbiAgICAgIF90aGlzLnNpbXVsYXRlRHJhd2luZ0xpbmVzKHtcbiAgICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy50cmlnZ2VyT25DaGFuZ2UoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJlcmFzZUFsbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5lcmFzZWRMaW5lcy5wdXNoKFtdLmNvbmNhdChfdGhpcy5saW5lcykpO1xuXG4gICAgICBfdGhpcy5jbGVhckV4Y2VwdEVyYXNlZExpbmVzKCk7XG5cbiAgICAgIF90aGlzLnRyaWdnZXJPbkNoYW5nZSgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsZWFyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmVyYXNlZExpbmVzID0gW107XG5cbiAgICAgIF90aGlzLmNsZWFyRXhjZXB0RXJhc2VkTGluZXMoKTtcblxuICAgICAgX3RoaXMucmVzZXRWaWV3KCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVzZXRWaWV3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jb29yZFN5c3RlbS5yZXNldFZpZXcoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRWaWV3XCIsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICByZXR1cm4gX3RoaXMuY29vcmRTeXN0ZW0uc2V0Vmlldyh2aWV3KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRTYXZlRGF0YVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb25zdHJ1Y3QgYW5kIHJldHVybiB0aGUgc3RyaW5naWZpZWQgc2F2ZURhdGEgb2JqZWN0XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBsaW5lczogX3RoaXMubGluZXMsXG4gICAgICAgIHdpZHRoOiBfdGhpcy5wcm9wcy5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfdGhpcy5wcm9wcy5jYW52YXNIZWlnaHRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldERhdGFVUkxcIiwgZnVuY3Rpb24gKGZpbGVUeXBlLCB1c2VCZ0ltYWdlLCBiYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAvLyBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIFwiZHJhd2luZ1wiIGxheWVyIG9mIHRoZSBjYW52YXNcbiAgICAgIHZhciBjYW52YXNUb0V4cG9ydCA9IF90aGlzLmNhbnZhcy5kcmF3aW5nO1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNUb0V4cG9ydC5nZXRDb250ZXh0KFwiMmRcIik7IC8vY2FjaGUgaGVpZ2h0IGFuZCB3aWR0aFxuXG4gICAgICB2YXIgd2lkdGggPSBjYW52YXNUb0V4cG9ydC53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjYW52YXNUb0V4cG9ydC5oZWlnaHQ7IC8vZ2V0IHRoZSBjdXJyZW50IEltYWdlRGF0YSBmb3IgdGhlIGNhbnZhc1xuXG4gICAgICB2YXIgc3RvcmVkSW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7IC8vc3RvcmUgdGhlIGN1cnJlbnQgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG5cbiAgICAgIHZhciBjb21wb3NpdGVPcGVyYXRpb24gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjsgLy9zZXQgdG8gZHJhdyBiZWhpbmQgY3VycmVudCBjb250ZW50XG5cbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1vdmVyXCI7IC8vIElmIFwidXNlQmdJbWFnZVwiIGhhcyBiZWVuIHNldCB0byB0cnVlLCB0aGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgYmFja2dyb3VuZCBjb2xvdXIgcGFyYW1ldGVyXG5cbiAgICAgIGlmICh1c2VCZ0ltYWdlKSB7XG4gICAgICAgIGlmICghX3RoaXMucHJvcHMuaW1nU3JjKSByZXR1cm4gXCJCYWNrZ3JvdW5kIGltYWdlIHNvdXJjZSBub3Qgc2V0XCI7IC8vIFdyaXRlIHRoZSBiYWNrZ3JvdW5kIGltYWdlXG5cbiAgICAgICAgX3RoaXMuZHJhd0ltYWdlKCk7XG4gICAgICB9IGVsc2UgaWYgKGJhY2tncm91bmRDb2xvdXIgIT0gbnVsbCkge1xuICAgICAgICAvL3NldCBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG91cjsgLy9maWxsIGVudGlyZSBjYW52YXMgd2l0aCBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IC8vIElmIHRoZSBmaWxlIHR5cGUgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZGVmYXVsdCB0byBQTkdcblxuXG4gICAgICBpZiAoIWZpbGVUeXBlKSBmaWxlVHlwZSA9IFwicG5nXCI7IC8vIEV4cG9ydCB0aGUgY2FudmFzIHRvIGRhdGEgVVJMXG5cbiAgICAgIHZhciBpbWFnZURhdGEgPSBjYW52YXNUb0V4cG9ydC50b0RhdGFVUkwoXCJpbWFnZS9cIiArIGZpbGVUeXBlKTsgLy9jbGVhciB0aGUgY2FudmFzXG5cbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpOyAvL3Jlc3RvcmUgaXQgd2l0aCBvcmlnaW5hbCAvIGNhY2hlZCBJbWFnZURhdGFcblxuICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoc3RvcmVkSW1hZ2VEYXRhLCAwLCAwKTsgLy9yZXNldCB0aGUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHRvIHdoYXQgaXQgd2FzXG5cbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsb2FkU2F2ZURhdGFcIiwgZnVuY3Rpb24gKHNhdmVEYXRhLCBpbW1lZGlhdGUpIHtcbiAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBpbW1lZGlhdGUgPSBfdGhpcy5wcm9wcy5pbW1lZGlhdGVMb2FkaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNhdmVEYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhdmVEYXRhIG5lZWRzIHRvIGJlIG9mIHR5cGUgc3RyaW5nIVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9KU09OJHBhcnNlID0gSlNPTi5wYXJzZShzYXZlRGF0YSksXG4gICAgICAgICAgbGluZXMgPSBfSlNPTiRwYXJzZS5saW5lcyxcbiAgICAgICAgICB3aWR0aCA9IF9KU09OJHBhcnNlLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9KU09OJHBhcnNlLmhlaWdodDtcblxuICAgICAgaWYgKCFsaW5lcyB8fCB0eXBlb2YgbGluZXMucHVzaCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNhdmVEYXRhLmxpbmVzIG5lZWRzIHRvIGJlIGFuIGFycmF5IVwiKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2xlYXIoKTtcblxuICAgICAgaWYgKHdpZHRoID09PSBfdGhpcy5wcm9wcy5jYW52YXNXaWR0aCAmJiBoZWlnaHQgPT09IF90aGlzLnByb3BzLmNhbnZhc0hlaWdodCkge1xuICAgICAgICBfdGhpcy5zaW11bGF0ZURyYXdpbmdMaW5lcyh7XG4gICAgICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgICAgIGltbWVkaWF0ZTogaW1tZWRpYXRlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNjYWxlIHRoZSBsaW5lcyBiYXNlZCBvbiBzYXZlZCAmIGN1cnJlbnQgZGltZW5zaW9uc1xuICAgICAgICB2YXIgc2NhbGVYID0gX3RoaXMucHJvcHMuY2FudmFzV2lkdGggLyB3aWR0aDtcbiAgICAgICAgdmFyIHNjYWxlWSA9IF90aGlzLnByb3BzLmNhbnZhc0hlaWdodCAvIGhlaWdodDtcbiAgICAgICAgdmFyIHNjYWxlQXZnID0gKHNjYWxlWCArIHNjYWxlWSkgLyAyO1xuXG4gICAgICAgIF90aGlzLnNpbXVsYXRlRHJhd2luZ0xpbmVzKHtcbiAgICAgICAgICBsaW5lczogbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxpbmUsIHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBsaW5lLnBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgeDogcC54ICogc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgeTogcC55ICogc2NhbGVZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGJydXNoUmFkaXVzOiBsaW5lLmJydXNoUmFkaXVzICogc2NhbGVBdmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGltbWVkaWF0ZTogaW1tZWRpYXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNhbnZhc09ic2VydmVyLnVub2JzZXJ2ZShfdGhpcy5jYW52YXNDb250YWluZXIpO1xuXG4gICAgICBfdGhpcy5jYW52YXNbXCJpbnRlcmZhY2VcIl0gJiYgX3RoaXMuY2FudmFzW1wiaW50ZXJmYWNlXCJdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBfdGhpcy5oYW5kbGVXaGVlbCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlV2hlZWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLmludGVyYWN0aW9uU00gPSBfdGhpcy5pbnRlcmFjdGlvblNNLmhhbmRsZU1vdXNlV2hlZWwoZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMuaW50ZXJhY3Rpb25TTSA9IF90aGlzLmludGVyYWN0aW9uU00uaGFuZGxlRHJhd1N0YXJ0KGUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLm1vdXNlSGFzTW92ZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZURyYXdNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5pbnRlcmFjdGlvblNNID0gX3RoaXMuaW50ZXJhY3Rpb25TTS5oYW5kbGVEcmF3TW92ZShlLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5tb3VzZUhhc01vdmVkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVEcmF3RW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5pbnRlcmFjdGlvblNNID0gX3RoaXMuaW50ZXJhY3Rpb25TTS5oYW5kbGVEcmF3RW5kKGUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLm1vdXNlSGFzTW92ZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFwcGx5Vmlld1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmN0eC5kcmF3aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FudmFzVHlwZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jdHhbbmFtZV07XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgX3RoaXMuY2xlYXJXaW5kb3coY3R4KTtcblxuICAgICAgICB2YXIgbSA9IF90aGlzLmNvb3JkU3lzdGVtLnRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIV90aGlzLmRlZmVyUmVkcmF3T25WaWV3Q2hhbmdlKSB7XG4gICAgICAgIF90aGlzLmRyYXdHcmlkKF90aGlzLmN0eC5ncmlkKTtcblxuICAgICAgICBfdGhpcy5yZWRyYXdJbWFnZSgpO1xuXG4gICAgICAgIF90aGlzLmxvb3Aoe1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGxpbmVzID0gX3RoaXMubGluZXM7XG4gICAgICAgIF90aGlzLmxpbmVzID0gW107XG5cbiAgICAgICAgX3RoaXMuc2ltdWxhdGVEcmF3aW5nTGluZXMoe1xuICAgICAgICAgIGxpbmVzOiBsaW5lcyxcbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2FudmFzUmVzaXplXCIsIGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICB2YXIgc2F2ZURhdGEgPSBfdGhpcy5nZXRTYXZlRGF0YSgpO1xuXG4gICAgICBfdGhpcy5kZWZlclJlZHJhd09uVmlld0NoYW5nZSA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoZW50cmllcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIF9lbnRyeSRjb250ZW50UmVjdCA9IGVudHJ5LmNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgICB3aWR0aCA9IF9lbnRyeSRjb250ZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gX2VudHJ5JGNvbnRlbnRSZWN0LmhlaWdodDtcblxuICAgICAgICAgIF90aGlzLnNldENhbnZhc1NpemUoX3RoaXMuY2FudmFzW1wiaW50ZXJmYWNlXCJdLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgIF90aGlzLnNldENhbnZhc1NpemUoX3RoaXMuY2FudmFzLmRyYXdpbmcsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgX3RoaXMuc2V0Q2FudmFzU2l6ZShfdGhpcy5jYW52YXMudGVtcCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICBfdGhpcy5zZXRDYW52YXNTaXplKF90aGlzLmNhbnZhcy5ncmlkLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgIF90aGlzLmNvb3JkU3lzdGVtLmRvY3VtZW50U2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLmRyYXdHcmlkKF90aGlzLmN0eC5ncmlkKTtcblxuICAgICAgICAgIF90aGlzLmRyYXdJbWFnZSgpO1xuXG4gICAgICAgICAgX3RoaXMubG9vcCh7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5sb2FkU2F2ZURhdGEoc2F2ZURhdGEsIHRydWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX3RoaXMuZGVmZXJSZWRyYXdPblZpZXdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGFtcFBvaW50VG9Eb2N1bWVudFwiLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5jbGFtcExpbmVzVG9Eb2N1bWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgubWF4KE1hdGgubWluKHBvaW50LngsIF90aGlzLnByb3BzLmNhbnZhc1dpZHRoKSwgMCksXG4gICAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4ocG9pbnQueSwgX3RoaXMucHJvcHMuY2FudmFzSGVpZ2h0KSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJyZWRyYXdJbWFnZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5pbWFnZSAmJiBfdGhpcy5pbWFnZS5jb21wbGV0ZSAmJiBkcmF3SW1hZ2Uoe1xuICAgICAgICBjdHg6IF90aGlzLmN0eC5ncmlkLFxuICAgICAgICBpbWc6IF90aGlzLmltYWdlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzaW11bGF0ZURyYXdpbmdMaW5lc1wiLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGxpbmVzID0gX3JlZi5saW5lcyxcbiAgICAgICAgICBpbW1lZGlhdGUgPSBfcmVmLmltbWVkaWF0ZTtcbiAgICAgIC8vIFNpbXVsYXRlIGxpdmUtZHJhd2luZyBvZiB0aGUgbG9hZGVkIGxpbmVzXG4gICAgICAvLyBUT0RPIHVzZSBhIGdlbmVyYXRvclxuICAgICAgdmFyIGN1clRpbWUgPSAwO1xuICAgICAgdmFyIHRpbWVvdXRHYXAgPSBpbW1lZGlhdGUgPyAwIDogX3RoaXMucHJvcHMubG9hZFRpbWVPZmZzZXQ7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBsaW5lLnBvaW50cyxcbiAgICAgICAgICAgIGJydXNoQ29sb3IgPSBsaW5lLmJydXNoQ29sb3IsXG4gICAgICAgICAgICBicnVzaFJhZGl1cyA9IGxpbmUuYnJ1c2hSYWRpdXM7IC8vIERyYXcgYWxsIGF0IG9uY2UgaWYgaW1tZWRpYXRlIGZsYWcgaXMgc2V0LCBpbnN0ZWFkIG9mIHVzaW5nIHNldFRpbWVvdXRcblxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgLy8gRHJhdyB0aGUgcG9pbnRzXG4gICAgICAgICAgX3RoaXMuZHJhd1BvaW50cyh7XG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgIGJydXNoQ29sb3I6IGJydXNoQ29sb3IsXG4gICAgICAgICAgICBicnVzaFJhZGl1czogYnJ1c2hSYWRpdXNcbiAgICAgICAgICB9KTsgLy8gU2F2ZSBsaW5lIHdpdGggdGhlIGRyYXduIHBvaW50c1xuXG5cbiAgICAgICAgICBfdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAgICAgICBfdGhpcy5zYXZlTGluZSh7XG4gICAgICAgICAgICBicnVzaENvbG9yOiBicnVzaENvbG9yLFxuICAgICAgICAgICAgYnJ1c2hSYWRpdXM6IGJydXNoUmFkaXVzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVXNlIHRpbWVvdXQgdG8gZHJhd1xuXG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIGN1clRpbWUgKz0gdGltZW91dEdhcDtcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kcmF3UG9pbnRzKHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMuc2xpY2UoMCwgaSArIDEpLFxuICAgICAgICAgICAgICBicnVzaENvbG9yOiBicnVzaENvbG9yLFxuICAgICAgICAgICAgICBicnVzaFJhZGl1czogYnJ1c2hSYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGN1clRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJUaW1lICs9IHRpbWVvdXRHYXA7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBTYXZlIHRoaXMgbGluZSB3aXRoIGl0cyBwcm9wcyBpbnN0ZWFkIG9mIHRoaXMucHJvcHNcbiAgICAgICAgICBfdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAgICAgICBfdGhpcy5zYXZlTGluZSh7XG4gICAgICAgICAgICBicnVzaENvbG9yOiBicnVzaENvbG9yLFxuICAgICAgICAgICAgYnJ1c2hSYWRpdXM6IGJydXNoUmFkaXVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGN1clRpbWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0Q2FudmFzU2l6ZVwiLCBmdW5jdGlvbiAoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZHJhd1BvaW50c1wiLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBwb2ludHMgPSBfcmVmMi5wb2ludHMsXG4gICAgICAgICAgYnJ1c2hDb2xvciA9IF9yZWYyLmJydXNoQ29sb3IsXG4gICAgICAgICAgYnJ1c2hSYWRpdXMgPSBfcmVmMi5icnVzaFJhZGl1cztcbiAgICAgIF90aGlzLmN0eC50ZW1wLmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgX3RoaXMuY3R4LnRlbXAubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgIF90aGlzLmN0eC50ZW1wLnN0cm9rZVN0eWxlID0gYnJ1c2hDb2xvcjtcblxuICAgICAgX3RoaXMuY2xlYXJXaW5kb3coX3RoaXMuY3R4LnRlbXApO1xuXG4gICAgICBfdGhpcy5jdHgudGVtcC5saW5lV2lkdGggPSBicnVzaFJhZGl1cyAqIDI7XG4gICAgICB2YXIgcDEgPSBwb2ludHNbMF07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbMV07XG5cbiAgICAgIF90aGlzLmN0eC50ZW1wLm1vdmVUbyhwMi54LCBwMi55KTtcblxuICAgICAgX3RoaXMuY3R4LnRlbXAuYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgcG9pbnQgYmV0d2VlbiBwaSsxICYgcGkrMiBhcyB0aGVcbiAgICAgICAgLy8gZW5kIHBvaW50IGFuZCBwMSBhcyBvdXIgY29udHJvbCBwb2ludFxuICAgICAgICB2YXIgbWlkUG9pbnQgPSBtaWRQb2ludEJ0dyhwMSwgcDIpO1xuXG4gICAgICAgIF90aGlzLmN0eC50ZW1wLnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG5cbiAgICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICAgIHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH0gLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG5cblxuICAgICAgX3RoaXMuY3R4LnRlbXAubGluZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBfdGhpcy5jdHgudGVtcC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzYXZlTGluZVwiLCBmdW5jdGlvbiAoX3RlbXApIHtcbiAgICAgIHZhciBfcmVmMyA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICAgIGJydXNoQ29sb3IgPSBfcmVmMy5icnVzaENvbG9yLFxuICAgICAgICAgIGJydXNoUmFkaXVzID0gX3JlZjMuYnJ1c2hSYWRpdXM7XG5cbiAgICAgIGlmIChfdGhpcy5wb2ludHMubGVuZ3RoIDwgMikgcmV0dXJuOyAvLyBTYXZlIGFzIG5ldyBsaW5lXG5cbiAgICAgIF90aGlzLmxpbmVzLnB1c2goe1xuICAgICAgICBwb2ludHM6IFtdLmNvbmNhdChfdGhpcy5wb2ludHMpLFxuICAgICAgICBicnVzaENvbG9yOiBicnVzaENvbG9yIHx8IF90aGlzLnByb3BzLmJydXNoQ29sb3IsXG4gICAgICAgIGJydXNoUmFkaXVzOiBicnVzaFJhZGl1cyB8fCBfdGhpcy5wcm9wcy5icnVzaFJhZGl1c1xuICAgICAgfSk7IC8vIFJlc2V0IHBvaW50cyBhcnJheVxuXG5cbiAgICAgIF90aGlzLnBvaW50cy5sZW5ndGggPSAwOyAvLyBDb3B5IHRoZSBsaW5lIHRvIHRoZSBkcmF3aW5nIGNhbnZhc1xuXG4gICAgICBfdGhpcy5pbkNsaWVudFNwYWNlKFtfdGhpcy5jdHguZHJhd2luZywgX3RoaXMuY3R4LnRlbXBdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmN0eC5kcmF3aW5nLmRyYXdJbWFnZShfdGhpcy5jYW52YXMudGVtcCwgMCwgMCwgX3RoaXMuY2FudmFzLmRyYXdpbmcud2lkdGgsIF90aGlzLmNhbnZhcy5kcmF3aW5nLmhlaWdodCk7XG4gICAgICB9KTsgLy8gQ2xlYXIgdGhlIHRlbXBvcmFyeSBsaW5lLWRyYXdpbmcgY2FudmFzXG5cblxuICAgICAgX3RoaXMuY2xlYXJXaW5kb3coX3RoaXMuY3R4LnRlbXApO1xuXG4gICAgICBfdGhpcy50cmlnZ2VyT25DaGFuZ2UoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0cmlnZ2VyT25DaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UgJiYgX3RoaXMucHJvcHMub25DaGFuZ2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsZWFyV2luZG93XCIsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIF90aGlzLmluQ2xpZW50U3BhY2UoW2N0eF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jbGVhclJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2xlYXJFeGNlcHRFcmFzZWRMaW5lc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5saW5lcyA9IFtdO1xuICAgICAgX3RoaXMudmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgIF90aGlzLmNsZWFyV2luZG93KF90aGlzLmN0eC5kcmF3aW5nKTtcblxuICAgICAgX3RoaXMuY2xlYXJXaW5kb3coX3RoaXMuY3R4LnRlbXApO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxvb3BcIiwgZnVuY3Rpb24gKF90ZW1wMikge1xuICAgICAgdmFyIF9yZWY0ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMixcbiAgICAgICAgICBfcmVmNCRvbmNlID0gX3JlZjQub25jZSxcbiAgICAgICAgICBvbmNlID0gX3JlZjQkb25jZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRvbmNlO1xuXG4gICAgICBpZiAoX3RoaXMubW91c2VIYXNNb3ZlZCB8fCBfdGhpcy52YWx1ZXNDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMubGF6eS5nZXRQb2ludGVyQ29vcmRpbmF0ZXMoKTtcblxuICAgICAgICB2YXIgYnJ1c2ggPSBfdGhpcy5sYXp5LmdldEJydXNoQ29vcmRpbmF0ZXMoKTtcblxuICAgICAgICBfdGhpcy5kcmF3SW50ZXJmYWNlKF90aGlzLmN0eFtcImludGVyZmFjZVwiXSwgcG9pbnRlciwgYnJ1c2gpO1xuXG4gICAgICAgIF90aGlzLm1vdXNlSGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9uY2UpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMubG9vcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpbkNsaWVudFNwYWNlXCIsIGZ1bmN0aW9uIChjdHhzLCBhY3Rpb24pIHtcbiAgICAgIGN0eHMuZm9yRWFjaChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oSURFTlRJVFkuYSwgSURFTlRJVFkuYiwgSURFTlRJVFkuYywgSURFTlRJVFkuZCwgSURFTlRJVFkuZSwgSURFTlRJVFkuZik7XG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYWN0aW9uKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdHhzLmZvckVhY2goZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkcmF3SW1hZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbWdTcmMpIHJldHVybjsgLy8gTG9hZCB0aGUgaW1hZ2VcblxuICAgICAgX3RoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gUHJldmVudCBTZWN1cml0eUVycm9yIFwiVGFpbnRlZCBjYW52YXNlcyBtYXkgbm90IGJlIGV4cG9ydGVkLlwiICM3MFxuXG4gICAgICBfdGhpcy5pbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7IC8vIERyYXcgdGhlIGltYWdlIG9uY2UgbG9hZGVkXG5cbiAgICAgIF90aGlzLmltYWdlLm9ubG9hZCA9IF90aGlzLnJlZHJhd0ltYWdlO1xuICAgICAgX3RoaXMuaW1hZ2Uuc3JjID0gX3RoaXMucHJvcHMuaW1nU3JjO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRyYXdHcmlkXCIsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5oaWRlR3JpZCkgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5jbGVhcldpbmRvdyhjdHgpO1xuXG4gICAgICB2YXIgZ3JpZFNpemUgPSAyNTtcbiAgICAgIHZhciBfdGhpcyRjb29yZFN5c3RlbSRjYW4gPSBfdGhpcy5jb29yZFN5c3RlbS5jYW52YXNCb3VuZHMsXG4gICAgICAgICAgdmlld01pbiA9IF90aGlzJGNvb3JkU3lzdGVtJGNhbi52aWV3TWluLFxuICAgICAgICAgIHZpZXdNYXggPSBfdGhpcyRjb29yZFN5c3RlbSRjYW4udmlld01heDtcbiAgICAgIHZhciBtaW54ID0gTWF0aC5mbG9vcih2aWV3TWluLnggLyBncmlkU2l6ZSAtIDEpICogZ3JpZFNpemU7XG4gICAgICB2YXIgbWlueSA9IE1hdGguZmxvb3Iodmlld01pbi55IC8gZ3JpZFNpemUgLSAxKSAqIGdyaWRTaXplO1xuICAgICAgdmFyIG1heHggPSB2aWV3TWF4LnggKyBncmlkU2l6ZTtcbiAgICAgIHZhciBtYXh5ID0gdmlld01heC55ICsgZ3JpZFNpemU7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goWzUsIDFdKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfdGhpcy5wcm9wcy5ncmlkQ29sb3I7XG4gICAgICBjdHgubGluZVdpZHRoID0gX3RoaXMucHJvcHMuZ3JpZExpbmVXaWR0aDtcblxuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5oaWRlR3JpZFgpIHtcbiAgICAgICAgdmFyIGNvdW50WCA9IG1pbng7XG4gICAgICAgIHZhciBncmlkU2l6ZVggPSBfdGhpcy5wcm9wcy5ncmlkU2l6ZVg7XG5cbiAgICAgICAgd2hpbGUgKGNvdW50WCA8IG1heHgpIHtcbiAgICAgICAgICBjb3VudFggKz0gZ3JpZFNpemVYO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oY291bnRYLCBtaW55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGNvdW50WCwgbWF4eSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuaGlkZUdyaWRZKSB7XG4gICAgICAgIHZhciBjb3VudFkgPSBtaW55O1xuICAgICAgICB2YXIgZ3JpZFNpemVZID0gX3RoaXMucHJvcHMuZ3JpZFNpemVZO1xuXG4gICAgICAgIHdoaWxlIChjb3VudFkgPCBtYXh5KSB7XG4gICAgICAgICAgY291bnRZICs9IGdyaWRTaXplWTtcbiAgICAgICAgICBjdHgubW92ZVRvKG1pbngsIGNvdW50WSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhtYXh4LCBjb3VudFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRyYXdJbnRlcmZhY2VcIiwgZnVuY3Rpb24gKGN0eCwgcG9pbnRlciwgYnJ1c2gpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5oaWRlSW50ZXJmYWNlKSByZXR1cm47XG5cbiAgICAgIF90aGlzLmNsZWFyV2luZG93KGN0eCk7IC8vIERyYXcgYnJ1c2ggcHJldmlld1xuXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBfdGhpcy5wcm9wcy5icnVzaENvbG9yO1xuICAgICAgY3R4LmFyYyhicnVzaC54LCBicnVzaC55LCBfdGhpcy5wcm9wcy5icnVzaFJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgY3R4LmZpbGwoKTsgLy8gRHJhdyBtb3VzZSBwb2ludCAodGhlIG9uZSBkaXJlY3RseSBhdCB0aGUgY3Vyc29yKVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gX3RoaXMucHJvcHMuY2F0ZW5hcnlDb2xvcjtcbiAgICAgIGN0eC5hcmMocG9pbnRlci54LCBwb2ludGVyLnksIDQsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIGN0eC5maWxsKCk7IC8vIERyYXcgY2F0ZW5hcnlcblxuICAgICAgaWYgKF90aGlzLmxhenkuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMiwgNF0pO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfdGhpcy5wcm9wcy5jYXRlbmFyeUNvbG9yO1xuXG4gICAgICAgIF90aGlzLmNhdGVuYXJ5LmRyYXdUb0NhbnZhcyhfdGhpcy5jdHhbXCJpbnRlcmZhY2VcIl0sIGJydXNoLCBwb2ludGVyLCBfdGhpcy5jaGFpbkxlbmd0aCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSAvLyBEcmF3IGJydXNoIHBvaW50ICh0aGUgb25lIGluIHRoZSBtaWRkbGUgb2YgdGhlIGJydXNoIHByZXZpZXcpXG5cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IF90aGlzLnByb3BzLmNhdGVuYXJ5Q29sb3I7XG4gICAgICBjdHguYXJjKGJydXNoLngsIGJydXNoLnksIDIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5jYW52YXMgPSB7fTtcbiAgICBfdGhpcy5jdHggPSB7fTtcbiAgICBfdGhpcy5jYXRlbmFyeSA9IG5ldyBDYXRlbmFyeSgpO1xuICAgIF90aGlzLnBvaW50cyA9IFtdO1xuICAgIF90aGlzLmxpbmVzID0gW107XG4gICAgX3RoaXMuZXJhc2VkTGluZXMgPSBbXTtcbiAgICBfdGhpcy5tb3VzZUhhc01vdmVkID0gdHJ1ZTtcbiAgICBfdGhpcy52YWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICBfdGhpcy5pc0RyYXdpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1ByZXNzaW5nID0gZmFsc2U7XG4gICAgX3RoaXMuZGVmZXJSZWRyYXdPblZpZXdDaGFuZ2UgPSBmYWxzZTtcbiAgICBfdGhpcy5pbnRlcmFjdGlvblNNID0gbmV3IERlZmF1bHRTdGF0ZSgpO1xuICAgIF90aGlzLmNvb3JkU3lzdGVtID0gbmV3IENvb3JkaW5hdGVTeXN0ZW0oe1xuICAgICAgc2NhbGVFeHRlbnRzOiBwcm9wcy56b29tRXh0ZW50cyxcbiAgICAgIGRvY3VtZW50U2l6ZToge1xuICAgICAgICB3aWR0aDogcHJvcHMuY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogcHJvcHMuY2FudmFzSGVpZ2h0XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfdGhpcy5jb29yZFN5c3RlbS5hdHRhY2hWaWV3Q2hhbmdlTGlzdGVuZXIoX3RoaXMuYXBwbHlWaWV3LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYW52YXNEcmF3LnByb3RvdHlwZTtcblxuICAvLy8vLyBwcml2YXRlIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8gUmVhY3QgTGlmZWN5Y2xlXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5sYXp5ID0gbmV3IExhenlCcnVzaCh7XG4gICAgICByYWRpdXM6IHRoaXMucHJvcHMubGF6eVJhZGl1cyAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGluaXRpYWxQb2ludDoge1xuICAgICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCAvIDIsXG4gICAgICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDJcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNoYWluTGVuZ3RoID0gdGhpcy5wcm9wcy5sYXp5UmFkaXVzICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5jYW52YXNPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcywgb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBfdGhpczIuaGFuZGxlQ2FudmFzUmVzaXplKGVudHJpZXMsIG9ic2VydmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhc09ic2VydmVyLm9ic2VydmUodGhpcy5jYW52YXNDb250YWluZXIpO1xuICAgIHRoaXMuZHJhd0ltYWdlKCk7XG4gICAgdGhpcy5sb29wKCk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGluaXRYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xuICAgICAgdmFyIGluaXRZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcblxuICAgICAgX3RoaXMyLmxhenkudXBkYXRlKHtcbiAgICAgICAgeDogaW5pdFggLSBfdGhpczIuY2hhaW5MZW5ndGggLyA0LFxuICAgICAgICB5OiBpbml0WVxuICAgICAgfSwge1xuICAgICAgICBib3RoOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMyLmxhenkudXBkYXRlKHtcbiAgICAgICAgeDogaW5pdFggKyBfdGhpczIuY2hhaW5MZW5ndGggLyA0LFxuICAgICAgICB5OiBpbml0WVxuICAgICAgfSwge1xuICAgICAgICBib3RoOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzMi5tb3VzZUhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIF90aGlzMi52YWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgX3RoaXMyLmNsZWFyRXhjZXB0RXJhc2VkTGluZXMoKTsgLy8gTG9hZCBzYXZlRGF0YSBmcm9tIHByb3AgaWYgaXQgZXhpc3RzXG5cblxuICAgICAgaWYgKF90aGlzMi5wcm9wcy5zYXZlRGF0YSkge1xuICAgICAgICBfdGhpczIubG9hZFNhdmVEYXRhKF90aGlzMi5wcm9wcy5zYXZlRGF0YSk7XG4gICAgICB9XG4gICAgfSwgMTAwKTsgLy8gQXR0YWNoIG91ciB3aGVlbCBldmVudCBsaXN0ZW5lciBoZXJlIGluc3RlYWQgb2YgaW4gdGhlIHJlbmRlciBzbyB0aGF0IHdlIGNhbiBzcGVjaWZ5IGEgbm9uLXBhc3NpdmUgbGlzdGVuZXIuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBldmVudCBhY3Rpb24gb24gY2hyb21lLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ4NTZcblxuICAgIHRoaXMuY2FudmFzW1wiaW50ZXJmYWNlXCJdICYmIHRoaXMuY2FudmFzW1wiaW50ZXJmYWNlXCJdLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLmhhbmRsZVdoZWVsLCBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCkpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHByZXZQcm9wcy5sYXp5UmFkaXVzICE9PSB0aGlzLnByb3BzLmxhenlSYWRpdXMpIHtcbiAgICAgIC8vIFNldCBuZXcgbGF6eVJhZGl1cyB2YWx1ZXNcbiAgICAgIHRoaXMuY2hhaW5MZW5ndGggPSB0aGlzLnByb3BzLmxhenlSYWRpdXMgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHRoaXMubGF6eS5zZXRSYWRpdXModGhpcy5wcm9wcy5sYXp5UmFkaXVzICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIGlmIChwcmV2UHJvcHMuc2F2ZURhdGEgIT09IHRoaXMucHJvcHMuc2F2ZURhdGEpIHtcbiAgICAgIHRoaXMubG9hZFNhdmVEYXRhKHRoaXMucHJvcHMuc2F2ZURhdGEpO1xuICAgIH1cblxuICAgIGlmIChKU09OLnN0cmluZ2lmeShwcmV2UHJvcHMpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnByb3BzKSkge1xuICAgICAgLy8gU2lnbmFsIHRoaXMubG9vcCBmdW5jdGlvbiB0aGF0IHZhbHVlcyBjaGFuZ2VkXG4gICAgICB0aGlzLnZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuY29vcmRTeXN0ZW0uc2NhbGVFeHRlbnRzID0gdGhpcy5wcm9wcy56b29tRXh0ZW50cztcblxuICAgIGlmICghdGhpcy5wcm9wcy5lbmFibGVQYW5BbmRab29tKSB7XG4gICAgICB0aGlzLmNvb3JkU3lzdGVtLnJlc2V0VmlldygpO1xuICAgIH1cblxuICAgIGlmIChwcmV2UHJvcHMuaW1nU3JjICE9PSB0aGlzLnByb3BzLmltZ1NyYykge1xuICAgICAgdGhpcy5kcmF3SW1hZ2UoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLnByb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgICAgICB3aWR0aDogdGhpcy5wcm9wcy5jYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmNhbnZhc0hlaWdodFxuICAgICAgfSwgdGhpcy5wcm9wcy5zdHlsZSksXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgIF90aGlzMy5jYW52YXNDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBjYW52YXNUeXBlcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpc0ludGVyZmFjZSA9IG5hbWUgPT09IFwiaW50ZXJmYWNlXCI7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgICAgICBrZXk6IG5hbWUsXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGNhbnZhcykge1xuICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIF90aGlzMy5jYW52YXNbbmFtZV0gPSBjYW52YXM7XG4gICAgICAgICAgICBfdGhpczMuY3R4W25hbWVdID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgaWYgKGlzSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5jb29yZFN5c3RlbS5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNhbnZhc1N0eWxlKSxcbiAgICAgICAgb25Nb3VzZURvd246IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdTdGFydCA6IHVuZGVmaW5lZCxcbiAgICAgICAgb25Nb3VzZU1vdmU6IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdNb3ZlIDogdW5kZWZpbmVkLFxuICAgICAgICBvbk1vdXNlVXA6IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdFbmQgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uTW91c2VPdXQ6IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdFbmQgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uVG91Y2hTdGFydDogaXNJbnRlcmZhY2UgPyBfdGhpczMuaGFuZGxlRHJhd1N0YXJ0IDogdW5kZWZpbmVkLFxuICAgICAgICBvblRvdWNoTW92ZTogaXNJbnRlcmZhY2UgPyBfdGhpczMuaGFuZGxlRHJhd01vdmUgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uVG91Y2hFbmQ6IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdFbmQgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uVG91Y2hDYW5jZWw6IGlzSW50ZXJmYWNlID8gX3RoaXMzLmhhbmRsZURyYXdFbmQgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfSAvLy8vLyBFdmVudCBIYW5kbGVyc1xuICA7XG5cbiAgcmV0dXJuIENhbnZhc0RyYXc7XG59KFB1cmVDb21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoQ2FudmFzRHJhdywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBvbkNoYW5nZTogbnVsbCxcbiAgbG9hZFRpbWVPZmZzZXQ6IDUsXG4gIGxhenlSYWRpdXM6IDEyLFxuICBicnVzaFJhZGl1czogMTAsXG4gIGJydXNoQ29sb3I6IFwiIzQ0NFwiLFxuICBjYXRlbmFyeUNvbG9yOiBcIiMwYTAzMDJcIixcbiAgZ3JpZENvbG9yOiBcInJnYmEoMTUwLDE1MCwxNTAsMC4xNylcIixcbiAgYmFja2dyb3VuZENvbG9yOiBcIiNGRkZcIixcbiAgaGlkZUdyaWQ6IGZhbHNlLFxuICBjYW52YXNXaWR0aDogNDAwLFxuICBjYW52YXNIZWlnaHQ6IDQwMCxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBpbWdTcmM6IFwiXCIsXG4gIHNhdmVEYXRhOiBcIlwiLFxuICBpbW1lZGlhdGVMb2FkaW5nOiBmYWxzZSxcbiAgaGlkZUludGVyZmFjZTogZmFsc2UsXG4gIGdyaWRTaXplWDogMjUsXG4gIGdyaWRTaXplWTogMjUsXG4gIGdyaWRMaW5lV2lkdGg6IDAuNSxcbiAgaGlkZUdyaWRYOiBmYWxzZSxcbiAgaGlkZUdyaWRZOiBmYWxzZSxcbiAgZW5hYmxlUGFuQW5kWm9vbTogZmFsc2UsXG4gIG1vdXNlWm9vbUZhY3RvcjogMC4wMSxcbiAgem9vbUV4dGVudHM6IHtcbiAgICBtaW46IDAuMzMsXG4gICAgbWF4OiAzXG4gIH0sXG4gIGNsYW1wTGluZXNUb0RvY3VtZW50OiBmYWxzZVxufSk7XG5cbmV4cG9ydCB7IENhbnZhc0RyYXcgYXMgZGVmYXVsdCB9O1xuQ2FudmFzRHJhdy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgbG9hZFRpbWVPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhenlSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIGJydXNoUmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBicnVzaENvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjYXRlbmFyeUNvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBncmlkQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJhY2tncm91bmRDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgaGlkZUdyaWQ6IFByb3BUeXBlcy5ib29sLFxuICBjYW52YXNXaWR0aDogZGltZW5zaW9uc1Byb3BUeXBlcyxcbiAgY2FudmFzSGVpZ2h0OiBkaW1lbnNpb25zUHJvcFR5cGVzLFxuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGltZ1NyYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2F2ZURhdGE6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGltbWVkaWF0ZUxvYWRpbmc6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlSW50ZXJmYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ3JpZFNpemVYOiBQcm9wVHlwZXMubnVtYmVyLFxuICBncmlkU2l6ZVk6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdyaWRMaW5lV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhpZGVHcmlkWDogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVHcmlkWTogUHJvcFR5cGVzLmJvb2wsXG4gIGVuYWJsZVBhbkFuZFpvb206IFByb3BUeXBlcy5ib29sLFxuICBtb3VzZVpvb21GYWN0b3I6IFByb3BUeXBlcy5udW1iZXIsXG4gIHpvb21FeHRlbnRzOiBib3VuZHNQcm9wLFxuICBjbGFtcExpbmVzVG9Eb2N1bWVudDogUHJvcFR5cGVzLmJvb2xcbn0gOiB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-canvas-draw/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-canvas-draw/es/interactionStateMachine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-canvas-draw/es/interactionStateMachine.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultState: () => (/* binding */ DefaultState),\n/* harmony export */   DisabledState: () => (/* binding */ DisabledState),\n/* harmony export */   DrawingState: () => (/* binding */ DrawingState),\n/* harmony export */   PanState: () => (/* binding */ PanState),\n/* harmony export */   ScaleOrPanState: () => (/* binding */ ScaleOrPanState),\n/* harmony export */   SyntheticEvent: () => (/* binding */ SyntheticEvent),\n/* harmony export */   TouchPanState: () => (/* binding */ TouchPanState),\n/* harmony export */   TouchScaleState: () => (/* binding */ TouchScaleState),\n/* harmony export */   WaitForPinchState: () => (/* binding */ WaitForPinchState),\n/* harmony export */   clientPointFromEvent: () => (/* binding */ clientPointFromEvent),\n/* harmony export */   viewPointFromEvent: () => (/* binding */ viewPointFromEvent)\n/* harmony export */ });\nvar _this = undefined;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TOUCH_SLOP = 10;\nvar PINCH_TIMEOUT_MS = 250;\n\nvar SUPPRESS_SCROLL = function SUPPRESS_SCROLL(e) {\n  // No zooming while drawing, but we'll cancel the scroll event.\n  e.preventDefault();\n  return _this;\n};\n/**\n * The default state for the interaction state machine. Supports zoom and\n * initiating pan and drawing actions.\n */\n\n\nvar DefaultState = function DefaultState() {\n  var _this2 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", function (e, canvasDraw) {\n    var _canvasDraw$props = canvasDraw.props,\n        disabled = _canvasDraw$props.disabled,\n        enablePanAndZoom = _canvasDraw$props.enablePanAndZoom,\n        mouseZoomFactor = _canvasDraw$props.mouseZoomFactor;\n\n    if (disabled) {\n      return new DisabledState();\n    } else if (enablePanAndZoom && e.ctrlKey) {\n      e.preventDefault();\n      canvasDraw.coordSystem.scaleAtClientPoint(mouseZoomFactor * e.deltaY, clientPointFromEvent(e));\n    }\n\n    return _this2;\n  });\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return new DisabledState();\n    } else if (e.ctrlKey && canvasDraw.props.enablePanAndZoom) {\n      return new PanState().handleDrawStart(e, canvasDraw);\n    } else {\n      return new WaitForPinchState().handleDrawStart(e, canvasDraw);\n    }\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return new DisabledState();\n    } else {\n      var _viewPointFromEvent = viewPointFromEvent(canvasDraw.coordSystem, e),\n          x = _viewPointFromEvent.x,\n          y = _viewPointFromEvent.y;\n\n      canvasDraw.lazy.update({\n        x: x,\n        y: y\n      });\n      return _this2;\n    }\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    return canvasDraw.props.disabled ? new DisabledState() : _this2;\n  });\n};\n;\n/**\n * This state is used as long as the disabled prop is active. It ignores all\n * events and doesn't prevent default actions. The disabled state can only be\n * triggered from the default state (i.e., while no action is actively being\n * performed).\n */\n\nvar DisabledState = function DisabledState() {\n  var _this3 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleMouseWheel(e, canvasDraw);\n    }\n  });\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawStart(e, canvasDraw);\n    }\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawMove(e, canvasDraw);\n    }\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawEnd(e, canvasDraw);\n    }\n  });\n};\n/**\n * This state is active as long as the user is panning the image. This state is\n * retained until the pan ceases.\n */\n\nvar PanState = function PanState() {\n  var _this4 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n    _this4.dragStart = clientPointFromEvent(e);\n    _this4.panStart = {\n      x: canvasDraw.coordSystem.x,\n      y: canvasDraw.coordSystem.y\n    };\n    return _this4;\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    var _clientPointFromEvent = clientPointFromEvent(e),\n        clientX = _clientPointFromEvent.clientX,\n        clientY = _clientPointFromEvent.clientY;\n\n    var dx = clientX - _this4.dragStart.clientX;\n    var dy = clientY - _this4.dragStart.clientY;\n    canvasDraw.coordSystem.setView({\n      x: _this4.panStart.x + dx,\n      y: _this4.panStart.y + dy\n    });\n    return _this4;\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n};\n/**\n * This state is active when the user has initiated the drawing action but has\n * not yet created any lines. We use this state to try and detect a second touch\n * event to initiate a pinch-zoom action. We'll give up on that if enough time\n * or movement happens without a second touch.\n */\n\nvar WaitForPinchState = function WaitForPinchState() {\n  var _this5 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    var enablePanAndZoom = canvasDraw.props.enablePanAndZoom;\n    e.preventDefault(); // We're going to transition immediately into lazy-drawing mode if\n    // pan-and-zoom isn't enabled or if this event wasn't triggered by a touch.\n\n    if (!e.touches || !e.touches.length || !enablePanAndZoom) {\n      return new DrawingState().handleDrawStart(e, canvasDraw);\n    } // If we already have two touch events, we can move straight into pinch/pan\n\n\n    if (enablePanAndZoom && e.touches && e.touches.length >= 2) {\n      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);\n    }\n\n    return _this5.handleDrawMove(e, canvasDraw);\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault(); // If we have two touches, move to pinch/pan (we don't have to recheck\n    // whether zoom is enabled because that happend in draw start).\n\n    if (e.touches && e.touches.length >= 2) {\n      // Use the start draw to handler to transition.\n      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);\n    }\n\n    var clientPt = clientPointFromEvent(e);\n\n    _this5.deferredPoints.push(clientPt); // If we've already moved far enough, or if enough time has passed, give up\n    // and switch over to drawing.\n\n\n    if (new Date().valueOf() - _this5.startTimestamp < PINCH_TIMEOUT_MS) {\n      if (_this5.startClientPoint === null) {\n        _this5.startClientPoint = clientPt;\n      } // Note that we're using \"manhattan distance\" rather than computing a\n      // hypotenuse here as a cheap approximation\n\n\n      var d = Math.abs(clientPt.clientX - _this5.startClientPoint.clientX) + Math.abs(clientPt.clientY - _this5.startClientPoint.clientY);\n\n      if (d < TOUCH_SLOP) {\n        // We're not ready to give up yet.\n        return _this5;\n      }\n    } // Okay, give up and start drawing.\n\n\n    return _this5.issueDeferredPoints(canvasDraw);\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    // The user stopped drawing before we decided what to do. Just treat this as\n    // if they were drawing all along.\n    return _this5.issueDeferredPoints(canvasDraw).handleDrawEnd(e, canvasDraw);\n  });\n\n  _defineProperty(this, \"issueDeferredPoints\", function (canvasDraw) {\n    // Time to give up. Play our deferred points out to the drawing state.\n    // The first point will have been a start draw.\n    var nextState = new DrawingState();\n\n    for (var i = 0; i < _this5.deferredPoints.length; i++) {\n      var deferredPt = _this5.deferredPoints[i];\n      var syntheticEvt = new SyntheticEvent(deferredPt);\n      var func = i === 0 ? nextState.handleDrawStart : nextState.handleDrawMove;\n      nextState = func(syntheticEvt, canvasDraw);\n    }\n\n    return nextState;\n  });\n\n  this.startClientPoint = null;\n  this.startTimestamp = new Date().valueOf();\n  this.deferredPoints = [];\n};\n/**\n * This state is active when the user has added at least two touch points but we\n * don't yet know if they intend to pan or zoom.\n */\n\nvar ScaleOrPanState = function ScaleOrPanState() {\n  var _this6 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n\n    _this6.start = _this6.getTouchMetrics(e);\n    _this6.panStart = {\n      x: canvasDraw.coordSystem.x,\n      y: canvasDraw.coordSystem.y\n    };\n    _this6.scaleStart = canvasDraw.coordSystem.scale;\n    return _this6;\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n\n    var _this6$recentMetrics = _this6.recentMetrics = _this6.getTouchMetrics(e),\n        centroid = _this6$recentMetrics.centroid,\n        distance = _this6$recentMetrics.distance; // Switch to scaling?\n\n\n    var dd = Math.abs(distance - _this6.start.distance);\n\n    if (dd >= TOUCH_SLOP) {\n      return new TouchScaleState(_this6).handleDrawMove(e, canvasDraw);\n    } // Switch to panning?\n\n\n    var dx = centroid.clientX - _this6.start.centroid.clientX;\n    var dy = centroid.clientY - _this6.start.centroid.clientY;\n    var dc = Math.abs(dx) + Math.abs(dy);\n\n    if (dc >= TOUCH_SLOP) {\n      return new TouchPanState(_this6).handleDrawMove(e, canvasDraw);\n    } // Not enough movement yet\n\n\n    return _this6;\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n\n  _defineProperty(this, \"getTouchMetrics\", function (e) {\n    var _clientPointFromEvent2 = clientPointFromEvent(e.touches[0]),\n        t1x = _clientPointFromEvent2.clientX,\n        t1y = _clientPointFromEvent2.clientY;\n\n    var _clientPointFromEvent3 = clientPointFromEvent(e.touches[1]),\n        t2x = _clientPointFromEvent3.clientX,\n        t2y = _clientPointFromEvent3.clientY;\n\n    var dx = t2x - t1x;\n    var dy = t2y - t1y;\n    return {\n      t1: {\n        clientX: t1x,\n        clientY: t1y\n      },\n      t2: {\n        clientX: t2x,\n        clientY: t2y\n      },\n      distance: Math.sqrt(dx * dx + dy * dy),\n      centroid: {\n        clientX: (t1x + t2x) / 2.0,\n        clientY: (t1y + t2y) / 2.0\n      }\n    };\n  });\n};\n/**\n * The user is actively using touch gestures to pan the image.\n */\n\nvar TouchPanState = function TouchPanState(scaleOrPanState) {\n  var _this7 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function () {\n    return _this7;\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n\n    var ref = _this7.scaleOrPanState;\n\n    var _ref$recentMetrics = ref.recentMetrics = ref.getTouchMetrics(e),\n        centroid = _ref$recentMetrics.centroid,\n        distance = _ref$recentMetrics.distance;\n\n    var dx = centroid.clientX - ref.start.centroid.clientX;\n    var dy = centroid.clientY - ref.start.centroid.clientY;\n    canvasDraw.setView({\n      x: ref.panStart.x + dx,\n      y: ref.panStart.y + dy\n    });\n    return _this7;\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n\n  this.scaleOrPanState = scaleOrPanState;\n};\n/**\n * The user is actively using touch gestures to scale the drawing.\n */\n\nvar TouchScaleState = function TouchScaleState(scaleOrPanState) {\n  var _this8 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function () {\n    return _this8;\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n\n    var ref = _this8.scaleOrPanState;\n\n    var _ref$recentMetrics2 = ref.recentMetrics = ref.getTouchMetrics(e),\n        centroid = _ref$recentMetrics2.centroid,\n        distance = _ref$recentMetrics2.distance;\n\n    var targetScale = ref.scaleStart * (distance / ref.start.distance);\n    var dScale = targetScale - canvasDraw.coordSystem.scale;\n    canvasDraw.coordSystem.scaleAtClientPoint(dScale, centroid);\n    return _this8;\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n\n  this.scaleOrPanState = scaleOrPanState;\n};\n/**\n * This state is active when the user is drawing.\n */\n\nvar DrawingState = function DrawingState() {\n  var _this9 = this;\n\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    if (e.touches && e.touches.length) {\n      // on touch, set catenary position to touch pos\n      var _viewPointFromEvent2 = viewPointFromEvent(canvasDraw.coordSystem, e),\n          x = _viewPointFromEvent2.x,\n          y = _viewPointFromEvent2.y;\n\n      canvasDraw.lazy.update({\n        x: x,\n        y: y\n      }, {\n        both: true\n      });\n    }\n\n    return _this9.handleDrawMove(e, canvasDraw);\n  });\n\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n\n    var _viewPointFromEvent3 = viewPointFromEvent(canvasDraw.coordSystem, e),\n        x = _viewPointFromEvent3.x,\n        y = _viewPointFromEvent3.y;\n\n    canvasDraw.lazy.update({\n      x: x,\n      y: y\n    });\n    var isDisabled = !canvasDraw.lazy.isEnabled();\n\n    if (!_this9.isDrawing || isDisabled) {\n      // Start drawing and add point\n      canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject()));\n      _this9.isDrawing = true;\n    } // Add new point\n\n\n    canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject())); // Draw current points\n\n    canvasDraw.drawPoints({\n      points: canvasDraw.points,\n      brushColor: canvasDraw.props.brushColor,\n      brushRadius: canvasDraw.props.brushRadius\n    });\n    return _this9;\n  });\n\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    e.preventDefault(); // Draw to this end pos\n\n    _this9.handleDrawMove(e, canvasDraw);\n\n    canvasDraw.saveLine();\n    return new DefaultState();\n  });\n\n  this.isDrawing = false;\n};\nvar SyntheticEvent = function SyntheticEvent(_ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n\n  _defineProperty(this, \"preventDefault\", function () {});\n\n  this.clientX = clientX;\n  this.clientY = clientY;\n  this.touches = [{\n    clientX: clientX,\n    clientY: clientY\n  }];\n};\nfunction clientPointFromEvent(e) {\n  // use cursor pos as default\n  var clientX = e.clientX;\n  var clientY = e.clientY; // use first touch if available\n\n  if (e.changedTouches && e.changedTouches.length > 0) {\n    clientX = e.changedTouches[0].clientX;\n    clientY = e.changedTouches[0].clientY;\n  }\n\n  return {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nfunction viewPointFromEvent(coordSystem, e) {\n  return coordSystem.clientPointToViewPoint(clientPointFromEvent(e));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvaW50ZXJhY3Rpb25TdGF0ZU1hY2hpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxZQUFZLFNBQUk7O0FBRWhCLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQztBQUMxQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7OztBQUdsRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTiwrRkFBK0Y7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbHV0by1sZWFybmluZy8uL25vZGVfbW9kdWxlcy9yZWFjdC1jYW52YXMtZHJhdy9lcy9pbnRlcmFjdGlvblN0YXRlTWFjaGluZS5qcz9mNTQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdGhpcyA9IHRoaXM7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBUT1VDSF9TTE9QID0gMTA7XG52YXIgUElOQ0hfVElNRU9VVF9NUyA9IDI1MDtcblxudmFyIFNVUFBSRVNTX1NDUk9MTCA9IGZ1bmN0aW9uIFNVUFBSRVNTX1NDUk9MTChlKSB7XG4gIC8vIE5vIHpvb21pbmcgd2hpbGUgZHJhd2luZywgYnV0IHdlJ2xsIGNhbmNlbCB0aGUgc2Nyb2xsIGV2ZW50LlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHJldHVybiBfdGhpcztcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0YXRlIGZvciB0aGUgaW50ZXJhY3Rpb24gc3RhdGUgbWFjaGluZS4gU3VwcG9ydHMgem9vbSBhbmRcbiAqIGluaXRpYXRpbmcgcGFuIGFuZCBkcmF3aW5nIGFjdGlvbnMuXG4gKi9cblxuXG5leHBvcnQgdmFyIERlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uIERlZmF1bHRTdGF0ZSgpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTW91c2VXaGVlbFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIHZhciBfY2FudmFzRHJhdyRwcm9wcyA9IGNhbnZhc0RyYXcucHJvcHMsXG4gICAgICAgIGRpc2FibGVkID0gX2NhbnZhc0RyYXckcHJvcHMuZGlzYWJsZWQsXG4gICAgICAgIGVuYWJsZVBhbkFuZFpvb20gPSBfY2FudmFzRHJhdyRwcm9wcy5lbmFibGVQYW5BbmRab29tLFxuICAgICAgICBtb3VzZVpvb21GYWN0b3IgPSBfY2FudmFzRHJhdyRwcm9wcy5tb3VzZVpvb21GYWN0b3I7XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoZW5hYmxlUGFuQW5kWm9vbSAmJiBlLmN0cmxLZXkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNhbnZhc0RyYXcuY29vcmRTeXN0ZW0uc2NhbGVBdENsaWVudFBvaW50KG1vdXNlWm9vbUZhY3RvciAqIGUuZGVsdGFZLCBjbGllbnRQb2ludEZyb21FdmVudChlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd1N0YXJ0XCIsIGZ1bmN0aW9uIChlLCBjYW52YXNEcmF3KSB7XG4gICAgaWYgKGNhbnZhc0RyYXcucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoZS5jdHJsS2V5ICYmIGNhbnZhc0RyYXcucHJvcHMuZW5hYmxlUGFuQW5kWm9vbSkge1xuICAgICAgcmV0dXJuIG5ldyBQYW5TdGF0ZSgpLmhhbmRsZURyYXdTdGFydChlLCBjYW52YXNEcmF3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBXYWl0Rm9yUGluY2hTdGF0ZSgpLmhhbmRsZURyYXdTdGFydChlLCBjYW52YXNEcmF3KTtcbiAgICB9XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdNb3ZlXCIsIGZ1bmN0aW9uIChlLCBjYW52YXNEcmF3KSB7XG4gICAgaWYgKGNhbnZhc0RyYXcucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ZpZXdQb2ludEZyb21FdmVudCA9IHZpZXdQb2ludEZyb21FdmVudChjYW52YXNEcmF3LmNvb3JkU3lzdGVtLCBlKSxcbiAgICAgICAgICB4ID0gX3ZpZXdQb2ludEZyb21FdmVudC54LFxuICAgICAgICAgIHkgPSBfdmlld1BvaW50RnJvbUV2ZW50Lnk7XG5cbiAgICAgIGNhbnZhc0RyYXcubGF6eS51cGRhdGUoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmF3RW5kXCIsIGZ1bmN0aW9uIChlLCBjYW52YXNEcmF3KSB7XG4gICAgcmV0dXJuIGNhbnZhc0RyYXcucHJvcHMuZGlzYWJsZWQgPyBuZXcgRGlzYWJsZWRTdGF0ZSgpIDogX3RoaXMyO1xuICB9KTtcbn07XG47XG4vKipcbiAqIFRoaXMgc3RhdGUgaXMgdXNlZCBhcyBsb25nIGFzIHRoZSBkaXNhYmxlZCBwcm9wIGlzIGFjdGl2ZS4gSXQgaWdub3JlcyBhbGxcbiAqIGV2ZW50cyBhbmQgZG9lc24ndCBwcmV2ZW50IGRlZmF1bHQgYWN0aW9ucy4gVGhlIGRpc2FibGVkIHN0YXRlIGNhbiBvbmx5IGJlXG4gKiB0cmlnZ2VyZWQgZnJvbSB0aGUgZGVmYXVsdCBzdGF0ZSAoaS5lLiwgd2hpbGUgbm8gYWN0aW9uIGlzIGFjdGl2ZWx5IGJlaW5nXG4gKiBwZXJmb3JtZWQpLlxuICovXG5cbmV4cG9ydCB2YXIgRGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIERpc2FibGVkU3RhdGUoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBpZiAoY2FudmFzRHJhdy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKS5oYW5kbGVNb3VzZVdoZWVsKGUsIGNhbnZhc0RyYXcpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd1N0YXJ0XCIsIGZ1bmN0aW9uIChlLCBjYW52YXNEcmF3KSB7XG4gICAgaWYgKGNhbnZhc0RyYXcucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0YXRlKCkuaGFuZGxlRHJhd1N0YXJ0KGUsIGNhbnZhc0RyYXcpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd01vdmVcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBpZiAoY2FudmFzRHJhdy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKS5oYW5kbGVEcmF3TW92ZShlLCBjYW52YXNEcmF3KTtcbiAgICB9XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdFbmRcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBpZiAoY2FudmFzRHJhdy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKS5oYW5kbGVEcmF3RW5kKGUsIGNhbnZhc0RyYXcpO1xuICAgIH1cbiAgfSk7XG59O1xuLyoqXG4gKiBUaGlzIHN0YXRlIGlzIGFjdGl2ZSBhcyBsb25nIGFzIHRoZSB1c2VyIGlzIHBhbm5pbmcgdGhlIGltYWdlLiBUaGlzIHN0YXRlIGlzXG4gKiByZXRhaW5lZCB1bnRpbCB0aGUgcGFuIGNlYXNlcy5cbiAqL1xuXG5leHBvcnQgdmFyIFBhblN0YXRlID0gZnVuY3Rpb24gUGFuU3RhdGUoKSB7XG4gIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgU1VQUFJFU1NfU0NST0xMLmJpbmQodGhpcykpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBfdGhpczQuZHJhZ1N0YXJ0ID0gY2xpZW50UG9pbnRGcm9tRXZlbnQoZSk7XG4gICAgX3RoaXM0LnBhblN0YXJ0ID0ge1xuICAgICAgeDogY2FudmFzRHJhdy5jb29yZFN5c3RlbS54LFxuICAgICAgeTogY2FudmFzRHJhdy5jb29yZFN5c3RlbS55XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmF3TW92ZVwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBfY2xpZW50UG9pbnRGcm9tRXZlbnQgPSBjbGllbnRQb2ludEZyb21FdmVudChlKSxcbiAgICAgICAgY2xpZW50WCA9IF9jbGllbnRQb2ludEZyb21FdmVudC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX2NsaWVudFBvaW50RnJvbUV2ZW50LmNsaWVudFk7XG5cbiAgICB2YXIgZHggPSBjbGllbnRYIC0gX3RoaXM0LmRyYWdTdGFydC5jbGllbnRYO1xuICAgIHZhciBkeSA9IGNsaWVudFkgLSBfdGhpczQuZHJhZ1N0YXJ0LmNsaWVudFk7XG4gICAgY2FudmFzRHJhdy5jb29yZFN5c3RlbS5zZXRWaWV3KHtcbiAgICAgIHg6IF90aGlzNC5wYW5TdGFydC54ICsgZHgsXG4gICAgICB5OiBfdGhpczQucGFuU3RhcnQueSArIGR5XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBUaGlzIHN0YXRlIGlzIGFjdGl2ZSB3aGVuIHRoZSB1c2VyIGhhcyBpbml0aWF0ZWQgdGhlIGRyYXdpbmcgYWN0aW9uIGJ1dCBoYXNcbiAqIG5vdCB5ZXQgY3JlYXRlZCBhbnkgbGluZXMuIFdlIHVzZSB0aGlzIHN0YXRlIHRvIHRyeSBhbmQgZGV0ZWN0IGEgc2Vjb25kIHRvdWNoXG4gKiBldmVudCB0byBpbml0aWF0ZSBhIHBpbmNoLXpvb20gYWN0aW9uLiBXZSdsbCBnaXZlIHVwIG9uIHRoYXQgaWYgZW5vdWdoIHRpbWVcbiAqIG9yIG1vdmVtZW50IGhhcHBlbnMgd2l0aG91dCBhIHNlY29uZCB0b3VjaC5cbiAqL1xuXG5leHBvcnQgdmFyIFdhaXRGb3JQaW5jaFN0YXRlID0gZnVuY3Rpb24gV2FpdEZvclBpbmNoU3RhdGUoKSB7XG4gIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgU1VQUFJFU1NfU0NST0xMLmJpbmQodGhpcykpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIHZhciBlbmFibGVQYW5BbmRab29tID0gY2FudmFzRHJhdy5wcm9wcy5lbmFibGVQYW5BbmRab29tO1xuICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gV2UncmUgZ29pbmcgdG8gdHJhbnNpdGlvbiBpbW1lZGlhdGVseSBpbnRvIGxhenktZHJhd2luZyBtb2RlIGlmXG4gICAgLy8gcGFuLWFuZC16b29tIGlzbid0IGVuYWJsZWQgb3IgaWYgdGhpcyBldmVudCB3YXNuJ3QgdHJpZ2dlcmVkIGJ5IGEgdG91Y2guXG5cbiAgICBpZiAoIWUudG91Y2hlcyB8fCAhZS50b3VjaGVzLmxlbmd0aCB8fCAhZW5hYmxlUGFuQW5kWm9vbSkge1xuICAgICAgcmV0dXJuIG5ldyBEcmF3aW5nU3RhdGUoKS5oYW5kbGVEcmF3U3RhcnQoZSwgY2FudmFzRHJhdyk7XG4gICAgfSAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdHdvIHRvdWNoIGV2ZW50cywgd2UgY2FuIG1vdmUgc3RyYWlnaHQgaW50byBwaW5jaC9wYW5cblxuXG4gICAgaWYgKGVuYWJsZVBhbkFuZFpvb20gJiYgZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIG5ldyBTY2FsZU9yUGFuU3RhdGUoKS5oYW5kbGVEcmF3U3RhcnQoZSwgY2FudmFzRHJhdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzNS5oYW5kbGVEcmF3TW92ZShlLCBjYW52YXNEcmF3KTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd01vdmVcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIElmIHdlIGhhdmUgdHdvIHRvdWNoZXMsIG1vdmUgdG8gcGluY2gvcGFuICh3ZSBkb24ndCBoYXZlIHRvIHJlY2hlY2tcbiAgICAvLyB3aGV0aGVyIHpvb20gaXMgZW5hYmxlZCBiZWNhdXNlIHRoYXQgaGFwcGVuZCBpbiBkcmF3IHN0YXJ0KS5cblxuICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAvLyBVc2UgdGhlIHN0YXJ0IGRyYXcgdG8gaGFuZGxlciB0byB0cmFuc2l0aW9uLlxuICAgICAgcmV0dXJuIG5ldyBTY2FsZU9yUGFuU3RhdGUoKS5oYW5kbGVEcmF3U3RhcnQoZSwgY2FudmFzRHJhdyk7XG4gICAgfVxuXG4gICAgdmFyIGNsaWVudFB0ID0gY2xpZW50UG9pbnRGcm9tRXZlbnQoZSk7XG5cbiAgICBfdGhpczUuZGVmZXJyZWRQb2ludHMucHVzaChjbGllbnRQdCk7IC8vIElmIHdlJ3ZlIGFscmVhZHkgbW92ZWQgZmFyIGVub3VnaCwgb3IgaWYgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZCwgZ2l2ZSB1cFxuICAgIC8vIGFuZCBzd2l0Y2ggb3ZlciB0byBkcmF3aW5nLlxuXG5cbiAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSBfdGhpczUuc3RhcnRUaW1lc3RhbXAgPCBQSU5DSF9USU1FT1VUX01TKSB7XG4gICAgICBpZiAoX3RoaXM1LnN0YXJ0Q2xpZW50UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgX3RoaXM1LnN0YXJ0Q2xpZW50UG9pbnQgPSBjbGllbnRQdDtcbiAgICAgIH0gLy8gTm90ZSB0aGF0IHdlJ3JlIHVzaW5nIFwibWFuaGF0dGFuIGRpc3RhbmNlXCIgcmF0aGVyIHRoYW4gY29tcHV0aW5nIGFcbiAgICAgIC8vIGh5cG90ZW51c2UgaGVyZSBhcyBhIGNoZWFwIGFwcHJveGltYXRpb25cblxuXG4gICAgICB2YXIgZCA9IE1hdGguYWJzKGNsaWVudFB0LmNsaWVudFggLSBfdGhpczUuc3RhcnRDbGllbnRQb2ludC5jbGllbnRYKSArIE1hdGguYWJzKGNsaWVudFB0LmNsaWVudFkgLSBfdGhpczUuc3RhcnRDbGllbnRQb2ludC5jbGllbnRZKTtcblxuICAgICAgaWYgKGQgPCBUT1VDSF9TTE9QKSB7XG4gICAgICAgIC8vIFdlJ3JlIG5vdCByZWFkeSB0byBnaXZlIHVwIHlldC5cbiAgICAgICAgcmV0dXJuIF90aGlzNTtcbiAgICAgIH1cbiAgICB9IC8vIE9rYXksIGdpdmUgdXAgYW5kIHN0YXJ0IGRyYXdpbmcuXG5cblxuICAgIHJldHVybiBfdGhpczUuaXNzdWVEZWZlcnJlZFBvaW50cyhjYW52YXNEcmF3KTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd0VuZFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIC8vIFRoZSB1c2VyIHN0b3BwZWQgZHJhd2luZyBiZWZvcmUgd2UgZGVjaWRlZCB3aGF0IHRvIGRvLiBKdXN0IHRyZWF0IHRoaXMgYXNcbiAgICAvLyBpZiB0aGV5IHdlcmUgZHJhd2luZyBhbGwgYWxvbmcuXG4gICAgcmV0dXJuIF90aGlzNS5pc3N1ZURlZmVycmVkUG9pbnRzKGNhbnZhc0RyYXcpLmhhbmRsZURyYXdFbmQoZSwgY2FudmFzRHJhdyk7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzc3VlRGVmZXJyZWRQb2ludHNcIiwgZnVuY3Rpb24gKGNhbnZhc0RyYXcpIHtcbiAgICAvLyBUaW1lIHRvIGdpdmUgdXAuIFBsYXkgb3VyIGRlZmVycmVkIHBvaW50cyBvdXQgdG8gdGhlIGRyYXdpbmcgc3RhdGUuXG4gICAgLy8gVGhlIGZpcnN0IHBvaW50IHdpbGwgaGF2ZSBiZWVuIGEgc3RhcnQgZHJhdy5cbiAgICB2YXIgbmV4dFN0YXRlID0gbmV3IERyYXdpbmdTdGF0ZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpczUuZGVmZXJyZWRQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZWZlcnJlZFB0ID0gX3RoaXM1LmRlZmVycmVkUG9pbnRzW2ldO1xuICAgICAgdmFyIHN5bnRoZXRpY0V2dCA9IG5ldyBTeW50aGV0aWNFdmVudChkZWZlcnJlZFB0KTtcbiAgICAgIHZhciBmdW5jID0gaSA9PT0gMCA/IG5leHRTdGF0ZS5oYW5kbGVEcmF3U3RhcnQgOiBuZXh0U3RhdGUuaGFuZGxlRHJhd01vdmU7XG4gICAgICBuZXh0U3RhdGUgPSBmdW5jKHN5bnRoZXRpY0V2dCwgY2FudmFzRHJhdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSk7XG5cbiAgdGhpcy5zdGFydENsaWVudFBvaW50ID0gbnVsbDtcbiAgdGhpcy5zdGFydFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICB0aGlzLmRlZmVycmVkUG9pbnRzID0gW107XG59O1xuLyoqXG4gKiBUaGlzIHN0YXRlIGlzIGFjdGl2ZSB3aGVuIHRoZSB1c2VyIGhhcyBhZGRlZCBhdCBsZWFzdCB0d28gdG91Y2ggcG9pbnRzIGJ1dCB3ZVxuICogZG9uJ3QgeWV0IGtub3cgaWYgdGhleSBpbnRlbmQgdG8gcGFuIG9yIHpvb20uXG4gKi9cblxuZXhwb3J0IHZhciBTY2FsZU9yUGFuU3RhdGUgPSBmdW5jdGlvbiBTY2FsZU9yUGFuU3RhdGUoKSB7XG4gIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgU1VQUFJFU1NfU0NST0xMLmJpbmQodGhpcykpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdGF0ZSgpO1xuICAgIH1cblxuICAgIF90aGlzNi5zdGFydCA9IF90aGlzNi5nZXRUb3VjaE1ldHJpY3MoZSk7XG4gICAgX3RoaXM2LnBhblN0YXJ0ID0ge1xuICAgICAgeDogY2FudmFzRHJhdy5jb29yZFN5c3RlbS54LFxuICAgICAgeTogY2FudmFzRHJhdy5jb29yZFN5c3RlbS55XG4gICAgfTtcbiAgICBfdGhpczYuc2NhbGVTdGFydCA9IGNhbnZhc0RyYXcuY29vcmRTeXN0ZW0uc2NhbGU7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd01vdmVcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXM2JHJlY2VudE1ldHJpY3MgPSBfdGhpczYucmVjZW50TWV0cmljcyA9IF90aGlzNi5nZXRUb3VjaE1ldHJpY3MoZSksXG4gICAgICAgIGNlbnRyb2lkID0gX3RoaXM2JHJlY2VudE1ldHJpY3MuY2VudHJvaWQsXG4gICAgICAgIGRpc3RhbmNlID0gX3RoaXM2JHJlY2VudE1ldHJpY3MuZGlzdGFuY2U7IC8vIFN3aXRjaCB0byBzY2FsaW5nP1xuXG5cbiAgICB2YXIgZGQgPSBNYXRoLmFicyhkaXN0YW5jZSAtIF90aGlzNi5zdGFydC5kaXN0YW5jZSk7XG5cbiAgICBpZiAoZGQgPj0gVE9VQ0hfU0xPUCkge1xuICAgICAgcmV0dXJuIG5ldyBUb3VjaFNjYWxlU3RhdGUoX3RoaXM2KS5oYW5kbGVEcmF3TW92ZShlLCBjYW52YXNEcmF3KTtcbiAgICB9IC8vIFN3aXRjaCB0byBwYW5uaW5nP1xuXG5cbiAgICB2YXIgZHggPSBjZW50cm9pZC5jbGllbnRYIC0gX3RoaXM2LnN0YXJ0LmNlbnRyb2lkLmNsaWVudFg7XG4gICAgdmFyIGR5ID0gY2VudHJvaWQuY2xpZW50WSAtIF90aGlzNi5zdGFydC5jZW50cm9pZC5jbGllbnRZO1xuICAgIHZhciBkYyA9IE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KTtcblxuICAgIGlmIChkYyA+PSBUT1VDSF9TTE9QKSB7XG4gICAgICByZXR1cm4gbmV3IFRvdWNoUGFuU3RhdGUoX3RoaXM2KS5oYW5kbGVEcmF3TW92ZShlLCBjYW52YXNEcmF3KTtcbiAgICB9IC8vIE5vdCBlbm91Z2ggbW92ZW1lbnQgeWV0XG5cblxuICAgIHJldHVybiBfdGhpczY7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdFbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGVmYXVsdFN0YXRlKCk7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFRvdWNoTWV0cmljc1wiLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfY2xpZW50UG9pbnRGcm9tRXZlbnQyID0gY2xpZW50UG9pbnRGcm9tRXZlbnQoZS50b3VjaGVzWzBdKSxcbiAgICAgICAgdDF4ID0gX2NsaWVudFBvaW50RnJvbUV2ZW50Mi5jbGllbnRYLFxuICAgICAgICB0MXkgPSBfY2xpZW50UG9pbnRGcm9tRXZlbnQyLmNsaWVudFk7XG5cbiAgICB2YXIgX2NsaWVudFBvaW50RnJvbUV2ZW50MyA9IGNsaWVudFBvaW50RnJvbUV2ZW50KGUudG91Y2hlc1sxXSksXG4gICAgICAgIHQyeCA9IF9jbGllbnRQb2ludEZyb21FdmVudDMuY2xpZW50WCxcbiAgICAgICAgdDJ5ID0gX2NsaWVudFBvaW50RnJvbUV2ZW50My5jbGllbnRZO1xuXG4gICAgdmFyIGR4ID0gdDJ4IC0gdDF4O1xuICAgIHZhciBkeSA9IHQyeSAtIHQxeTtcbiAgICByZXR1cm4ge1xuICAgICAgdDE6IHtcbiAgICAgICAgY2xpZW50WDogdDF4LFxuICAgICAgICBjbGllbnRZOiB0MXlcbiAgICAgIH0sXG4gICAgICB0Mjoge1xuICAgICAgICBjbGllbnRYOiB0MngsXG4gICAgICAgIGNsaWVudFk6IHQyeVxuICAgICAgfSxcbiAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgY2VudHJvaWQ6IHtcbiAgICAgICAgY2xpZW50WDogKHQxeCArIHQyeCkgLyAyLjAsXG4gICAgICAgIGNsaWVudFk6ICh0MXkgKyB0MnkpIC8gMi4wXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59O1xuLyoqXG4gKiBUaGUgdXNlciBpcyBhY3RpdmVseSB1c2luZyB0b3VjaCBnZXN0dXJlcyB0byBwYW4gdGhlIGltYWdlLlxuICovXG5cbmV4cG9ydCB2YXIgVG91Y2hQYW5TdGF0ZSA9IGZ1bmN0aW9uIFRvdWNoUGFuU3RhdGUoc2NhbGVPclBhblN0YXRlKSB7XG4gIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgU1VQUFJFU1NfU0NST0xMLmJpbmQodGhpcykpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd01vdmVcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gX3RoaXM3LnNjYWxlT3JQYW5TdGF0ZTtcblxuICAgIHZhciBfcmVmJHJlY2VudE1ldHJpY3MgPSByZWYucmVjZW50TWV0cmljcyA9IHJlZi5nZXRUb3VjaE1ldHJpY3MoZSksXG4gICAgICAgIGNlbnRyb2lkID0gX3JlZiRyZWNlbnRNZXRyaWNzLmNlbnRyb2lkLFxuICAgICAgICBkaXN0YW5jZSA9IF9yZWYkcmVjZW50TWV0cmljcy5kaXN0YW5jZTtcblxuICAgIHZhciBkeCA9IGNlbnRyb2lkLmNsaWVudFggLSByZWYuc3RhcnQuY2VudHJvaWQuY2xpZW50WDtcbiAgICB2YXIgZHkgPSBjZW50cm9pZC5jbGllbnRZIC0gcmVmLnN0YXJ0LmNlbnRyb2lkLmNsaWVudFk7XG4gICAgY2FudmFzRHJhdy5zZXRWaWV3KHtcbiAgICAgIHg6IHJlZi5wYW5TdGFydC54ICsgZHgsXG4gICAgICB5OiByZWYucGFuU3RhcnQueSArIGR5XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgfSk7XG5cbiAgdGhpcy5zY2FsZU9yUGFuU3RhdGUgPSBzY2FsZU9yUGFuU3RhdGU7XG59O1xuLyoqXG4gKiBUaGUgdXNlciBpcyBhY3RpdmVseSB1c2luZyB0b3VjaCBnZXN0dXJlcyB0byBzY2FsZSB0aGUgZHJhd2luZy5cbiAqL1xuXG5leHBvcnQgdmFyIFRvdWNoU2NhbGVTdGF0ZSA9IGZ1bmN0aW9uIFRvdWNoU2NhbGVTdGF0ZShzY2FsZU9yUGFuU3RhdGUpIHtcbiAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTW91c2VXaGVlbFwiLCBTVVBQUkVTU19TQ1JPTEwuYmluZCh0aGlzKSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd1N0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmF3TW92ZVwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRTdGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciByZWYgPSBfdGhpczguc2NhbGVPclBhblN0YXRlO1xuXG4gICAgdmFyIF9yZWYkcmVjZW50TWV0cmljczIgPSByZWYucmVjZW50TWV0cmljcyA9IHJlZi5nZXRUb3VjaE1ldHJpY3MoZSksXG4gICAgICAgIGNlbnRyb2lkID0gX3JlZiRyZWNlbnRNZXRyaWNzMi5jZW50cm9pZCxcbiAgICAgICAgZGlzdGFuY2UgPSBfcmVmJHJlY2VudE1ldHJpY3MyLmRpc3RhbmNlO1xuXG4gICAgdmFyIHRhcmdldFNjYWxlID0gcmVmLnNjYWxlU3RhcnQgKiAoZGlzdGFuY2UgLyByZWYuc3RhcnQuZGlzdGFuY2UpO1xuICAgIHZhciBkU2NhbGUgPSB0YXJnZXRTY2FsZSAtIGNhbnZhc0RyYXcuY29vcmRTeXN0ZW0uc2NhbGU7XG4gICAgY2FudmFzRHJhdy5jb29yZFN5c3RlbS5zY2FsZUF0Q2xpZW50UG9pbnQoZFNjYWxlLCBjZW50cm9pZCk7XG4gICAgcmV0dXJuIF90aGlzODtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgfSk7XG5cbiAgdGhpcy5zY2FsZU9yUGFuU3RhdGUgPSBzY2FsZU9yUGFuU3RhdGU7XG59O1xuLyoqXG4gKiBUaGlzIHN0YXRlIGlzIGFjdGl2ZSB3aGVuIHRoZSB1c2VyIGlzIGRyYXdpbmcuXG4gKi9cblxuZXhwb3J0IHZhciBEcmF3aW5nU3RhdGUgPSBmdW5jdGlvbiBEcmF3aW5nU3RhdGUoKSB7XG4gIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZU1vdXNlV2hlZWxcIiwgU1VQUFJFU1NfU0NST0xMLmJpbmQodGhpcykpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdTdGFydFwiLCBmdW5jdGlvbiAoZSwgY2FudmFzRHJhdykge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgLy8gb24gdG91Y2gsIHNldCBjYXRlbmFyeSBwb3NpdGlvbiB0byB0b3VjaCBwb3NcbiAgICAgIHZhciBfdmlld1BvaW50RnJvbUV2ZW50MiA9IHZpZXdQb2ludEZyb21FdmVudChjYW52YXNEcmF3LmNvb3JkU3lzdGVtLCBlKSxcbiAgICAgICAgICB4ID0gX3ZpZXdQb2ludEZyb21FdmVudDIueCxcbiAgICAgICAgICB5ID0gX3ZpZXdQb2ludEZyb21FdmVudDIueTtcblxuICAgICAgY2FudmFzRHJhdy5sYXp5LnVwZGF0ZSh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0sIHtcbiAgICAgICAgYm90aDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzOS5oYW5kbGVEcmF3TW92ZShlLCBjYW52YXNEcmF3KTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhd01vdmVcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgX3ZpZXdQb2ludEZyb21FdmVudDMgPSB2aWV3UG9pbnRGcm9tRXZlbnQoY2FudmFzRHJhdy5jb29yZFN5c3RlbSwgZSksXG4gICAgICAgIHggPSBfdmlld1BvaW50RnJvbUV2ZW50My54LFxuICAgICAgICB5ID0gX3ZpZXdQb2ludEZyb21FdmVudDMueTtcblxuICAgIGNhbnZhc0RyYXcubGF6eS51cGRhdGUoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFjYW52YXNEcmF3LmxhenkuaXNFbmFibGVkKCk7XG5cbiAgICBpZiAoIV90aGlzOS5pc0RyYXdpbmcgfHwgaXNEaXNhYmxlZCkge1xuICAgICAgLy8gU3RhcnQgZHJhd2luZyBhbmQgYWRkIHBvaW50XG4gICAgICBjYW52YXNEcmF3LnBvaW50cy5wdXNoKGNhbnZhc0RyYXcuY2xhbXBQb2ludFRvRG9jdW1lbnQoY2FudmFzRHJhdy5sYXp5LmJydXNoLnRvT2JqZWN0KCkpKTtcbiAgICAgIF90aGlzOS5pc0RyYXdpbmcgPSB0cnVlO1xuICAgIH0gLy8gQWRkIG5ldyBwb2ludFxuXG5cbiAgICBjYW52YXNEcmF3LnBvaW50cy5wdXNoKGNhbnZhc0RyYXcuY2xhbXBQb2ludFRvRG9jdW1lbnQoY2FudmFzRHJhdy5sYXp5LmJydXNoLnRvT2JqZWN0KCkpKTsgLy8gRHJhdyBjdXJyZW50IHBvaW50c1xuXG4gICAgY2FudmFzRHJhdy5kcmF3UG9pbnRzKHtcbiAgICAgIHBvaW50czogY2FudmFzRHJhdy5wb2ludHMsXG4gICAgICBicnVzaENvbG9yOiBjYW52YXNEcmF3LnByb3BzLmJydXNoQ29sb3IsXG4gICAgICBicnVzaFJhZGl1czogY2FudmFzRHJhdy5wcm9wcy5icnVzaFJhZGl1c1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczk7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYXdFbmRcIiwgZnVuY3Rpb24gKGUsIGNhbnZhc0RyYXcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIERyYXcgdG8gdGhpcyBlbmQgcG9zXG5cbiAgICBfdGhpczkuaGFuZGxlRHJhd01vdmUoZSwgY2FudmFzRHJhdyk7XG5cbiAgICBjYW52YXNEcmF3LnNhdmVMaW5lKCk7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RhdGUoKTtcbiAgfSk7XG5cbiAgdGhpcy5pc0RyYXdpbmcgPSBmYWxzZTtcbn07XG5leHBvcnQgdmFyIFN5bnRoZXRpY0V2ZW50ID0gZnVuY3Rpb24gU3ludGhldGljRXZlbnQoX3JlZikge1xuICB2YXIgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJldmVudERlZmF1bHRcIiwgZnVuY3Rpb24gKCkge30pO1xuXG4gIHRoaXMuY2xpZW50WCA9IGNsaWVudFg7XG4gIHRoaXMuY2xpZW50WSA9IGNsaWVudFk7XG4gIHRoaXMudG91Y2hlcyA9IFt7XG4gICAgY2xpZW50WDogY2xpZW50WCxcbiAgICBjbGllbnRZOiBjbGllbnRZXG4gIH1dO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBjbGllbnRQb2ludEZyb21FdmVudChlKSB7XG4gIC8vIHVzZSBjdXJzb3IgcG9zIGFzIGRlZmF1bHRcbiAgdmFyIGNsaWVudFggPSBlLmNsaWVudFg7XG4gIHZhciBjbGllbnRZID0gZS5jbGllbnRZOyAvLyB1c2UgZmlyc3QgdG91Y2ggaWYgYXZhaWxhYmxlXG5cbiAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgY2xpZW50WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICBjbGllbnRZID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgIGNsaWVudFk6IGNsaWVudFlcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2aWV3UG9pbnRGcm9tRXZlbnQoY29vcmRTeXN0ZW0sIGUpIHtcbiAgcmV0dXJuIGNvb3JkU3lzdGVtLmNsaWVudFBvaW50VG9WaWV3UG9pbnQoY2xpZW50UG9pbnRGcm9tRXZlbnQoZSkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-canvas-draw/es/interactionStateMachine.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-canvas-draw/es/makePassiveEventOption.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-canvas-draw/es/makePassiveEventOption.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ makePassiveEventOption)\n/* harmony export */ });\n// Determines if the browser supprots passive events\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nvar passiveSupported = false;\n\ntry {\n  var options = {\n    get passive() {\n      passiveSupported = true;\n      return false;\n    }\n\n  };\n  window.addEventListener(\"test\", options, options);\n  window.removeEventListener(\"test\", options, options);\n} catch (e) {\n  passiveSupported = false;\n}\n\nfunction makePassiveEventOption(passive) {\n  return passiveSupported ? {\n    passive: passive\n  } : passive;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2FudmFzLWRyYXcvZXMvbWFrZVBhc3NpdmVFdmVudE9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbHV0by1sZWFybmluZy8uL25vZGVfbW9kdWxlcy9yZWFjdC1jYW52YXMtZHJhdy9lcy9tYWtlUGFzc2l2ZUV2ZW50T3B0aW9uLmpzP2QwZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBzdXBwcm90cyBwYXNzaXZlIGV2ZW50c1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxudmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgb3B0aW9ucywgb3B0aW9ucyk7XG59IGNhdGNoIChlKSB7XG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZVBhc3NpdmVFdmVudE9wdGlvbihwYXNzaXZlKSB7XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkID8ge1xuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSA6IHBhc3NpdmU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-canvas-draw/es/makePassiveEventOption.js\n");

/***/ })

};
;