"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-size";
exports.ids = ["vendor-chunks/canvas-size"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/canvas-size/dist/canvas-size.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ canvasSize)\n/* harmony export */ });\n/*!\n * canvas-size\n * v1.2.6\n * https://github.com/jhildenbiddle/canvas-size\n * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>\n * MIT license\n */\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for (;!(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) ;\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally {\n            try {\n                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n            } finally {\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter((function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        }))), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\n\nfunction _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {\n            _defineProperty(target, key, source[key]);\n        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        }));\n    }\n    return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n}\n\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction canvasTest(settings) {\n    var size = settings.sizes.shift();\n    var width = Math.max(Math.ceil(size[0]), 1);\n    var height = Math.max(Math.ceil(size[1]), 1);\n    var fill = [ width - 1, height - 1, 1, 1 ];\n    var job = Date.now();\n    var isWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n    var cropCvs, testCvs;\n    if (isWorker) {\n        cropCvs = new OffscreenCanvas(1, 1);\n        testCvs = new OffscreenCanvas(width, height);\n    } else {\n        cropCvs = document.createElement(\"canvas\");\n        cropCvs.width = 1;\n        cropCvs.height = 1;\n        testCvs = document.createElement(\"canvas\");\n        testCvs.width = width;\n        testCvs.height = height;\n    }\n    var cropCtx = cropCvs.getContext(\"2d\");\n    var testCtx = testCvs.getContext(\"2d\");\n    if (testCtx) {\n        testCtx.fillRect.apply(testCtx, fill);\n        cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);\n    }\n    var isTestPass = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;\n    var benchmark = Date.now() - job;\n    [ cropCvs, testCvs ].forEach((function(cvs) {\n        cvs.height = 0;\n        cvs.width = 0;\n    }));\n    if (isWorker) {\n        postMessage({\n            width: width,\n            height: height,\n            benchmark: benchmark,\n            isTestPass: isTestPass\n        });\n        if (!isTestPass && settings.sizes.length) {\n            canvasTest(settings);\n        }\n    } else if (isTestPass) {\n        settings.onSuccess(width, height, benchmark);\n    } else {\n        settings.onError(width, height, benchmark);\n        if (settings.sizes.length) {\n            canvasTest(settings);\n        }\n    }\n    return isTestPass;\n}\n\nvar testSizes = {\n    area: [ 16384, 14188, 11402, 11180, 10836, 8192, 4096, 1 ],\n    height: [ 8388607, 65535, 32767, 16384, 8192, 4096, 1 ],\n    width: [ 4194303, 65535, 32767, 16384, 8192, 4096, 1 ]\n};\n\nvar _excluded = [ \"onError\", \"onSuccess\" ];\n\nvar defaults = {\n    max: null,\n    min: 1,\n    sizes: [],\n    step: 1024,\n    usePromise: false,\n    useWorker: false,\n    onError: Function.prototype,\n    onSuccess: Function.prototype\n};\n\nvar workerJobs = {};\n\nfunction createSizesArray(settings) {\n    var isArea = settings.width === settings.height;\n    var isWidth = settings.height === 1;\n    var isHeight = settings.width === 1;\n    var sizes = [];\n    if (!settings.width || !settings.height) {\n        settings.sizes.forEach((function(testSize) {\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([ width, height ]);\n        }));\n    } else {\n        var testMin = settings.min || defaults.min;\n        var testStep = settings.step || defaults.step;\n        var testSize = Math.max(settings.width, settings.height);\n        while (testSize >= testMin) {\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([ width, height ]);\n            testSize -= testStep;\n        }\n    }\n    return sizes;\n}\n\nfunction handleMethod(settings) {\n    var hasCanvasSupport = window && \"HTMLCanvasElement\" in window;\n    var hasOffscreenCanvasSupport = window && \"OffscreenCanvas\" in window;\n    var jobID = Date.now();\n    var _onError = settings.onError, _onSuccess = settings.onSuccess, settingsWithoutCallbacks = _objectWithoutProperties(settings, _excluded);\n    var worker = null;\n    if (!hasCanvasSupport) {\n        return false;\n    }\n    if (settings.useWorker && hasOffscreenCanvasSupport) {\n        var js = \"\\n            var canvasTest = \".concat(canvasTest.toString(), \";\\n            onmessage = function(e) {\\n                canvasTest(e.data);\\n            };\\n        \");\n        var blob = new Blob([ js ], {\n            type: \"application/javascript\"\n        });\n        var blobURL = URL.createObjectURL(blob);\n        worker = new Worker(blobURL);\n        URL.revokeObjectURL(blobURL);\n        worker.onmessage = function(e) {\n            var _e$data = e.data, width = _e$data.width, height = _e$data.height, benchmark = _e$data.benchmark, isTestPass = _e$data.isTestPass;\n            if (isTestPass) {\n                workerJobs[jobID].onSuccess(width, height, benchmark);\n                delete workerJobs[jobID];\n            } else {\n                workerJobs[jobID].onError(width, height, benchmark);\n            }\n        };\n    }\n    if (settings.usePromise) {\n        return new Promise((function(resolve, reject) {\n            var promiseSettings = _objectSpread2(_objectSpread2({}, settings), {}, {\n                onError: function onError(width, height, benchmark) {\n                    var isLastTest;\n                    if (settings.sizes.length === 0) {\n                        isLastTest = true;\n                    } else {\n                        var _settings$sizes$slice = settings.sizes.slice(-1), _settings$sizes$slice2 = _slicedToArray(_settings$sizes$slice, 1), _settings$sizes$slice3 = _slicedToArray(_settings$sizes$slice2[0], 2), lastWidth = _settings$sizes$slice3[0], lastHeight = _settings$sizes$slice3[1];\n                        isLastTest = width === lastWidth && height === lastHeight;\n                    }\n                    _onError(width, height, benchmark);\n                    if (isLastTest) {\n                        reject({\n                            width: width,\n                            height: height,\n                            benchmark: benchmark\n                        });\n                    }\n                },\n                onSuccess: function onSuccess(width, height, benchmark) {\n                    _onSuccess(width, height, benchmark);\n                    resolve({\n                        width: width,\n                        height: height,\n                        benchmark: benchmark\n                    });\n                }\n            });\n            if (worker) {\n                var onError = promiseSettings.onError, onSuccess = promiseSettings.onSuccess;\n                workerJobs[jobID] = {\n                    onError: onError,\n                    onSuccess: onSuccess\n                };\n                worker.postMessage(settingsWithoutCallbacks);\n            } else {\n                canvasTest(promiseSettings);\n            }\n        }));\n    } else {\n        if (worker) {\n            workerJobs[jobID] = {\n                onError: _onError,\n                onSuccess: _onSuccess\n            };\n            worker.postMessage(settingsWithoutCallbacks);\n        } else {\n            return canvasTest(settings);\n        }\n    }\n}\n\nvar canvasSize = {\n    maxArea: function maxArea() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.area)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxHeight: function maxHeight() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: 1,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.height)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxWidth: function maxWidth() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: 1,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.width)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    test: function test() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var settings = _objectSpread2(_objectSpread2({}, defaults), options);\n        settings.sizes = _toConsumableArray(settings.sizes);\n        if (settings.width && settings.height) {\n            settings.sizes = [ [ settings.width, settings.height ] ];\n        }\n        return handleMethod(settings);\n    }\n};\n\n\n//# sourceMappingURL=canvas-size.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLXNpemUvZGlzdC9jYW52YXMtc2l6ZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyw2RUFBNkU7QUFDdEcsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix1Q0FBdUMscUNBQXFDLGdCQUFnQjtBQUMvSztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNFQUFzRSx5QkFBeUI7QUFDL0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzRUFBc0UseUJBQXlCO0FBQy9GO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0VBQXNFLHlCQUF5QjtBQUMvRjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsdXRvLWxlYXJuaW5nLy4vbm9kZV9tb2R1bGVzL2NhbnZhcy1zaXplL2Rpc3QvY2FudmFzLXNpemUuZXNtLmpzPzhhY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBjYW52YXMtc2l6ZVxuICogdjEuMi42XG4gKiBodHRwczovL2dpdGh1Yi5jb20vamhpbGRlbmJpZGRsZS9jYW52YXMtc2l6ZVxuICogKGMpIDIwMTUtMjAyMyBKb2huIEhpbGRlbmJpZGRsZSA8aHR0cDovL2hpbGRlbmJpZGRsZS5jb20+XG4gKiBNSVQgbGljZW5zZVxuICovXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICAgICAgdmFyIF9zLCBfZSwgX3gsIF9yLCBfYXJyID0gW10sIF9uID0gITAsIF9kID0gITE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX3ggPSAoX2kgPSBfaS5jYWxsKGFycikpLm5leHQsIDAgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjtcbiAgICAgICAgICAgICAgICBfbiA9ICExO1xuICAgICAgICAgICAgfSBlbHNlIGZvciAoOyEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCkgO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2kucmV0dXJuICYmIChfciA9IF9pLnJldHVybigpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcigoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSkpKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gY2FudmFzVGVzdChzZXR0aW5ncykge1xuICAgIHZhciBzaXplID0gc2V0dGluZ3Muc2l6ZXMuc2hpZnQoKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoc2l6ZVswXSksIDEpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoc2l6ZVsxXSksIDEpO1xuICAgIHZhciBmaWxsID0gWyB3aWR0aCAtIDEsIGhlaWdodCAtIDEsIDEsIDEgXTtcbiAgICB2YXIgam9iID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgaXNXb3JrZXIgPSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlO1xuICAgIHZhciBjcm9wQ3ZzLCB0ZXN0Q3ZzO1xuICAgIGlmIChpc1dvcmtlcikge1xuICAgICAgICBjcm9wQ3ZzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICAgICAgdGVzdEN2cyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3JvcEN2cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIGNyb3BDdnMud2lkdGggPSAxO1xuICAgICAgICBjcm9wQ3ZzLmhlaWdodCA9IDE7XG4gICAgICAgIHRlc3RDdnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICB0ZXN0Q3ZzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRlc3RDdnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgY3JvcEN0eCA9IGNyb3BDdnMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHZhciB0ZXN0Q3R4ID0gdGVzdEN2cy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKHRlc3RDdHgpIHtcbiAgICAgICAgdGVzdEN0eC5maWxsUmVjdC5hcHBseSh0ZXN0Q3R4LCBmaWxsKTtcbiAgICAgICAgY3JvcEN0eC5kcmF3SW1hZ2UodGVzdEN2cywgd2lkdGggLSAxLCBoZWlnaHQgLSAxLCAxLCAxLCAwLCAwLCAxLCAxKTtcbiAgICB9XG4gICAgdmFyIGlzVGVzdFBhc3MgPSBjcm9wQ3R4ICYmIGNyb3BDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbM10gIT09IDA7XG4gICAgdmFyIGJlbmNobWFyayA9IERhdGUubm93KCkgLSBqb2I7XG4gICAgWyBjcm9wQ3ZzLCB0ZXN0Q3ZzIF0uZm9yRWFjaCgoZnVuY3Rpb24oY3ZzKSB7XG4gICAgICAgIGN2cy5oZWlnaHQgPSAwO1xuICAgICAgICBjdnMud2lkdGggPSAwO1xuICAgIH0pKTtcbiAgICBpZiAoaXNXb3JrZXIpIHtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBiZW5jaG1hcms6IGJlbmNobWFyayxcbiAgICAgICAgICAgIGlzVGVzdFBhc3M6IGlzVGVzdFBhc3NcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNUZXN0UGFzcyAmJiBzZXR0aW5ncy5zaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbnZhc1Rlc3Qoc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1Rlc3RQYXNzKSB7XG4gICAgICAgIHNldHRpbmdzLm9uU3VjY2Vzcyh3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzLm9uRXJyb3Iod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnNpemVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FudmFzVGVzdChzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzVGVzdFBhc3M7XG59XG5cbnZhciB0ZXN0U2l6ZXMgPSB7XG4gICAgYXJlYTogWyAxNjM4NCwgMTQxODgsIDExNDAyLCAxMTE4MCwgMTA4MzYsIDgxOTIsIDQwOTYsIDEgXSxcbiAgICBoZWlnaHQ6IFsgODM4ODYwNywgNjU1MzUsIDMyNzY3LCAxNjM4NCwgODE5MiwgNDA5NiwgMSBdLFxuICAgIHdpZHRoOiBbIDQxOTQzMDMsIDY1NTM1LCAzMjc2NywgMTYzODQsIDgxOTIsIDQwOTYsIDEgXVxufTtcblxudmFyIF9leGNsdWRlZCA9IFsgXCJvbkVycm9yXCIsIFwib25TdWNjZXNzXCIgXTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIG1heDogbnVsbCxcbiAgICBtaW46IDEsXG4gICAgc2l6ZXM6IFtdLFxuICAgIHN0ZXA6IDEwMjQsXG4gICAgdXNlUHJvbWlzZTogZmFsc2UsXG4gICAgdXNlV29ya2VyOiBmYWxzZSxcbiAgICBvbkVycm9yOiBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb25TdWNjZXNzOiBGdW5jdGlvbi5wcm90b3R5cGVcbn07XG5cbnZhciB3b3JrZXJKb2JzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpemVzQXJyYXkoc2V0dGluZ3MpIHtcbiAgICB2YXIgaXNBcmVhID0gc2V0dGluZ3Mud2lkdGggPT09IHNldHRpbmdzLmhlaWdodDtcbiAgICB2YXIgaXNXaWR0aCA9IHNldHRpbmdzLmhlaWdodCA9PT0gMTtcbiAgICB2YXIgaXNIZWlnaHQgPSBzZXR0aW5ncy53aWR0aCA9PT0gMTtcbiAgICB2YXIgc2l6ZXMgPSBbXTtcbiAgICBpZiAoIXNldHRpbmdzLndpZHRoIHx8ICFzZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgc2V0dGluZ3Muc2l6ZXMuZm9yRWFjaCgoZnVuY3Rpb24odGVzdFNpemUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGlzQXJlYSB8fCBpc1dpZHRoID8gdGVzdFNpemUgOiAxO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlzQXJlYSB8fCBpc0hlaWdodCA/IHRlc3RTaXplIDogMTtcbiAgICAgICAgICAgIHNpemVzLnB1c2goWyB3aWR0aCwgaGVpZ2h0IF0pO1xuICAgICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRlc3RNaW4gPSBzZXR0aW5ncy5taW4gfHwgZGVmYXVsdHMubWluO1xuICAgICAgICB2YXIgdGVzdFN0ZXAgPSBzZXR0aW5ncy5zdGVwIHx8IGRlZmF1bHRzLnN0ZXA7XG4gICAgICAgIHZhciB0ZXN0U2l6ZSA9IE1hdGgubWF4KHNldHRpbmdzLndpZHRoLCBzZXR0aW5ncy5oZWlnaHQpO1xuICAgICAgICB3aGlsZSAodGVzdFNpemUgPj0gdGVzdE1pbikge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaXNBcmVhIHx8IGlzV2lkdGggPyB0ZXN0U2l6ZSA6IDE7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaXNBcmVhIHx8IGlzSGVpZ2h0ID8gdGVzdFNpemUgOiAxO1xuICAgICAgICAgICAgc2l6ZXMucHVzaChbIHdpZHRoLCBoZWlnaHQgXSk7XG4gICAgICAgICAgICB0ZXN0U2l6ZSAtPSB0ZXN0U3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZXM7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1ldGhvZChzZXR0aW5ncykge1xuICAgIHZhciBoYXNDYW52YXNTdXBwb3J0ID0gd2luZG93ICYmIFwiSFRNTENhbnZhc0VsZW1lbnRcIiBpbiB3aW5kb3c7XG4gICAgdmFyIGhhc09mZnNjcmVlbkNhbnZhc1N1cHBvcnQgPSB3aW5kb3cgJiYgXCJPZmZzY3JlZW5DYW52YXNcIiBpbiB3aW5kb3c7XG4gICAgdmFyIGpvYklEID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgX29uRXJyb3IgPSBzZXR0aW5ncy5vbkVycm9yLCBfb25TdWNjZXNzID0gc2V0dGluZ3Mub25TdWNjZXNzLCBzZXR0aW5nc1dpdGhvdXRDYWxsYmFja3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc2V0dGluZ3MsIF9leGNsdWRlZCk7XG4gICAgdmFyIHdvcmtlciA9IG51bGw7XG4gICAgaWYgKCFoYXNDYW52YXNTdXBwb3J0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLnVzZVdvcmtlciAmJiBoYXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0KSB7XG4gICAgICAgIHZhciBqcyA9IFwiXFxuICAgICAgICAgICAgdmFyIGNhbnZhc1Rlc3QgPSBcIi5jb25jYXQoY2FudmFzVGVzdC50b1N0cmluZygpLCBcIjtcXG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XFxuICAgICAgICAgICAgICAgIGNhbnZhc1Rlc3QoZS5kYXRhKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgXCIpO1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFsganMgXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBfZSRkYXRhID0gZS5kYXRhLCB3aWR0aCA9IF9lJGRhdGEud2lkdGgsIGhlaWdodCA9IF9lJGRhdGEuaGVpZ2h0LCBiZW5jaG1hcmsgPSBfZSRkYXRhLmJlbmNobWFyaywgaXNUZXN0UGFzcyA9IF9lJGRhdGEuaXNUZXN0UGFzcztcbiAgICAgICAgICAgIGlmIChpc1Rlc3RQYXNzKSB7XG4gICAgICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0ub25TdWNjZXNzKHdpZHRoLCBoZWlnaHQsIGJlbmNobWFyayk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdvcmtlckpvYnNbam9iSURdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrZXJKb2JzW2pvYklEXS5vbkVycm9yKHdpZHRoLCBoZWlnaHQsIGJlbmNobWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy51c2VQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZVNldHRpbmdzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNldHRpbmdzKSwge30sIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHdpZHRoLCBoZWlnaHQsIGJlbmNobWFyaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNMYXN0VGVzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNpemVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNMYXN0VGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3NldHRpbmdzJHNpemVzJHNsaWNlID0gc2V0dGluZ3Muc2l6ZXMuc2xpY2UoLTEpLCBfc2V0dGluZ3Mkc2l6ZXMkc2xpY2UyID0gX3NsaWNlZFRvQXJyYXkoX3NldHRpbmdzJHNpemVzJHNsaWNlLCAxKSwgX3NldHRpbmdzJHNpemVzJHNsaWNlMyA9IF9zbGljZWRUb0FycmF5KF9zZXR0aW5ncyRzaXplcyRzbGljZTJbMF0sIDIpLCBsYXN0V2lkdGggPSBfc2V0dGluZ3Mkc2l6ZXMkc2xpY2UzWzBdLCBsYXN0SGVpZ2h0ID0gX3NldHRpbmdzJHNpemVzJHNsaWNlM1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdFRlc3QgPSB3aWR0aCA9PT0gbGFzdFdpZHRoICYmIGhlaWdodCA9PT0gbGFzdEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfb25FcnJvcih3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYXN0VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVuY2htYXJrOiBiZW5jaG1hcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2Vzcyh3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgX29uU3VjY2Vzcyh3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVuY2htYXJrOiBiZW5jaG1hcmtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBwcm9taXNlU2V0dGluZ3Mub25FcnJvciwgb25TdWNjZXNzID0gcHJvbWlzZVNldHRpbmdzLm9uU3VjY2VzcztcbiAgICAgICAgICAgICAgICB3b3JrZXJKb2JzW2pvYklEXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShzZXR0aW5nc1dpdGhvdXRDYWxsYmFja3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXNUZXN0KHByb21pc2VTZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgICB3b3JrZXJKb2JzW2pvYklEXSA9IHtcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBfb25FcnJvcixcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IF9vblN1Y2Nlc3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2tzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXNUZXN0KHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGNhbnZhc1NpemUgPSB7XG4gICAgbWF4QXJlYTogZnVuY3Rpb24gbWF4QXJlYSgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgc2l6ZXMgPSBjcmVhdGVTaXplc0FycmF5KHtcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5tYXgsXG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgc3RlcDogb3B0aW9ucy5zdGVwLFxuICAgICAgICAgICAgc2l6ZXM6IF90b0NvbnN1bWFibGVBcnJheSh0ZXN0U2l6ZXMuYXJlYSlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgc2l6ZXM6IHNpemVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlTWV0aG9kKHNldHRpbmdzKTtcbiAgICB9LFxuICAgIG1heEhlaWdodDogZnVuY3Rpb24gbWF4SGVpZ2h0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBzaXplcyA9IGNyZWF0ZVNpemVzQXJyYXkoe1xuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4LFxuICAgICAgICAgICAgbWluOiBvcHRpb25zLm1pbixcbiAgICAgICAgICAgIHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgICAgICAgICAgIHNpemVzOiBfdG9Db25zdW1hYmxlQXJyYXkodGVzdFNpemVzLmhlaWdodClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgc2l6ZXM6IHNpemVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlTWV0aG9kKHNldHRpbmdzKTtcbiAgICB9LFxuICAgIG1heFdpZHRoOiBmdW5jdGlvbiBtYXhXaWR0aCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgc2l6ZXMgPSBjcmVhdGVTaXplc0FycmF5KHtcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBzdGVwOiBvcHRpb25zLnN0ZXAsXG4gICAgICAgICAgICBzaXplczogX3RvQ29uc3VtYWJsZUFycmF5KHRlc3RTaXplcy53aWR0aClcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgc2l6ZXM6IHNpemVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlTWV0aG9kKHNldHRpbmdzKTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICAgIHNldHRpbmdzLnNpemVzID0gX3RvQ29uc3VtYWJsZUFycmF5KHNldHRpbmdzLnNpemVzKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLndpZHRoICYmIHNldHRpbmdzLmhlaWdodCkge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2l6ZXMgPSBbIFsgc2V0dGluZ3Mud2lkdGgsIHNldHRpbmdzLmhlaWdodCBdIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgY2FudmFzU2l6ZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW52YXMtc2l6ZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js\n");

/***/ })

};
;