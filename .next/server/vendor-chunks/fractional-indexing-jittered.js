"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fractional-indexing-jittered";
exports.ids = ["vendor-chunks/fractional-indexing-jittered"];
exports.modules = {

/***/ "(ssr)/./node_modules/fractional-indexing-jittered/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/fractional-indexing-jittered/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IndexGenerator: () => (/* binding */ IndexGenerator),\n/* harmony export */   base62CharSet: () => (/* binding */ base62CharSet),\n/* harmony export */   generateJitteredKeyBetween: () => (/* binding */ generateJitteredKeyBetween),\n/* harmony export */   generateKeyBetween: () => (/* binding */ generateKeyBetween),\n/* harmony export */   generateNJitteredKeysBetween: () => (/* binding */ generateNJitteredKeysBetween),\n/* harmony export */   generateNKeysBetween: () => (/* binding */ generateNKeysBetween),\n/* harmony export */   indexCharacterSet: () => (/* binding */ indexCharacterSet)\n/* harmony export */ });\n// src/charSet.ts\nfunction indexCharacterSet(options) {\n  const dicts = createCharSetDicts(options.chars);\n  const limits = integerLimits(\n    dicts,\n    options.firstPositive,\n    options.mostPositive,\n    options.mostNegative\n  );\n  const jitterRange = options.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);\n  const paddingRange = paddingDict(jitterRange, dicts.length);\n  return {\n    chars: options.chars,\n    byChar: dicts.byChar,\n    byCode: dicts.byCode,\n    length: dicts.length,\n    first: dicts.byCode[0],\n    last: dicts.byCode[dicts.length - 1],\n    firstPositive: limits.firstPositive,\n    mostPositive: limits.mostPositive,\n    firstNegative: limits.firstNegative,\n    mostNegative: limits.mostNegative,\n    jitterRange,\n    paddingDict: paddingRange\n  };\n}\nfunction createCharSetDicts(charSet) {\n  const byCode = {};\n  const byChar = {};\n  const length = charSet.length;\n  for (let i = 0; i < length; i++) {\n    const char = charSet[i];\n    byCode[i] = char;\n    byChar[char] = i;\n  }\n  return {\n    byCode,\n    byChar,\n    length\n  };\n}\nfunction integerLimits(dicts, firstPositive, mostPositive, mostNegative) {\n  const firstPositiveIndex = firstPositive ? dicts.byChar[firstPositive] : Math.ceil(dicts.length / 2);\n  const mostPositiveIndex = mostPositive ? dicts.byChar[mostPositive] : dicts.length - 1;\n  const mostNegativeIndex = mostNegative ? dicts.byChar[mostNegative] : 0;\n  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {\n    throw new Error(\"invalid charSet\");\n  }\n  if (mostPositiveIndex - firstPositiveIndex < 3) {\n    throw new Error(\n      \"mostPositive must be at least 3 characters away from neutral\"\n    );\n  }\n  if (firstPositiveIndex - mostNegativeIndex < 3) {\n    throw new Error(\n      \"mostNegative must be at least 3 characters away from neutral\"\n    );\n  }\n  return {\n    firstPositive: dicts.byCode[firstPositiveIndex],\n    mostPositive: dicts.byCode[mostPositiveIndex],\n    firstNegative: dicts.byCode[firstPositiveIndex - 1],\n    mostNegative: dicts.byCode[mostNegativeIndex]\n  };\n}\nfunction paddingDict(jitterRange, charSetLength) {\n  const paddingDict2 = {};\n  let distance = 0;\n  for (let i = 0; i < 100; i++) {\n    paddingDict2[i] = Math.pow(charSetLength, i);\n    if (paddingDict2[i] > jitterRange) {\n      break;\n    }\n  }\n  return paddingDict2;\n}\nvar _base62CharSet = null;\nfunction base62CharSet() {\n  if (_base62CharSet)\n    return _base62CharSet;\n  return _base62CharSet = indexCharacterSet({\n    // Base62 are all the alphanumeric characters, database and user friendly\n    // For shorter strings and more room you could opt for more characters\n    chars: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n    // This gives us nice human readable keys to start with a0 a1 etc\n    firstPositive: \"a\",\n    mostPositive: \"z\",\n    mostNegative: \"A\"\n  });\n}\n\n// src/integerLength.ts\nfunction distanceBetween(a, b, charSet) {\n  const indexA = charSet.byChar[a];\n  const indexB = charSet.byChar[b];\n  return Math.abs(indexA - indexB);\n}\nfunction integerLength(head, charSet) {\n  const firstChar = head[0];\n  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {\n    throw new Error(\"invalid firstChar on key\");\n  }\n  if (firstChar === charSet.mostPositive) {\n    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;\n    return firstLevel + integerLengthFromSecondLevel(head.slice(1), \"positive\", charSet);\n  }\n  if (firstChar === charSet.mostNegative) {\n    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;\n    return firstLevel + integerLengthFromSecondLevel(head.slice(1), \"negative\", charSet);\n  }\n  const isPositiveRange = firstChar >= charSet.firstPositive;\n  if (isPositiveRange) {\n    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;\n  } else {\n    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;\n  }\n}\nfunction integerLengthFromSecondLevel(key, direction, charSet) {\n  const firstChar = key[0];\n  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {\n    throw new Error(\"invalid firstChar on key\");\n  }\n  if (firstChar === charSet.mostPositive && direction === \"positive\") {\n    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;\n    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);\n  }\n  if (firstChar === charSet.mostNegative && direction === \"negative\") {\n    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;\n    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);\n  }\n  if (direction === \"positive\") {\n    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;\n  } else {\n    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;\n  }\n}\n\n// src/padToSameLength.ts\nfunction makeSameLength(a, b, pad, fillChar, forceLength) {\n  const max = forceLength ?? Math.max(a.length, b.length);\n  if (pad === \"start\") {\n    return [a.padStart(max, fillChar), b.padStart(max, fillChar)];\n  }\n  return [a.padEnd(max, fillChar), b.padEnd(max, fillChar)];\n}\n\n// src/keyAsNumber.ts\nfunction midPoint(lower, upper, charSet) {\n  let [paddedLower, paddedUpper] = makeSameLength(\n    lower,\n    upper,\n    \"end\",\n    charSet.first\n  );\n  let distance = lexicalDistance(paddedLower, paddedUpper, charSet);\n  if (distance === 1) {\n    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);\n    distance = charSet.length;\n  }\n  const mid = encodeToCharSet(Math.floor(distance / 2), charSet);\n  return addCharSetKeys(paddedLower, mid, charSet);\n}\nfunction lexicalDistance(a, b, charSet) {\n  const [lower, upper] = makeSameLength(a, b, \"end\", charSet.first).sort();\n  const distance = subtractCharSetKeys(upper, lower, charSet);\n  return decodeCharSetToNumber(distance, charSet);\n}\nfunction addCharSetKeys(a, b, charSet) {\n  const base = charSet.length;\n  const [paddedA, paddedB] = makeSameLength(a, b, \"start\", charSet.first);\n  const result = [];\n  let carry = 0;\n  for (let i = paddedA.length - 1; i >= 0; i--) {\n    const digitA = charSet.byChar[paddedA[i]];\n    const digitB = charSet.byChar[paddedB[i]];\n    const sum = digitA + digitB + carry;\n    carry = Math.floor(sum / base);\n    const remainder = sum % base;\n    result.unshift(charSet.byCode[remainder]);\n  }\n  if (carry > 0) {\n    result.unshift(charSet.byCode[carry]);\n  }\n  return result.join(\"\");\n}\nfunction subtractCharSetKeys(a, b, charSet) {\n  const base = charSet.length;\n  const [paddedA, paddedB] = makeSameLength(a, b, \"start\", charSet.first);\n  const result = [];\n  let borrow = 0;\n  for (let i = paddedA.length - 1; i >= 0; i--) {\n    let digitA = charSet.byChar[paddedA[i]];\n    const digitB = charSet.byChar[paddedB[i]] + borrow;\n    if (digitA < digitB) {\n      borrow = 1;\n      digitA += base;\n    } else {\n      borrow = 0;\n    }\n    const difference = digitA - digitB;\n    result.unshift(charSet.byCode[difference]);\n  }\n  if (borrow > 0) {\n    throw new Error(\n      \"Subtraction result is negative. Ensure a is greater than or equal to b.\"\n    );\n  }\n  while (result.length > 1 && result[0] === charSet.byCode[0]) {\n    result.shift();\n  }\n  return result.join(\"\");\n}\nfunction incrementKey(key, charSet) {\n  return addCharSetKeys(key, charSet.byCode[1], charSet);\n}\nfunction decrementKey(key, charSet) {\n  return subtractCharSetKeys(key, charSet.byCode[1], charSet);\n}\nfunction encodeToCharSet(int, charSet) {\n  if (int === 0) {\n    return charSet.byCode[0];\n  }\n  let res = \"\";\n  const max = charSet.length;\n  while (int > 0) {\n    res = charSet.byCode[int % max] + res;\n    int = Math.floor(int / max);\n  }\n  return res;\n}\nfunction decodeCharSetToNumber(key, charSet) {\n  let res = 0;\n  const length = key.length;\n  const max = charSet.length;\n  for (let i = 0; i < length; i++) {\n    res += charSet.byChar[key[i]] * Math.pow(max, length - i - 1);\n  }\n  return res;\n}\n\n// src/integer.ts\nfunction startKey(charSet) {\n  return charSet.firstPositive + charSet.byCode[0];\n}\nfunction validInteger(integer, charSet) {\n  const length = integerLength(integer, charSet);\n  return length === integer.length;\n}\nfunction validateOrderKey(orderKey, charSet) {\n  getIntegerPart(orderKey, charSet);\n}\nfunction getIntegerPart(orderKey, charSet) {\n  const head = integerHead(orderKey, charSet);\n  const integerPartLength = integerLength(head, charSet);\n  if (integerPartLength > orderKey.length) {\n    throw new Error(\"invalid order key length: \" + orderKey);\n  }\n  return orderKey.slice(0, integerPartLength);\n}\nfunction validateInteger(integer, charSet) {\n  if (!validInteger(integer, charSet)) {\n    throw new Error(\"invalid integer length: \" + integer);\n  }\n}\nfunction incrementInteger(integer, charSet) {\n  validateInteger(integer, charSet);\n  const [head, digs] = splitInteger(integer, charSet);\n  const anyNonMaxedDigit = digs.split(\"\").some((d) => d !== charSet.byCode[charSet.length - 1]);\n  if (anyNonMaxedDigit) {\n    const newDigits = incrementKey(digs, charSet);\n    return head + newDigits;\n  }\n  const nextHead = incrementIntegerHead(head, charSet);\n  return startOnNewHead(nextHead, \"lower\", charSet);\n}\nfunction decrementInteger(integer, charSet) {\n  validateInteger(integer, charSet);\n  const [head, digs] = splitInteger(integer, charSet);\n  const anyNonLimitDigit = digs.split(\"\").some((d) => d !== charSet.byCode[0]);\n  if (anyNonLimitDigit) {\n    const newDigits = decrementKey(digs, charSet);\n    return head + newDigits;\n  }\n  const nextHead = decrementIntegerHead(head, charSet);\n  return startOnNewHead(nextHead, \"upper\", charSet);\n}\nfunction integerHead(integer, charSet) {\n  let i = 0;\n  if (integer[0] === charSet.mostPositive) {\n    while (integer[i] === charSet.mostPositive) {\n      i = i + 1;\n    }\n  }\n  if (integer[0] === charSet.mostNegative) {\n    while (integer[i] === charSet.mostNegative) {\n      i = i + 1;\n    }\n  }\n  return integer.slice(0, i + 1);\n}\nfunction splitInteger(integer, charSet) {\n  const head = integerHead(integer, charSet);\n  const tail = integer.slice(head.length);\n  return [head, tail];\n}\nfunction incrementIntegerHead(head, charSet) {\n  const inPositiveRange = head >= charSet.firstPositive;\n  const nextHead = incrementKey(head, charSet);\n  const headIsLimitMax = head[head.length - 1] === charSet.mostPositive;\n  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;\n  if (inPositiveRange && nextHeadIsLimitMax) {\n    return nextHead + charSet.mostNegative;\n  }\n  if (!inPositiveRange && headIsLimitMax) {\n    return head.slice(0, head.length - 1);\n  }\n  return nextHead;\n}\nfunction decrementIntegerHead(head, charSet) {\n  const inPositiveRange = head >= charSet.firstPositive;\n  const headIsLimitMin = head[head.length - 1] === charSet.mostNegative;\n  if (inPositiveRange && headIsLimitMin) {\n    const nextLevel = head.slice(0, head.length - 1);\n    return decrementKey(nextLevel, charSet);\n  }\n  if (!inPositiveRange && headIsLimitMin) {\n    return head + charSet.mostPositive;\n  }\n  return decrementKey(head, charSet);\n}\nfunction startOnNewHead(head, limit, charSet) {\n  const newLength = integerLength(head, charSet);\n  const fillChar = limit === \"upper\" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];\n  return head + fillChar.repeat(newLength - head.length);\n}\n\n// src/jittering.ts\nfunction jitterString(orderKey, charSet) {\n  const shift = encodeToCharSet(\n    Math.floor(Math.random() * charSet.jitterRange),\n    charSet\n  );\n  return addCharSetKeys(orderKey, shift, charSet);\n}\nfunction padAndJitterString(orderKey, numberOfChars, charSet) {\n  const paddedKey = orderKey.padEnd(\n    orderKey.length + numberOfChars,\n    charSet.first\n  );\n  return jitterString(paddedKey, charSet);\n}\nfunction paddingNeededForJitter(orderKey, b, charSet) {\n  const integer = getIntegerPart(orderKey, charSet);\n  const nextInteger = incrementInteger(integer, charSet);\n  let needed = 0;\n  if (b !== null) {\n    const distanceToB = lexicalDistance(orderKey, b, charSet);\n    if (distanceToB < charSet.jitterRange + 1) {\n      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));\n    }\n  }\n  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);\n  if (distanceToNextInteger < charSet.jitterRange + 1) {\n    needed = Math.max(\n      needed,\n      paddingNeededForDistance(distanceToNextInteger, charSet)\n    );\n  }\n  return needed;\n}\nfunction paddingNeededForDistance(distance, charSet) {\n  const gap = charSet.jitterRange - distance;\n  const firstBigger = Object.entries(charSet.paddingDict).find(\n    ([_key, value]) => {\n      return value > gap;\n    }\n  );\n  return firstBigger ? parseInt(firstBigger[0]) : 0;\n}\n\n// src/generateKeyBetween.ts\nfunction generateKeyBetween(lower, upper, charSet = base62CharSet()) {\n  if (lower !== null) {\n    validateOrderKey(lower, charSet);\n  }\n  if (upper !== null) {\n    validateOrderKey(upper, charSet);\n  }\n  if (lower === null && upper === null) {\n    return startKey(charSet);\n  }\n  if (lower === null) {\n    const integer = getIntegerPart(upper, charSet);\n    return decrementInteger(integer, charSet);\n  }\n  if (upper === null) {\n    const integer = getIntegerPart(lower, charSet);\n    return incrementInteger(integer, charSet);\n  }\n  if (lower >= upper) {\n    throw new Error(lower + \" >= \" + upper);\n  }\n  return midPoint(lower, upper, charSet);\n}\nfunction generateNKeysBetween(a, b, n, charSet = base62CharSet()) {\n  return spreadGeneratorResults(\n    a,\n    b,\n    n,\n    charSet,\n    generateKeyBetween,\n    generateNKeysBetween\n  );\n}\nfunction generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {\n  const key = generateKeyBetween(lower, upper, charSet);\n  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);\n  if (paddingNeeded) {\n    return padAndJitterString(key, paddingNeeded, charSet);\n  }\n  return jitterString(key, charSet);\n}\nfunction generateNJitteredKeysBetween(lower, upper, n, charSet = base62CharSet()) {\n  return spreadGeneratorResults(\n    lower,\n    upper,\n    n,\n    charSet,\n    generateJitteredKeyBetween,\n    generateNJitteredKeysBetween\n  );\n}\nfunction spreadGeneratorResults(lower, upper, n, charSet, generateKey, generateNKeys) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKey(lower, upper, charSet)];\n  }\n  if (upper == null) {\n    let newUpper = generateKey(lower, upper, charSet);\n    const result = [newUpper];\n    for (let i = 0; i < n - 1; i++) {\n      newUpper = generateKey(newUpper, upper, charSet);\n      result.push(newUpper);\n    }\n    return result;\n  }\n  if (lower == null) {\n    let newLower = generateKey(lower, upper, charSet);\n    const result = [newLower];\n    for (let i = 0; i < n - 1; i++) {\n      newLower = generateKey(lower, newLower, charSet);\n      result.push(newLower);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const midOrderKey = generateKey(lower, upper, charSet);\n  return [\n    ...generateNKeys(lower, midOrderKey, mid, charSet),\n    midOrderKey,\n    ...generateNKeys(midOrderKey, upper, n - mid - 1, charSet)\n  ];\n}\n\n// src/IndexGenerator.ts\nvar IndexGenerator = class {\n  charSet;\n  useJitter;\n  list;\n  useGroups;\n  groupIdLength;\n  constructor(list, options = {}) {\n    this.charSet = options.charSet ?? base62CharSet();\n    this.useJitter = options.useJitter ?? true;\n    this.list = list;\n    this.useGroups = !!options.groupIdLength && options.groupIdLength > 0;\n    this.groupIdLength = options.groupIdLength ?? 0;\n  }\n  /**\n   * Updates the list that the generator uses to generate keys.\n   * The generator will not mutate the internal list when generating keys.\n   */\n  updateList(list) {\n    this.list = [...list].sort();\n  }\n  /**\n   * Generate any number of keys at the start of the list (before the first key).\n   * Optionally you can supply a groupId to generate keys at the start of a specific group.\n   */\n  nKeysStart(n, groupId) {\n    this.validateGroupId(groupId);\n    return this.generateNKeysBetween(\n      null,\n      this.firstOfGroup(groupId),\n      n,\n      groupId\n    );\n  }\n  /**\n   * Generate a single key at the start of the list (before the first key).\n   * Optionally you can supply a groupId to generate a key at the start of a specific group.\n   */\n  keyStart(groupId) {\n    this.validateGroupId(groupId);\n    return this.nKeysStart(1, groupId)[0];\n  }\n  /**\n   * Generate any number of keys at the end of the list (after the last key).\n   * Optionally you can supply a groupId to generate keys at the end of a specific group.\n   */\n  nKeysEnd(n, groupId) {\n    this.validateGroupId(groupId);\n    return this.generateNKeysBetween(\n      this.lastOfGroup(groupId),\n      null,\n      n,\n      groupId\n    );\n  }\n  /**\n   * Generate a single key at the end of the list (after the last key).\n   * Optionally you can supply a groupId to generate a key at the end of a specific group.\n   */\n  keyEnd(groupId) {\n    this.validateGroupId(groupId);\n    return this.nKeysEnd(1, groupId)[0];\n  }\n  /**\n   * Generate any number of keys behind a specific key and in front of the next key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  nKeysAfter(orderKey, n) {\n    const keyAfter = this.getKeyAfter(orderKey);\n    return this.generateNKeysBetween(\n      orderKey,\n      keyAfter,\n      n,\n      this.groupId(orderKey)\n    );\n  }\n  /**\n   * Generate a single key behind a specific key and in front of the next key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  keyAfter(orderKey) {\n    return this.nKeysAfter(orderKey, 1)[0];\n  }\n  /**\n   * Generate any number of keys in front of a specific key and behind the previous key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  nKeysBefore(orderKey, n) {\n    const keyBefore = this.getKeyBefore(orderKey);\n    return this.generateNKeysBetween(\n      keyBefore,\n      orderKey,\n      n,\n      this.groupId(orderKey)\n    );\n  }\n  /**\n   * Generate a single key in front of a specific key and behind the previous key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  keyBefore(orderKey) {\n    return this.nKeysBefore(orderKey, 1)[0];\n  }\n  /**\n   * private function responsible for calling the correct generate function\n   */\n  generateNKeysBetween(lowerKey, upperKey, n, groupId) {\n    const lower = this.groupLessKey(lowerKey);\n    const upper = this.groupLessKey(upperKey);\n    const keys = this.useJitter ? generateNJitteredKeysBetween(lower, upper, n, this.charSet) : generateNKeysBetween(lower, upper, n, this.charSet);\n    return !groupId ? keys : keys.map((key) => groupId + key);\n  }\n  /**\n   * get the key before the supplied orderKey, if it exists and is in the same group\n   */\n  getKeyBefore(orderKey) {\n    const index = this.list.indexOf(orderKey);\n    if (index === -1) {\n      throw new Error(`orderKey is not in the list`);\n    }\n    const before = this.list[index - 1];\n    return !!before && this.isSameGroup(orderKey, before) ? before : null;\n  }\n  /**\n   * get the key after the supplied orderKey, if it exists and is in the same group\n   */\n  getKeyAfter(orderKey) {\n    const index = this.list.indexOf(orderKey);\n    if (index === -1) {\n      throw new Error(`orderKey is not in the list`);\n    }\n    const after = this.list[index + 1];\n    return !!after && this.isSameGroup(orderKey, after) ? after : null;\n  }\n  /**\n   * get the first key of the group (or the first key of the list if not using groups)\n   */\n  firstOfGroup(groupId) {\n    if (!this.useGroups)\n      return this.list[0] ?? null;\n    const first = this.list.find((key) => this.isPartOfGroup(key, groupId));\n    return first ?? null;\n  }\n  /**\n   * get the last key of the group (or the last key of the list if not using groups)\n   */\n  lastOfGroup(groupId) {\n    if (!this.useGroups)\n      return this.list[this.list.length - 1] ?? null;\n    const allGroupItems = this.list.filter(\n      (key) => this.isPartOfGroup(key, groupId)\n    );\n    const last = allGroupItems[allGroupItems.length - 1];\n    return last ?? null;\n  }\n  /**\n   * throw an error if the groupId is invalid or supplied when not using groups\n   */\n  validateGroupId(groupId) {\n    if (!this.useGroups) {\n      if (groupId) {\n        console.warn(\"groupId should not used when not using groups\");\n      }\n      return;\n    }\n    if (!groupId) {\n      throw new Error(\"groupId is required when using groups\");\n    }\n    if (groupId.length !== this.groupIdLength) {\n      throw new Error(`groupId must be the lenght supplied in the options`);\n    }\n  }\n  /**\n   * get the groupId from the orderKey\n   */\n  groupId(orderKey) {\n    if (!this.useGroups)\n      return void 0;\n    return this.splitIntoGroupIdAndOrderKey(orderKey)[0];\n  }\n  /**\n   * remove the groupId from the orderKey\n   */\n  groupLessKey(orderKey) {\n    if (!this.useGroups)\n      return orderKey;\n    return this.splitIntoGroupIdAndOrderKey(orderKey)[1];\n  }\n  /**\n   * split the orderKey into groupId and key\n   * if not using groups, orderKey will be the same as key\n   */\n  splitIntoGroupIdAndOrderKey(orderKey) {\n    if (!this.useGroups || !orderKey) {\n      return [void 0, orderKey];\n    }\n    const groupId = orderKey.substring(0, this.groupIdLength);\n    const key = orderKey.substring(this.groupIdLength);\n    return [groupId, key];\n  }\n  /**\n   * check if two keys are in the same group\n   * if not using groups, keys will always be in the same group\n   */\n  isSameGroup(a, b) {\n    if (!this.useGroups)\n      return true;\n    const [aGroupId] = this.splitIntoGroupIdAndOrderKey(a);\n    const [bGroupId] = this.splitIntoGroupIdAndOrderKey(b);\n    return aGroupId === bGroupId;\n  }\n  /**\n   * check if the key is part of the group\n   * if not using groups, key will always be part of the group\n   */\n  isPartOfGroup(orderKey, groupId) {\n    if (!this.useGroups)\n      return true;\n    const [keyGroupId] = this.splitIntoGroupIdAndOrderKey(orderKey);\n    return keyGroupId === groupId;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhY3Rpb25hbC1pbmRleGluZy1qaXR0ZXJlZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbHV0by1sZWFybmluZy8uL25vZGVfbW9kdWxlcy9mcmFjdGlvbmFsLWluZGV4aW5nLWppdHRlcmVkL2xpYi9pbmRleC5qcz8yMWU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jaGFyU2V0LnRzXG5mdW5jdGlvbiBpbmRleENoYXJhY3RlclNldChvcHRpb25zKSB7XG4gIGNvbnN0IGRpY3RzID0gY3JlYXRlQ2hhclNldERpY3RzKG9wdGlvbnMuY2hhcnMpO1xuICBjb25zdCBsaW1pdHMgPSBpbnRlZ2VyTGltaXRzKFxuICAgIGRpY3RzLFxuICAgIG9wdGlvbnMuZmlyc3RQb3NpdGl2ZSxcbiAgICBvcHRpb25zLm1vc3RQb3NpdGl2ZSxcbiAgICBvcHRpb25zLm1vc3ROZWdhdGl2ZVxuICApO1xuICBjb25zdCBqaXR0ZXJSYW5nZSA9IG9wdGlvbnMuaml0dGVyUmFuZ2UgPz8gTWF0aC5mbG9vcihNYXRoLnBvdyhkaWN0cy5sZW5ndGgsIDMpIC8gNSk7XG4gIGNvbnN0IHBhZGRpbmdSYW5nZSA9IHBhZGRpbmdEaWN0KGppdHRlclJhbmdlLCBkaWN0cy5sZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJzOiBvcHRpb25zLmNoYXJzLFxuICAgIGJ5Q2hhcjogZGljdHMuYnlDaGFyLFxuICAgIGJ5Q29kZTogZGljdHMuYnlDb2RlLFxuICAgIGxlbmd0aDogZGljdHMubGVuZ3RoLFxuICAgIGZpcnN0OiBkaWN0cy5ieUNvZGVbMF0sXG4gICAgbGFzdDogZGljdHMuYnlDb2RlW2RpY3RzLmxlbmd0aCAtIDFdLFxuICAgIGZpcnN0UG9zaXRpdmU6IGxpbWl0cy5maXJzdFBvc2l0aXZlLFxuICAgIG1vc3RQb3NpdGl2ZTogbGltaXRzLm1vc3RQb3NpdGl2ZSxcbiAgICBmaXJzdE5lZ2F0aXZlOiBsaW1pdHMuZmlyc3ROZWdhdGl2ZSxcbiAgICBtb3N0TmVnYXRpdmU6IGxpbWl0cy5tb3N0TmVnYXRpdmUsXG4gICAgaml0dGVyUmFuZ2UsXG4gICAgcGFkZGluZ0RpY3Q6IHBhZGRpbmdSYW5nZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhclNldERpY3RzKGNoYXJTZXQpIHtcbiAgY29uc3QgYnlDb2RlID0ge307XG4gIGNvbnN0IGJ5Q2hhciA9IHt9O1xuICBjb25zdCBsZW5ndGggPSBjaGFyU2V0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyU2V0W2ldO1xuICAgIGJ5Q29kZVtpXSA9IGNoYXI7XG4gICAgYnlDaGFyW2NoYXJdID0gaTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJ5Q29kZSxcbiAgICBieUNoYXIsXG4gICAgbGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBpbnRlZ2VyTGltaXRzKGRpY3RzLCBmaXJzdFBvc2l0aXZlLCBtb3N0UG9zaXRpdmUsIG1vc3ROZWdhdGl2ZSkge1xuICBjb25zdCBmaXJzdFBvc2l0aXZlSW5kZXggPSBmaXJzdFBvc2l0aXZlID8gZGljdHMuYnlDaGFyW2ZpcnN0UG9zaXRpdmVdIDogTWF0aC5jZWlsKGRpY3RzLmxlbmd0aCAvIDIpO1xuICBjb25zdCBtb3N0UG9zaXRpdmVJbmRleCA9IG1vc3RQb3NpdGl2ZSA/IGRpY3RzLmJ5Q2hhclttb3N0UG9zaXRpdmVdIDogZGljdHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgbW9zdE5lZ2F0aXZlSW5kZXggPSBtb3N0TmVnYXRpdmUgPyBkaWN0cy5ieUNoYXJbbW9zdE5lZ2F0aXZlXSA6IDA7XG4gIGlmIChmaXJzdFBvc2l0aXZlSW5kZXggPT09IHZvaWQgMCB8fCBtb3N0UG9zaXRpdmVJbmRleCA9PT0gdm9pZCAwIHx8IG1vc3ROZWdhdGl2ZUluZGV4ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNoYXJTZXRcIik7XG4gIH1cbiAgaWYgKG1vc3RQb3NpdGl2ZUluZGV4IC0gZmlyc3RQb3NpdGl2ZUluZGV4IDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwibW9zdFBvc2l0aXZlIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGF3YXkgZnJvbSBuZXV0cmFsXCJcbiAgICApO1xuICB9XG4gIGlmIChmaXJzdFBvc2l0aXZlSW5kZXggLSBtb3N0TmVnYXRpdmVJbmRleCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIm1vc3ROZWdhdGl2ZSBtdXN0IGJlIGF0IGxlYXN0IDMgY2hhcmFjdGVycyBhd2F5IGZyb20gbmV1dHJhbFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpcnN0UG9zaXRpdmU6IGRpY3RzLmJ5Q29kZVtmaXJzdFBvc2l0aXZlSW5kZXhdLFxuICAgIG1vc3RQb3NpdGl2ZTogZGljdHMuYnlDb2RlW21vc3RQb3NpdGl2ZUluZGV4XSxcbiAgICBmaXJzdE5lZ2F0aXZlOiBkaWN0cy5ieUNvZGVbZmlyc3RQb3NpdGl2ZUluZGV4IC0gMV0sXG4gICAgbW9zdE5lZ2F0aXZlOiBkaWN0cy5ieUNvZGVbbW9zdE5lZ2F0aXZlSW5kZXhdXG4gIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nRGljdChqaXR0ZXJSYW5nZSwgY2hhclNldExlbmd0aCkge1xuICBjb25zdCBwYWRkaW5nRGljdDIgPSB7fTtcbiAgbGV0IGRpc3RhbmNlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgIHBhZGRpbmdEaWN0MltpXSA9IE1hdGgucG93KGNoYXJTZXRMZW5ndGgsIGkpO1xuICAgIGlmIChwYWRkaW5nRGljdDJbaV0gPiBqaXR0ZXJSYW5nZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYWRkaW5nRGljdDI7XG59XG52YXIgX2Jhc2U2MkNoYXJTZXQgPSBudWxsO1xuZnVuY3Rpb24gYmFzZTYyQ2hhclNldCgpIHtcbiAgaWYgKF9iYXNlNjJDaGFyU2V0KVxuICAgIHJldHVybiBfYmFzZTYyQ2hhclNldDtcbiAgcmV0dXJuIF9iYXNlNjJDaGFyU2V0ID0gaW5kZXhDaGFyYWN0ZXJTZXQoe1xuICAgIC8vIEJhc2U2MiBhcmUgYWxsIHRoZSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycywgZGF0YWJhc2UgYW5kIHVzZXIgZnJpZW5kbHlcbiAgICAvLyBGb3Igc2hvcnRlciBzdHJpbmdzIGFuZCBtb3JlIHJvb20geW91IGNvdWxkIG9wdCBmb3IgbW9yZSBjaGFyYWN0ZXJzXG4gICAgY2hhcnM6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgICAvLyBUaGlzIGdpdmVzIHVzIG5pY2UgaHVtYW4gcmVhZGFibGUga2V5cyB0byBzdGFydCB3aXRoIGEwIGExIGV0Y1xuICAgIGZpcnN0UG9zaXRpdmU6IFwiYVwiLFxuICAgIG1vc3RQb3NpdGl2ZTogXCJ6XCIsXG4gICAgbW9zdE5lZ2F0aXZlOiBcIkFcIlxuICB9KTtcbn1cblxuLy8gc3JjL2ludGVnZXJMZW5ndGgudHNcbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlbihhLCBiLCBjaGFyU2V0KSB7XG4gIGNvbnN0IGluZGV4QSA9IGNoYXJTZXQuYnlDaGFyW2FdO1xuICBjb25zdCBpbmRleEIgPSBjaGFyU2V0LmJ5Q2hhcltiXTtcbiAgcmV0dXJuIE1hdGguYWJzKGluZGV4QSAtIGluZGV4Qik7XG59XG5mdW5jdGlvbiBpbnRlZ2VyTGVuZ3RoKGhlYWQsIGNoYXJTZXQpIHtcbiAgY29uc3QgZmlyc3RDaGFyID0gaGVhZFswXTtcbiAgaWYgKGZpcnN0Q2hhciA+IGNoYXJTZXQubW9zdFBvc2l0aXZlIHx8IGZpcnN0Q2hhciA8IGNoYXJTZXQubW9zdE5lZ2F0aXZlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaXJzdENoYXIgb24ga2V5XCIpO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09IGNoYXJTZXQubW9zdFBvc2l0aXZlKSB7XG4gICAgY29uc3QgZmlyc3RMZXZlbCA9IGRpc3RhbmNlQmV0d2VlbihmaXJzdENoYXIsIGNoYXJTZXQuZmlyc3RQb3NpdGl2ZSwgY2hhclNldCkgKyAxO1xuICAgIHJldHVybiBmaXJzdExldmVsICsgaW50ZWdlckxlbmd0aEZyb21TZWNvbmRMZXZlbChoZWFkLnNsaWNlKDEpLCBcInBvc2l0aXZlXCIsIGNoYXJTZXQpO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09IGNoYXJTZXQubW9zdE5lZ2F0aXZlKSB7XG4gICAgY29uc3QgZmlyc3RMZXZlbCA9IGRpc3RhbmNlQmV0d2VlbihmaXJzdENoYXIsIGNoYXJTZXQuZmlyc3ROZWdhdGl2ZSwgY2hhclNldCkgKyAxO1xuICAgIHJldHVybiBmaXJzdExldmVsICsgaW50ZWdlckxlbmd0aEZyb21TZWNvbmRMZXZlbChoZWFkLnNsaWNlKDEpLCBcIm5lZ2F0aXZlXCIsIGNoYXJTZXQpO1xuICB9XG4gIGNvbnN0IGlzUG9zaXRpdmVSYW5nZSA9IGZpcnN0Q2hhciA+PSBjaGFyU2V0LmZpcnN0UG9zaXRpdmU7XG4gIGlmIChpc1Bvc2l0aXZlUmFuZ2UpIHtcbiAgICByZXR1cm4gZGlzdGFuY2VCZXR3ZWVuKGZpcnN0Q2hhciwgY2hhclNldC5maXJzdFBvc2l0aXZlLCBjaGFyU2V0KSArIDI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlQmV0d2VlbihmaXJzdENoYXIsIGNoYXJTZXQuZmlyc3ROZWdhdGl2ZSwgY2hhclNldCkgKyAyO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlZ2VyTGVuZ3RoRnJvbVNlY29uZExldmVsKGtleSwgZGlyZWN0aW9uLCBjaGFyU2V0KSB7XG4gIGNvbnN0IGZpcnN0Q2hhciA9IGtleVswXTtcbiAgaWYgKGZpcnN0Q2hhciA+IGNoYXJTZXQubW9zdFBvc2l0aXZlIHx8IGZpcnN0Q2hhciA8IGNoYXJTZXQubW9zdE5lZ2F0aXZlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaXJzdENoYXIgb24ga2V5XCIpO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09IGNoYXJTZXQubW9zdFBvc2l0aXZlICYmIGRpcmVjdGlvbiA9PT0gXCJwb3NpdGl2ZVwiKSB7XG4gICAgY29uc3QgdG90YWxQb3NpdGl2ZVJvb20gPSBkaXN0YW5jZUJldHdlZW4oZmlyc3RDaGFyLCBjaGFyU2V0Lm1vc3ROZWdhdGl2ZSwgY2hhclNldCkgKyAxO1xuICAgIHJldHVybiB0b3RhbFBvc2l0aXZlUm9vbSArIGludGVnZXJMZW5ndGhGcm9tU2Vjb25kTGV2ZWwoa2V5LnNsaWNlKDEpLCBkaXJlY3Rpb24sIGNoYXJTZXQpO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09IGNoYXJTZXQubW9zdE5lZ2F0aXZlICYmIGRpcmVjdGlvbiA9PT0gXCJuZWdhdGl2ZVwiKSB7XG4gICAgY29uc3QgdG90YWxOZWdhdGl2ZVJvb20gPSBkaXN0YW5jZUJldHdlZW4oZmlyc3RDaGFyLCBjaGFyU2V0Lm1vc3RQb3NpdGl2ZSwgY2hhclNldCkgKyAxO1xuICAgIHJldHVybiB0b3RhbE5lZ2F0aXZlUm9vbSArIGludGVnZXJMZW5ndGhGcm9tU2Vjb25kTGV2ZWwoa2V5LnNsaWNlKDEpLCBkaXJlY3Rpb24sIGNoYXJTZXQpO1xuICB9XG4gIGlmIChkaXJlY3Rpb24gPT09IFwicG9zaXRpdmVcIikge1xuICAgIHJldHVybiBkaXN0YW5jZUJldHdlZW4oZmlyc3RDaGFyLCBjaGFyU2V0Lm1vc3ROZWdhdGl2ZSwgY2hhclNldCkgKyAyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaXN0YW5jZUJldHdlZW4oZmlyc3RDaGFyLCBjaGFyU2V0Lm1vc3RQb3NpdGl2ZSwgY2hhclNldCkgKyAyO1xuICB9XG59XG5cbi8vIHNyYy9wYWRUb1NhbWVMZW5ndGgudHNcbmZ1bmN0aW9uIG1ha2VTYW1lTGVuZ3RoKGEsIGIsIHBhZCwgZmlsbENoYXIsIGZvcmNlTGVuZ3RoKSB7XG4gIGNvbnN0IG1heCA9IGZvcmNlTGVuZ3RoID8/IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIGlmIChwYWQgPT09IFwic3RhcnRcIikge1xuICAgIHJldHVybiBbYS5wYWRTdGFydChtYXgsIGZpbGxDaGFyKSwgYi5wYWRTdGFydChtYXgsIGZpbGxDaGFyKV07XG4gIH1cbiAgcmV0dXJuIFthLnBhZEVuZChtYXgsIGZpbGxDaGFyKSwgYi5wYWRFbmQobWF4LCBmaWxsQ2hhcildO1xufVxuXG4vLyBzcmMva2V5QXNOdW1iZXIudHNcbmZ1bmN0aW9uIG1pZFBvaW50KGxvd2VyLCB1cHBlciwgY2hhclNldCkge1xuICBsZXQgW3BhZGRlZExvd2VyLCBwYWRkZWRVcHBlcl0gPSBtYWtlU2FtZUxlbmd0aChcbiAgICBsb3dlcixcbiAgICB1cHBlcixcbiAgICBcImVuZFwiLFxuICAgIGNoYXJTZXQuZmlyc3RcbiAgKTtcbiAgbGV0IGRpc3RhbmNlID0gbGV4aWNhbERpc3RhbmNlKHBhZGRlZExvd2VyLCBwYWRkZWRVcHBlciwgY2hhclNldCk7XG4gIGlmIChkaXN0YW5jZSA9PT0gMSkge1xuICAgIHBhZGRlZExvd2VyID0gcGFkZGVkTG93ZXIucGFkRW5kKHBhZGRlZExvd2VyLmxlbmd0aCArIDEsIGNoYXJTZXQuZmlyc3QpO1xuICAgIGRpc3RhbmNlID0gY2hhclNldC5sZW5ndGg7XG4gIH1cbiAgY29uc3QgbWlkID0gZW5jb2RlVG9DaGFyU2V0KE1hdGguZmxvb3IoZGlzdGFuY2UgLyAyKSwgY2hhclNldCk7XG4gIHJldHVybiBhZGRDaGFyU2V0S2V5cyhwYWRkZWRMb3dlciwgbWlkLCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIGxleGljYWxEaXN0YW5jZShhLCBiLCBjaGFyU2V0KSB7XG4gIGNvbnN0IFtsb3dlciwgdXBwZXJdID0gbWFrZVNhbWVMZW5ndGgoYSwgYiwgXCJlbmRcIiwgY2hhclNldC5maXJzdCkuc29ydCgpO1xuICBjb25zdCBkaXN0YW5jZSA9IHN1YnRyYWN0Q2hhclNldEtleXModXBwZXIsIGxvd2VyLCBjaGFyU2V0KTtcbiAgcmV0dXJuIGRlY29kZUNoYXJTZXRUb051bWJlcihkaXN0YW5jZSwgY2hhclNldCk7XG59XG5mdW5jdGlvbiBhZGRDaGFyU2V0S2V5cyhhLCBiLCBjaGFyU2V0KSB7XG4gIGNvbnN0IGJhc2UgPSBjaGFyU2V0Lmxlbmd0aDtcbiAgY29uc3QgW3BhZGRlZEEsIHBhZGRlZEJdID0gbWFrZVNhbWVMZW5ndGgoYSwgYiwgXCJzdGFydFwiLCBjaGFyU2V0LmZpcnN0KTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjYXJyeSA9IDA7XG4gIGZvciAobGV0IGkgPSBwYWRkZWRBLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgZGlnaXRBID0gY2hhclNldC5ieUNoYXJbcGFkZGVkQVtpXV07XG4gICAgY29uc3QgZGlnaXRCID0gY2hhclNldC5ieUNoYXJbcGFkZGVkQltpXV07XG4gICAgY29uc3Qgc3VtID0gZGlnaXRBICsgZGlnaXRCICsgY2Fycnk7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHN1bSAvIGJhc2UpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1bSAlIGJhc2U7XG4gICAgcmVzdWx0LnVuc2hpZnQoY2hhclNldC5ieUNvZGVbcmVtYWluZGVyXSk7XG4gIH1cbiAgaWYgKGNhcnJ5ID4gMCkge1xuICAgIHJlc3VsdC51bnNoaWZ0KGNoYXJTZXQuYnlDb2RlW2NhcnJ5XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3VidHJhY3RDaGFyU2V0S2V5cyhhLCBiLCBjaGFyU2V0KSB7XG4gIGNvbnN0IGJhc2UgPSBjaGFyU2V0Lmxlbmd0aDtcbiAgY29uc3QgW3BhZGRlZEEsIHBhZGRlZEJdID0gbWFrZVNhbWVMZW5ndGgoYSwgYiwgXCJzdGFydFwiLCBjaGFyU2V0LmZpcnN0KTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBib3Jyb3cgPSAwO1xuICBmb3IgKGxldCBpID0gcGFkZGVkQS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBkaWdpdEEgPSBjaGFyU2V0LmJ5Q2hhcltwYWRkZWRBW2ldXTtcbiAgICBjb25zdCBkaWdpdEIgPSBjaGFyU2V0LmJ5Q2hhcltwYWRkZWRCW2ldXSArIGJvcnJvdztcbiAgICBpZiAoZGlnaXRBIDwgZGlnaXRCKSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgICAgZGlnaXRBICs9IGJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBkaWdpdEEgLSBkaWdpdEI7XG4gICAgcmVzdWx0LnVuc2hpZnQoY2hhclNldC5ieUNvZGVbZGlmZmVyZW5jZV0pO1xuICB9XG4gIGlmIChib3Jyb3cgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJTdWJ0cmFjdGlvbiByZXN1bHQgaXMgbmVnYXRpdmUuIEVuc3VyZSBhIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBiLlwiXG4gICAgKTtcbiAgfVxuICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA+IDEgJiYgcmVzdWx0WzBdID09PSBjaGFyU2V0LmJ5Q29kZVswXSkge1xuICAgIHJlc3VsdC5zaGlmdCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGluY3JlbWVudEtleShrZXksIGNoYXJTZXQpIHtcbiAgcmV0dXJuIGFkZENoYXJTZXRLZXlzKGtleSwgY2hhclNldC5ieUNvZGVbMV0sIGNoYXJTZXQpO1xufVxuZnVuY3Rpb24gZGVjcmVtZW50S2V5KGtleSwgY2hhclNldCkge1xuICByZXR1cm4gc3VidHJhY3RDaGFyU2V0S2V5cyhrZXksIGNoYXJTZXQuYnlDb2RlWzFdLCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRvQ2hhclNldChpbnQsIGNoYXJTZXQpIHtcbiAgaWYgKGludCA9PT0gMCkge1xuICAgIHJldHVybiBjaGFyU2V0LmJ5Q29kZVswXTtcbiAgfVxuICBsZXQgcmVzID0gXCJcIjtcbiAgY29uc3QgbWF4ID0gY2hhclNldC5sZW5ndGg7XG4gIHdoaWxlIChpbnQgPiAwKSB7XG4gICAgcmVzID0gY2hhclNldC5ieUNvZGVbaW50ICUgbWF4XSArIHJlcztcbiAgICBpbnQgPSBNYXRoLmZsb29yKGludCAvIG1heCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRlY29kZUNoYXJTZXRUb051bWJlcihrZXksIGNoYXJTZXQpIHtcbiAgbGV0IHJlcyA9IDA7XG4gIGNvbnN0IGxlbmd0aCA9IGtleS5sZW5ndGg7XG4gIGNvbnN0IG1heCA9IGNoYXJTZXQubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzICs9IGNoYXJTZXQuYnlDaGFyW2tleVtpXV0gKiBNYXRoLnBvdyhtYXgsIGxlbmd0aCAtIGkgLSAxKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvaW50ZWdlci50c1xuZnVuY3Rpb24gc3RhcnRLZXkoY2hhclNldCkge1xuICByZXR1cm4gY2hhclNldC5maXJzdFBvc2l0aXZlICsgY2hhclNldC5ieUNvZGVbMF07XG59XG5mdW5jdGlvbiB2YWxpZEludGVnZXIoaW50ZWdlciwgY2hhclNldCkge1xuICBjb25zdCBsZW5ndGggPSBpbnRlZ2VyTGVuZ3RoKGludGVnZXIsIGNoYXJTZXQpO1xuICByZXR1cm4gbGVuZ3RoID09PSBpbnRlZ2VyLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3JkZXJLZXkob3JkZXJLZXksIGNoYXJTZXQpIHtcbiAgZ2V0SW50ZWdlclBhcnQob3JkZXJLZXksIGNoYXJTZXQpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZWdlclBhcnQob3JkZXJLZXksIGNoYXJTZXQpIHtcbiAgY29uc3QgaGVhZCA9IGludGVnZXJIZWFkKG9yZGVyS2V5LCBjaGFyU2V0KTtcbiAgY29uc3QgaW50ZWdlclBhcnRMZW5ndGggPSBpbnRlZ2VyTGVuZ3RoKGhlYWQsIGNoYXJTZXQpO1xuICBpZiAoaW50ZWdlclBhcnRMZW5ndGggPiBvcmRlcktleS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yZGVyIGtleSBsZW5ndGg6IFwiICsgb3JkZXJLZXkpO1xuICB9XG4gIHJldHVybiBvcmRlcktleS5zbGljZSgwLCBpbnRlZ2VyUGFydExlbmd0aCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludGVnZXIoaW50ZWdlciwgY2hhclNldCkge1xuICBpZiAoIXZhbGlkSW50ZWdlcihpbnRlZ2VyLCBjaGFyU2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50ZWdlciBsZW5ndGg6IFwiICsgaW50ZWdlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGluY3JlbWVudEludGVnZXIoaW50ZWdlciwgY2hhclNldCkge1xuICB2YWxpZGF0ZUludGVnZXIoaW50ZWdlciwgY2hhclNldCk7XG4gIGNvbnN0IFtoZWFkLCBkaWdzXSA9IHNwbGl0SW50ZWdlcihpbnRlZ2VyLCBjaGFyU2V0KTtcbiAgY29uc3QgYW55Tm9uTWF4ZWREaWdpdCA9IGRpZ3Muc3BsaXQoXCJcIikuc29tZSgoZCkgPT4gZCAhPT0gY2hhclNldC5ieUNvZGVbY2hhclNldC5sZW5ndGggLSAxXSk7XG4gIGlmIChhbnlOb25NYXhlZERpZ2l0KSB7XG4gICAgY29uc3QgbmV3RGlnaXRzID0gaW5jcmVtZW50S2V5KGRpZ3MsIGNoYXJTZXQpO1xuICAgIHJldHVybiBoZWFkICsgbmV3RGlnaXRzO1xuICB9XG4gIGNvbnN0IG5leHRIZWFkID0gaW5jcmVtZW50SW50ZWdlckhlYWQoaGVhZCwgY2hhclNldCk7XG4gIHJldHVybiBzdGFydE9uTmV3SGVhZChuZXh0SGVhZCwgXCJsb3dlclwiLCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIGRlY3JlbWVudEludGVnZXIoaW50ZWdlciwgY2hhclNldCkge1xuICB2YWxpZGF0ZUludGVnZXIoaW50ZWdlciwgY2hhclNldCk7XG4gIGNvbnN0IFtoZWFkLCBkaWdzXSA9IHNwbGl0SW50ZWdlcihpbnRlZ2VyLCBjaGFyU2V0KTtcbiAgY29uc3QgYW55Tm9uTGltaXREaWdpdCA9IGRpZ3Muc3BsaXQoXCJcIikuc29tZSgoZCkgPT4gZCAhPT0gY2hhclNldC5ieUNvZGVbMF0pO1xuICBpZiAoYW55Tm9uTGltaXREaWdpdCkge1xuICAgIGNvbnN0IG5ld0RpZ2l0cyA9IGRlY3JlbWVudEtleShkaWdzLCBjaGFyU2V0KTtcbiAgICByZXR1cm4gaGVhZCArIG5ld0RpZ2l0cztcbiAgfVxuICBjb25zdCBuZXh0SGVhZCA9IGRlY3JlbWVudEludGVnZXJIZWFkKGhlYWQsIGNoYXJTZXQpO1xuICByZXR1cm4gc3RhcnRPbk5ld0hlYWQobmV4dEhlYWQsIFwidXBwZXJcIiwgY2hhclNldCk7XG59XG5mdW5jdGlvbiBpbnRlZ2VySGVhZChpbnRlZ2VyLCBjaGFyU2V0KSB7XG4gIGxldCBpID0gMDtcbiAgaWYgKGludGVnZXJbMF0gPT09IGNoYXJTZXQubW9zdFBvc2l0aXZlKSB7XG4gICAgd2hpbGUgKGludGVnZXJbaV0gPT09IGNoYXJTZXQubW9zdFBvc2l0aXZlKSB7XG4gICAgICBpID0gaSArIDE7XG4gICAgfVxuICB9XG4gIGlmIChpbnRlZ2VyWzBdID09PSBjaGFyU2V0Lm1vc3ROZWdhdGl2ZSkge1xuICAgIHdoaWxlIChpbnRlZ2VyW2ldID09PSBjaGFyU2V0Lm1vc3ROZWdhdGl2ZSkge1xuICAgICAgaSA9IGkgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW50ZWdlci5zbGljZSgwLCBpICsgMSk7XG59XG5mdW5jdGlvbiBzcGxpdEludGVnZXIoaW50ZWdlciwgY2hhclNldCkge1xuICBjb25zdCBoZWFkID0gaW50ZWdlckhlYWQoaW50ZWdlciwgY2hhclNldCk7XG4gIGNvbnN0IHRhaWwgPSBpbnRlZ2VyLnNsaWNlKGhlYWQubGVuZ3RoKTtcbiAgcmV0dXJuIFtoZWFkLCB0YWlsXTtcbn1cbmZ1bmN0aW9uIGluY3JlbWVudEludGVnZXJIZWFkKGhlYWQsIGNoYXJTZXQpIHtcbiAgY29uc3QgaW5Qb3NpdGl2ZVJhbmdlID0gaGVhZCA+PSBjaGFyU2V0LmZpcnN0UG9zaXRpdmU7XG4gIGNvbnN0IG5leHRIZWFkID0gaW5jcmVtZW50S2V5KGhlYWQsIGNoYXJTZXQpO1xuICBjb25zdCBoZWFkSXNMaW1pdE1heCA9IGhlYWRbaGVhZC5sZW5ndGggLSAxXSA9PT0gY2hhclNldC5tb3N0UG9zaXRpdmU7XG4gIGNvbnN0IG5leHRIZWFkSXNMaW1pdE1heCA9IG5leHRIZWFkW25leHRIZWFkLmxlbmd0aCAtIDFdID09PSBjaGFyU2V0Lm1vc3RQb3NpdGl2ZTtcbiAgaWYgKGluUG9zaXRpdmVSYW5nZSAmJiBuZXh0SGVhZElzTGltaXRNYXgpIHtcbiAgICByZXR1cm4gbmV4dEhlYWQgKyBjaGFyU2V0Lm1vc3ROZWdhdGl2ZTtcbiAgfVxuICBpZiAoIWluUG9zaXRpdmVSYW5nZSAmJiBoZWFkSXNMaW1pdE1heCkge1xuICAgIHJldHVybiBoZWFkLnNsaWNlKDAsIGhlYWQubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIG5leHRIZWFkO1xufVxuZnVuY3Rpb24gZGVjcmVtZW50SW50ZWdlckhlYWQoaGVhZCwgY2hhclNldCkge1xuICBjb25zdCBpblBvc2l0aXZlUmFuZ2UgPSBoZWFkID49IGNoYXJTZXQuZmlyc3RQb3NpdGl2ZTtcbiAgY29uc3QgaGVhZElzTGltaXRNaW4gPSBoZWFkW2hlYWQubGVuZ3RoIC0gMV0gPT09IGNoYXJTZXQubW9zdE5lZ2F0aXZlO1xuICBpZiAoaW5Qb3NpdGl2ZVJhbmdlICYmIGhlYWRJc0xpbWl0TWluKSB7XG4gICAgY29uc3QgbmV4dExldmVsID0gaGVhZC5zbGljZSgwLCBoZWFkLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBkZWNyZW1lbnRLZXkobmV4dExldmVsLCBjaGFyU2V0KTtcbiAgfVxuICBpZiAoIWluUG9zaXRpdmVSYW5nZSAmJiBoZWFkSXNMaW1pdE1pbikge1xuICAgIHJldHVybiBoZWFkICsgY2hhclNldC5tb3N0UG9zaXRpdmU7XG4gIH1cbiAgcmV0dXJuIGRlY3JlbWVudEtleShoZWFkLCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T25OZXdIZWFkKGhlYWQsIGxpbWl0LCBjaGFyU2V0KSB7XG4gIGNvbnN0IG5ld0xlbmd0aCA9IGludGVnZXJMZW5ndGgoaGVhZCwgY2hhclNldCk7XG4gIGNvbnN0IGZpbGxDaGFyID0gbGltaXQgPT09IFwidXBwZXJcIiA/IGNoYXJTZXQuYnlDb2RlW2NoYXJTZXQubGVuZ3RoIC0gMV0gOiBjaGFyU2V0LmJ5Q29kZVswXTtcbiAgcmV0dXJuIGhlYWQgKyBmaWxsQ2hhci5yZXBlYXQobmV3TGVuZ3RoIC0gaGVhZC5sZW5ndGgpO1xufVxuXG4vLyBzcmMvaml0dGVyaW5nLnRzXG5mdW5jdGlvbiBqaXR0ZXJTdHJpbmcob3JkZXJLZXksIGNoYXJTZXQpIHtcbiAgY29uc3Qgc2hpZnQgPSBlbmNvZGVUb0NoYXJTZXQoXG4gICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhclNldC5qaXR0ZXJSYW5nZSksXG4gICAgY2hhclNldFxuICApO1xuICByZXR1cm4gYWRkQ2hhclNldEtleXMob3JkZXJLZXksIHNoaWZ0LCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIHBhZEFuZEppdHRlclN0cmluZyhvcmRlcktleSwgbnVtYmVyT2ZDaGFycywgY2hhclNldCkge1xuICBjb25zdCBwYWRkZWRLZXkgPSBvcmRlcktleS5wYWRFbmQoXG4gICAgb3JkZXJLZXkubGVuZ3RoICsgbnVtYmVyT2ZDaGFycyxcbiAgICBjaGFyU2V0LmZpcnN0XG4gICk7XG4gIHJldHVybiBqaXR0ZXJTdHJpbmcocGFkZGVkS2V5LCBjaGFyU2V0KTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmdOZWVkZWRGb3JKaXR0ZXIob3JkZXJLZXksIGIsIGNoYXJTZXQpIHtcbiAgY29uc3QgaW50ZWdlciA9IGdldEludGVnZXJQYXJ0KG9yZGVyS2V5LCBjaGFyU2V0KTtcbiAgY29uc3QgbmV4dEludGVnZXIgPSBpbmNyZW1lbnRJbnRlZ2VyKGludGVnZXIsIGNoYXJTZXQpO1xuICBsZXQgbmVlZGVkID0gMDtcbiAgaWYgKGIgIT09IG51bGwpIHtcbiAgICBjb25zdCBkaXN0YW5jZVRvQiA9IGxleGljYWxEaXN0YW5jZShvcmRlcktleSwgYiwgY2hhclNldCk7XG4gICAgaWYgKGRpc3RhbmNlVG9CIDwgY2hhclNldC5qaXR0ZXJSYW5nZSArIDEpIHtcbiAgICAgIG5lZWRlZCA9IE1hdGgubWF4KG5lZWRlZCwgcGFkZGluZ05lZWRlZEZvckRpc3RhbmNlKGRpc3RhbmNlVG9CLCBjaGFyU2V0KSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRpc3RhbmNlVG9OZXh0SW50ZWdlciA9IGxleGljYWxEaXN0YW5jZShvcmRlcktleSwgbmV4dEludGVnZXIsIGNoYXJTZXQpO1xuICBpZiAoZGlzdGFuY2VUb05leHRJbnRlZ2VyIDwgY2hhclNldC5qaXR0ZXJSYW5nZSArIDEpIHtcbiAgICBuZWVkZWQgPSBNYXRoLm1heChcbiAgICAgIG5lZWRlZCxcbiAgICAgIHBhZGRpbmdOZWVkZWRGb3JEaXN0YW5jZShkaXN0YW5jZVRvTmV4dEludGVnZXIsIGNoYXJTZXQpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmVlZGVkO1xufVxuZnVuY3Rpb24gcGFkZGluZ05lZWRlZEZvckRpc3RhbmNlKGRpc3RhbmNlLCBjaGFyU2V0KSB7XG4gIGNvbnN0IGdhcCA9IGNoYXJTZXQuaml0dGVyUmFuZ2UgLSBkaXN0YW5jZTtcbiAgY29uc3QgZmlyc3RCaWdnZXIgPSBPYmplY3QuZW50cmllcyhjaGFyU2V0LnBhZGRpbmdEaWN0KS5maW5kKFxuICAgIChbX2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBnYXA7XG4gICAgfVxuICApO1xuICByZXR1cm4gZmlyc3RCaWdnZXIgPyBwYXJzZUludChmaXJzdEJpZ2dlclswXSkgOiAwO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGVLZXlCZXR3ZWVuLnRzXG5mdW5jdGlvbiBnZW5lcmF0ZUtleUJldHdlZW4obG93ZXIsIHVwcGVyLCBjaGFyU2V0ID0gYmFzZTYyQ2hhclNldCgpKSB7XG4gIGlmIChsb3dlciAhPT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT3JkZXJLZXkobG93ZXIsIGNoYXJTZXQpO1xuICB9XG4gIGlmICh1cHBlciAhPT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT3JkZXJLZXkodXBwZXIsIGNoYXJTZXQpO1xuICB9XG4gIGlmIChsb3dlciA9PT0gbnVsbCAmJiB1cHBlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzdGFydEtleShjaGFyU2V0KTtcbiAgfVxuICBpZiAobG93ZXIgPT09IG51bGwpIHtcbiAgICBjb25zdCBpbnRlZ2VyID0gZ2V0SW50ZWdlclBhcnQodXBwZXIsIGNoYXJTZXQpO1xuICAgIHJldHVybiBkZWNyZW1lbnRJbnRlZ2VyKGludGVnZXIsIGNoYXJTZXQpO1xuICB9XG4gIGlmICh1cHBlciA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGludGVnZXIgPSBnZXRJbnRlZ2VyUGFydChsb3dlciwgY2hhclNldCk7XG4gICAgcmV0dXJuIGluY3JlbWVudEludGVnZXIoaW50ZWdlciwgY2hhclNldCk7XG4gIH1cbiAgaWYgKGxvd2VyID49IHVwcGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGxvd2VyICsgXCIgPj0gXCIgKyB1cHBlcik7XG4gIH1cbiAgcmV0dXJuIG1pZFBvaW50KGxvd2VyLCB1cHBlciwgY2hhclNldCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU5LZXlzQmV0d2VlbihhLCBiLCBuLCBjaGFyU2V0ID0gYmFzZTYyQ2hhclNldCgpKSB7XG4gIHJldHVybiBzcHJlYWRHZW5lcmF0b3JSZXN1bHRzKFxuICAgIGEsXG4gICAgYixcbiAgICBuLFxuICAgIGNoYXJTZXQsXG4gICAgZ2VuZXJhdGVLZXlCZXR3ZWVuLFxuICAgIGdlbmVyYXRlTktleXNCZXR3ZWVuXG4gICk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUppdHRlcmVkS2V5QmV0d2Vlbihsb3dlciwgdXBwZXIsIGNoYXJTZXQgPSBiYXNlNjJDaGFyU2V0KCkpIHtcbiAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXlCZXR3ZWVuKGxvd2VyLCB1cHBlciwgY2hhclNldCk7XG4gIGNvbnN0IHBhZGRpbmdOZWVkZWQgPSBwYWRkaW5nTmVlZGVkRm9ySml0dGVyKGtleSwgdXBwZXIsIGNoYXJTZXQpO1xuICBpZiAocGFkZGluZ05lZWRlZCkge1xuICAgIHJldHVybiBwYWRBbmRKaXR0ZXJTdHJpbmcoa2V5LCBwYWRkaW5nTmVlZGVkLCBjaGFyU2V0KTtcbiAgfVxuICByZXR1cm4gaml0dGVyU3RyaW5nKGtleSwgY2hhclNldCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU5KaXR0ZXJlZEtleXNCZXR3ZWVuKGxvd2VyLCB1cHBlciwgbiwgY2hhclNldCA9IGJhc2U2MkNoYXJTZXQoKSkge1xuICByZXR1cm4gc3ByZWFkR2VuZXJhdG9yUmVzdWx0cyhcbiAgICBsb3dlcixcbiAgICB1cHBlcixcbiAgICBuLFxuICAgIGNoYXJTZXQsXG4gICAgZ2VuZXJhdGVKaXR0ZXJlZEtleUJldHdlZW4sXG4gICAgZ2VuZXJhdGVOSml0dGVyZWRLZXlzQmV0d2VlblxuICApO1xufVxuZnVuY3Rpb24gc3ByZWFkR2VuZXJhdG9yUmVzdWx0cyhsb3dlciwgdXBwZXIsIG4sIGNoYXJTZXQsIGdlbmVyYXRlS2V5LCBnZW5lcmF0ZU5LZXlzKSB7XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChuID09PSAxKSB7XG4gICAgcmV0dXJuIFtnZW5lcmF0ZUtleShsb3dlciwgdXBwZXIsIGNoYXJTZXQpXTtcbiAgfVxuICBpZiAodXBwZXIgPT0gbnVsbCkge1xuICAgIGxldCBuZXdVcHBlciA9IGdlbmVyYXRlS2V5KGxvd2VyLCB1cHBlciwgY2hhclNldCk7XG4gICAgY29uc3QgcmVzdWx0ID0gW25ld1VwcGVyXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIG5ld1VwcGVyID0gZ2VuZXJhdGVLZXkobmV3VXBwZXIsIHVwcGVyLCBjaGFyU2V0KTtcbiAgICAgIHJlc3VsdC5wdXNoKG5ld1VwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAobG93ZXIgPT0gbnVsbCkge1xuICAgIGxldCBuZXdMb3dlciA9IGdlbmVyYXRlS2V5KGxvd2VyLCB1cHBlciwgY2hhclNldCk7XG4gICAgY29uc3QgcmVzdWx0ID0gW25ld0xvd2VyXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIG5ld0xvd2VyID0gZ2VuZXJhdGVLZXkobG93ZXIsIG5ld0xvd2VyLCBjaGFyU2V0KTtcbiAgICAgIHJlc3VsdC5wdXNoKG5ld0xvd2VyKTtcbiAgICB9XG4gICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobiAvIDIpO1xuICBjb25zdCBtaWRPcmRlcktleSA9IGdlbmVyYXRlS2V5KGxvd2VyLCB1cHBlciwgY2hhclNldCk7XG4gIHJldHVybiBbXG4gICAgLi4uZ2VuZXJhdGVOS2V5cyhsb3dlciwgbWlkT3JkZXJLZXksIG1pZCwgY2hhclNldCksXG4gICAgbWlkT3JkZXJLZXksXG4gICAgLi4uZ2VuZXJhdGVOS2V5cyhtaWRPcmRlcktleSwgdXBwZXIsIG4gLSBtaWQgLSAxLCBjaGFyU2V0KVxuICBdO1xufVxuXG4vLyBzcmMvSW5kZXhHZW5lcmF0b3IudHNcbnZhciBJbmRleEdlbmVyYXRvciA9IGNsYXNzIHtcbiAgY2hhclNldDtcbiAgdXNlSml0dGVyO1xuICBsaXN0O1xuICB1c2VHcm91cHM7XG4gIGdyb3VwSWRMZW5ndGg7XG4gIGNvbnN0cnVjdG9yKGxpc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuY2hhclNldCA9IG9wdGlvbnMuY2hhclNldCA/PyBiYXNlNjJDaGFyU2V0KCk7XG4gICAgdGhpcy51c2VKaXR0ZXIgPSBvcHRpb25zLnVzZUppdHRlciA/PyB0cnVlO1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy51c2VHcm91cHMgPSAhIW9wdGlvbnMuZ3JvdXBJZExlbmd0aCAmJiBvcHRpb25zLmdyb3VwSWRMZW5ndGggPiAwO1xuICAgIHRoaXMuZ3JvdXBJZExlbmd0aCA9IG9wdGlvbnMuZ3JvdXBJZExlbmd0aCA/PyAwO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBsaXN0IHRoYXQgdGhlIGdlbmVyYXRvciB1c2VzIHRvIGdlbmVyYXRlIGtleXMuXG4gICAqIFRoZSBnZW5lcmF0b3Igd2lsbCBub3QgbXV0YXRlIHRoZSBpbnRlcm5hbCBsaXN0IHdoZW4gZ2VuZXJhdGluZyBrZXlzLlxuICAgKi9cbiAgdXBkYXRlTGlzdChsaXN0KSB7XG4gICAgdGhpcy5saXN0ID0gWy4uLmxpc3RdLnNvcnQoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYW55IG51bWJlciBvZiBrZXlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGlzdCAoYmVmb3JlIHRoZSBmaXJzdCBrZXkpLlxuICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3VwcGx5IGEgZ3JvdXBJZCB0byBnZW5lcmF0ZSBrZXlzIGF0IHRoZSBzdGFydCBvZiBhIHNwZWNpZmljIGdyb3VwLlxuICAgKi9cbiAgbktleXNTdGFydChuLCBncm91cElkKSB7XG4gICAgdGhpcy52YWxpZGF0ZUdyb3VwSWQoZ3JvdXBJZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVOS2V5c0JldHdlZW4oXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5maXJzdE9mR3JvdXAoZ3JvdXBJZCksXG4gICAgICBuLFxuICAgICAgZ3JvdXBJZFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2luZ2xlIGtleSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpc3QgKGJlZm9yZSB0aGUgZmlyc3Qga2V5KS5cbiAgICogT3B0aW9uYWxseSB5b3UgY2FuIHN1cHBseSBhIGdyb3VwSWQgdG8gZ2VuZXJhdGUgYSBrZXkgYXQgdGhlIHN0YXJ0IG9mIGEgc3BlY2lmaWMgZ3JvdXAuXG4gICAqL1xuICBrZXlTdGFydChncm91cElkKSB7XG4gICAgdGhpcy52YWxpZGF0ZUdyb3VwSWQoZ3JvdXBJZCk7XG4gICAgcmV0dXJuIHRoaXMubktleXNTdGFydCgxLCBncm91cElkKVswXTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYW55IG51bWJlciBvZiBrZXlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgKGFmdGVyIHRoZSBsYXN0IGtleSkuXG4gICAqIE9wdGlvbmFsbHkgeW91IGNhbiBzdXBwbHkgYSBncm91cElkIHRvIGdlbmVyYXRlIGtleXMgYXQgdGhlIGVuZCBvZiBhIHNwZWNpZmljIGdyb3VwLlxuICAgKi9cbiAgbktleXNFbmQobiwgZ3JvdXBJZCkge1xuICAgIHRoaXMudmFsaWRhdGVHcm91cElkKGdyb3VwSWQpO1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTktleXNCZXR3ZWVuKFxuICAgICAgdGhpcy5sYXN0T2ZHcm91cChncm91cElkKSxcbiAgICAgIG51bGwsXG4gICAgICBuLFxuICAgICAgZ3JvdXBJZFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2luZ2xlIGtleSBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IChhZnRlciB0aGUgbGFzdCBrZXkpLlxuICAgKiBPcHRpb25hbGx5IHlvdSBjYW4gc3VwcGx5IGEgZ3JvdXBJZCB0byBnZW5lcmF0ZSBhIGtleSBhdCB0aGUgZW5kIG9mIGEgc3BlY2lmaWMgZ3JvdXAuXG4gICAqL1xuICBrZXlFbmQoZ3JvdXBJZCkge1xuICAgIHRoaXMudmFsaWRhdGVHcm91cElkKGdyb3VwSWQpO1xuICAgIHJldHVybiB0aGlzLm5LZXlzRW5kKDEsIGdyb3VwSWQpWzBdO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbnkgbnVtYmVyIG9mIGtleXMgYmVoaW5kIGEgc3BlY2lmaWMga2V5IGFuZCBpbiBmcm9udCBvZiB0aGUgbmV4dCBrZXkuXG4gICAqIEdyb3VwSWQgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBvcmRlcktleSBpZiB3b3JraW5nIHdpdGggZ3JvdXBzXG4gICAqL1xuICBuS2V5c0FmdGVyKG9yZGVyS2V5LCBuKSB7XG4gICAgY29uc3Qga2V5QWZ0ZXIgPSB0aGlzLmdldEtleUFmdGVyKG9yZGVyS2V5KTtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU5LZXlzQmV0d2VlbihcbiAgICAgIG9yZGVyS2V5LFxuICAgICAga2V5QWZ0ZXIsXG4gICAgICBuLFxuICAgICAgdGhpcy5ncm91cElkKG9yZGVyS2V5KVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2luZ2xlIGtleSBiZWhpbmQgYSBzcGVjaWZpYyBrZXkgYW5kIGluIGZyb250IG9mIHRoZSBuZXh0IGtleS5cbiAgICogR3JvdXBJZCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlIG9yZGVyS2V5IGlmIHdvcmtpbmcgd2l0aCBncm91cHNcbiAgICovXG4gIGtleUFmdGVyKG9yZGVyS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubktleXNBZnRlcihvcmRlcktleSwgMSlbMF07XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFueSBudW1iZXIgb2Yga2V5cyBpbiBmcm9udCBvZiBhIHNwZWNpZmljIGtleSBhbmQgYmVoaW5kIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqIEdyb3VwSWQgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBvcmRlcktleSBpZiB3b3JraW5nIHdpdGggZ3JvdXBzXG4gICAqL1xuICBuS2V5c0JlZm9yZShvcmRlcktleSwgbikge1xuICAgIGNvbnN0IGtleUJlZm9yZSA9IHRoaXMuZ2V0S2V5QmVmb3JlKG9yZGVyS2V5KTtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU5LZXlzQmV0d2VlbihcbiAgICAgIGtleUJlZm9yZSxcbiAgICAgIG9yZGVyS2V5LFxuICAgICAgbixcbiAgICAgIHRoaXMuZ3JvdXBJZChvcmRlcktleSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNpbmdsZSBrZXkgaW4gZnJvbnQgb2YgYSBzcGVjaWZpYyBrZXkgYW5kIGJlaGluZCB0aGUgcHJldmlvdXMga2V5LlxuICAgKiBHcm91cElkIHdpbGwgYmUgaW5mZXJyZWQgZnJvbSB0aGUgb3JkZXJLZXkgaWYgd29ya2luZyB3aXRoIGdyb3Vwc1xuICAgKi9cbiAga2V5QmVmb3JlKG9yZGVyS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubktleXNCZWZvcmUob3JkZXJLZXksIDEpWzBdO1xuICB9XG4gIC8qKlxuICAgKiBwcml2YXRlIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBjb3JyZWN0IGdlbmVyYXRlIGZ1bmN0aW9uXG4gICAqL1xuICBnZW5lcmF0ZU5LZXlzQmV0d2Vlbihsb3dlcktleSwgdXBwZXJLZXksIG4sIGdyb3VwSWQpIHtcbiAgICBjb25zdCBsb3dlciA9IHRoaXMuZ3JvdXBMZXNzS2V5KGxvd2VyS2V5KTtcbiAgICBjb25zdCB1cHBlciA9IHRoaXMuZ3JvdXBMZXNzS2V5KHVwcGVyS2V5KTtcbiAgICBjb25zdCBrZXlzID0gdGhpcy51c2VKaXR0ZXIgPyBnZW5lcmF0ZU5KaXR0ZXJlZEtleXNCZXR3ZWVuKGxvd2VyLCB1cHBlciwgbiwgdGhpcy5jaGFyU2V0KSA6IGdlbmVyYXRlTktleXNCZXR3ZWVuKGxvd2VyLCB1cHBlciwgbiwgdGhpcy5jaGFyU2V0KTtcbiAgICByZXR1cm4gIWdyb3VwSWQgPyBrZXlzIDoga2V5cy5tYXAoKGtleSkgPT4gZ3JvdXBJZCArIGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUga2V5IGJlZm9yZSB0aGUgc3VwcGxpZWQgb3JkZXJLZXksIGlmIGl0IGV4aXN0cyBhbmQgaXMgaW4gdGhlIHNhbWUgZ3JvdXBcbiAgICovXG4gIGdldEtleUJlZm9yZShvcmRlcktleSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0LmluZGV4T2Yob3JkZXJLZXkpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgb3JkZXJLZXkgaXMgbm90IGluIHRoZSBsaXN0YCk7XG4gICAgfVxuICAgIGNvbnN0IGJlZm9yZSA9IHRoaXMubGlzdFtpbmRleCAtIDFdO1xuICAgIHJldHVybiAhIWJlZm9yZSAmJiB0aGlzLmlzU2FtZUdyb3VwKG9yZGVyS2V5LCBiZWZvcmUpID8gYmVmb3JlIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBrZXkgYWZ0ZXIgdGhlIHN1cHBsaWVkIG9yZGVyS2V5LCBpZiBpdCBleGlzdHMgYW5kIGlzIGluIHRoZSBzYW1lIGdyb3VwXG4gICAqL1xuICBnZXRLZXlBZnRlcihvcmRlcktleSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0LmluZGV4T2Yob3JkZXJLZXkpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgb3JkZXJLZXkgaXMgbm90IGluIHRoZSBsaXN0YCk7XG4gICAgfVxuICAgIGNvbnN0IGFmdGVyID0gdGhpcy5saXN0W2luZGV4ICsgMV07XG4gICAgcmV0dXJuICEhYWZ0ZXIgJiYgdGhpcy5pc1NhbWVHcm91cChvcmRlcktleSwgYWZ0ZXIpID8gYWZ0ZXIgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGZpcnN0IGtleSBvZiB0aGUgZ3JvdXAgKG9yIHRoZSBmaXJzdCBrZXkgb2YgdGhlIGxpc3QgaWYgbm90IHVzaW5nIGdyb3VwcylcbiAgICovXG4gIGZpcnN0T2ZHcm91cChncm91cElkKSB7XG4gICAgaWYgKCF0aGlzLnVzZUdyb3VwcylcbiAgICAgIHJldHVybiB0aGlzLmxpc3RbMF0gPz8gbnVsbDtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMubGlzdC5maW5kKChrZXkpID0+IHRoaXMuaXNQYXJ0T2ZHcm91cChrZXksIGdyb3VwSWQpKTtcbiAgICByZXR1cm4gZmlyc3QgPz8gbnVsbDtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBsYXN0IGtleSBvZiB0aGUgZ3JvdXAgKG9yIHRoZSBsYXN0IGtleSBvZiB0aGUgbGlzdCBpZiBub3QgdXNpbmcgZ3JvdXBzKVxuICAgKi9cbiAgbGFzdE9mR3JvdXAoZ3JvdXBJZCkge1xuICAgIGlmICghdGhpcy51c2VHcm91cHMpXG4gICAgICByZXR1cm4gdGhpcy5saXN0W3RoaXMubGlzdC5sZW5ndGggLSAxXSA/PyBudWxsO1xuICAgIGNvbnN0IGFsbEdyb3VwSXRlbXMgPSB0aGlzLmxpc3QuZmlsdGVyKFxuICAgICAgKGtleSkgPT4gdGhpcy5pc1BhcnRPZkdyb3VwKGtleSwgZ3JvdXBJZClcbiAgICApO1xuICAgIGNvbnN0IGxhc3QgPSBhbGxHcm91cEl0ZW1zW2FsbEdyb3VwSXRlbXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3QgPz8gbnVsbDtcbiAgfVxuICAvKipcbiAgICogdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdyb3VwSWQgaXMgaW52YWxpZCBvciBzdXBwbGllZCB3aGVuIG5vdCB1c2luZyBncm91cHNcbiAgICovXG4gIHZhbGlkYXRlR3JvdXBJZChncm91cElkKSB7XG4gICAgaWYgKCF0aGlzLnVzZUdyb3Vwcykge1xuICAgICAgaWYgKGdyb3VwSWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiZ3JvdXBJZCBzaG91bGQgbm90IHVzZWQgd2hlbiBub3QgdXNpbmcgZ3JvdXBzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdyb3VwSWQgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBncm91cHNcIik7XG4gICAgfVxuICAgIGlmIChncm91cElkLmxlbmd0aCAhPT0gdGhpcy5ncm91cElkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGdyb3VwSWQgbXVzdCBiZSB0aGUgbGVuZ2h0IHN1cHBsaWVkIGluIHRoZSBvcHRpb25zYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGdyb3VwSWQgZnJvbSB0aGUgb3JkZXJLZXlcbiAgICovXG4gIGdyb3VwSWQob3JkZXJLZXkpIHtcbiAgICBpZiAoIXRoaXMudXNlR3JvdXBzKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5zcGxpdEludG9Hcm91cElkQW5kT3JkZXJLZXkob3JkZXJLZXkpWzBdO1xuICB9XG4gIC8qKlxuICAgKiByZW1vdmUgdGhlIGdyb3VwSWQgZnJvbSB0aGUgb3JkZXJLZXlcbiAgICovXG4gIGdyb3VwTGVzc0tleShvcmRlcktleSkge1xuICAgIGlmICghdGhpcy51c2VHcm91cHMpXG4gICAgICByZXR1cm4gb3JkZXJLZXk7XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRJbnRvR3JvdXBJZEFuZE9yZGVyS2V5KG9yZGVyS2V5KVsxXTtcbiAgfVxuICAvKipcbiAgICogc3BsaXQgdGhlIG9yZGVyS2V5IGludG8gZ3JvdXBJZCBhbmQga2V5XG4gICAqIGlmIG5vdCB1c2luZyBncm91cHMsIG9yZGVyS2V5IHdpbGwgYmUgdGhlIHNhbWUgYXMga2V5XG4gICAqL1xuICBzcGxpdEludG9Hcm91cElkQW5kT3JkZXJLZXkob3JkZXJLZXkpIHtcbiAgICBpZiAoIXRoaXMudXNlR3JvdXBzIHx8ICFvcmRlcktleSkge1xuICAgICAgcmV0dXJuIFt2b2lkIDAsIG9yZGVyS2V5XTtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBJZCA9IG9yZGVyS2V5LnN1YnN0cmluZygwLCB0aGlzLmdyb3VwSWRMZW5ndGgpO1xuICAgIGNvbnN0IGtleSA9IG9yZGVyS2V5LnN1YnN0cmluZyh0aGlzLmdyb3VwSWRMZW5ndGgpO1xuICAgIHJldHVybiBbZ3JvdXBJZCwga2V5XTtcbiAgfVxuICAvKipcbiAgICogY2hlY2sgaWYgdHdvIGtleXMgYXJlIGluIHRoZSBzYW1lIGdyb3VwXG4gICAqIGlmIG5vdCB1c2luZyBncm91cHMsIGtleXMgd2lsbCBhbHdheXMgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAgICovXG4gIGlzU2FtZUdyb3VwKGEsIGIpIHtcbiAgICBpZiAoIXRoaXMudXNlR3JvdXBzKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgW2FHcm91cElkXSA9IHRoaXMuc3BsaXRJbnRvR3JvdXBJZEFuZE9yZGVyS2V5KGEpO1xuICAgIGNvbnN0IFtiR3JvdXBJZF0gPSB0aGlzLnNwbGl0SW50b0dyb3VwSWRBbmRPcmRlcktleShiKTtcbiAgICByZXR1cm4gYUdyb3VwSWQgPT09IGJHcm91cElkO1xuICB9XG4gIC8qKlxuICAgKiBjaGVjayBpZiB0aGUga2V5IGlzIHBhcnQgb2YgdGhlIGdyb3VwXG4gICAqIGlmIG5vdCB1c2luZyBncm91cHMsIGtleSB3aWxsIGFsd2F5cyBiZSBwYXJ0IG9mIHRoZSBncm91cFxuICAgKi9cbiAgaXNQYXJ0T2ZHcm91cChvcmRlcktleSwgZ3JvdXBJZCkge1xuICAgIGlmICghdGhpcy51c2VHcm91cHMpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBba2V5R3JvdXBJZF0gPSB0aGlzLnNwbGl0SW50b0dyb3VwSWRBbmRPcmRlcktleShvcmRlcktleSk7XG4gICAgcmV0dXJuIGtleUdyb3VwSWQgPT09IGdyb3VwSWQ7XG4gIH1cbn07XG5leHBvcnQge1xuICBJbmRleEdlbmVyYXRvcixcbiAgYmFzZTYyQ2hhclNldCxcbiAgZ2VuZXJhdGVKaXR0ZXJlZEtleUJldHdlZW4sXG4gIGdlbmVyYXRlS2V5QmV0d2VlbixcbiAgZ2VuZXJhdGVOSml0dGVyZWRLZXlzQmV0d2VlbixcbiAgZ2VuZXJhdGVOS2V5c0JldHdlZW4sXG4gIGluZGV4Q2hhcmFjdGVyU2V0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fractional-indexing-jittered/lib/index.js\n");

/***/ })

};
;