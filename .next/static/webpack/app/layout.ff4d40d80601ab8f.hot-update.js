"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzU3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBTztBQUNyQyxXQUFXLG1CQUFPLENBQUMsOEdBQThCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz9kOTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0nKTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuLy8gZm9yIENvbW1vbkpTIGludGVyb3AuXG5cbnZhciB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGluc3Q7XG5cbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG5cbiAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcbiAgICAvLyBtZW1vaXplZCBpbnN0YW5jZSBvZiBhIGdldFNuYXBzaG90IGZ1bmN0aW9uLiBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhXG4gICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG4gICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cbiAgICB2YXIgaGFzTWVtbyA9IGZhbHNlO1xuICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgIHZhciBtZW1vaXplZFNlbGVjdG9yID0gZnVuY3Rpb24gKG5leHRTbmFwc2hvdCkge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cbiAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgaWYgcG9zc2libGUsIHRvIHByZXNlcnZlIGRvd25zdHJlYW0gbWVtb2l6YXRpb25zLlxuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcbiAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuICAgICAgLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG4gICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9IC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cblxuXG4gICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG4gICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuICAgICAgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cbiAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG4gICAgdmFyIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuXG4gICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuICAgICAgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sXG4gICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/MDYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHdPQUE0RjtBQUM5RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzP2I2OGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/layout.jsx":
/*!************************!*\
  !*** ./app/layout.jsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ RootLayout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.css */ \"(app-pages-browser)/./app/globals.css\");\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-toastify/dist/ReactToastify.css */ \"(app-pages-browser)/./node_modules/react-toastify/dist/ReactToastify.css\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store */ \"(app-pages-browser)/./store/index.js\");\n/* harmony import */ var _Providers_NextAuthProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Providers/NextAuthProvider */ \"(app-pages-browser)/./Providers/NextAuthProvider.jsx\");\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ \"(app-pages-browser)/./node_modules/bootstrap/dist/css/bootstrap.min.css\");\n/* harmony import */ var bootstrap_dist_js_bootstrap_bundle_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bootstrap/dist/js/bootstrap.bundle.min.js */ \"(app-pages-browser)/./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js\");\n/* harmony import */ var bootstrap_dist_js_bootstrap_bundle_min_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bootstrap_dist_js_bootstrap_bundle_min_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _components_PreLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/PreLoader */ \"(app-pages-browser)/./components/PreLoader.jsx\");\n/* harmony import */ var _components_Loader_Loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/Loader/Loader */ \"(app-pages-browser)/./components/Loader/Loader.jsx\");\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/script */ \"(app-pages-browser)/./node_modules/next/dist/api/script.js\");\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-toastify */ \"(app-pages-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @liveblocks/react */ \"(app-pages-browser)/./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs\");\n/* harmony import */ var _liveblocks_client__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @liveblocks/client */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\nconst client = (0,_liveblocks_client__WEBPACK_IMPORTED_MODULE_11__.createClient)({\n    authEndpoint: \"/api/liveblocks-auth\"\n});\nfunction RootLayout(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"head\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.png\",\n                        sizes: \"any\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                        lineNumber: 25,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"stylesheet\",\n                        href: \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                        lineNumber: 26,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"stylesheet\",\n                        href: \"/assets/styles/style.css\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                        lineNumber: 30,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_12__.LiveblocksProvider, {\n                    client: client,\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Providers_NextAuthProvider__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                            children: [\n                                children,\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_toastify__WEBPACK_IMPORTED_MODULE_10__.ToastContainer, {}, void 0, false, {\n                                    fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                                    lineNumber: 37,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                            lineNumber: 35,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                        lineNumber: 34,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                    lineNumber: 33,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n                lineNumber: 32,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\laragon\\\\www\\\\pluto_learning_frontend\\\\app\\\\layout.jsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, this);\n}\n_c = RootLayout;\nvar _c;\n$RefreshReg$(_c, \"RootLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9sYXlvdXQuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFdUI7QUFDd0I7QUFDUjtBQUNWO0FBQ2dDO0FBQ2Y7QUFDSztBQUNIO0FBQ0M7QUFDaEI7QUFDZTtBQUNPO0FBQ0w7QUFFbEQsTUFBTVMsU0FBU0QsaUVBQVlBLENBQUM7SUFDMUJFLGNBQWM7QUFDaEI7QUFFZSxTQUFTQyxXQUFXLEtBQVk7UUFBWixFQUFFQyxRQUFRLEVBQUUsR0FBWjtJQUNqQyxxQkFDRSw4REFBQ0M7UUFBS0MsTUFBSzs7MEJBQ1QsOERBQUNDOztrQ0FDQyw4REFBQ0M7d0JBQUtDLEtBQUk7d0JBQU9DLE1BQUs7d0JBQWVDLE9BQU07Ozs7OztrQ0FDM0MsOERBQUNIO3dCQUNDQyxLQUFJO3dCQUNKQyxNQUFLOzs7Ozs7a0NBRVAsOERBQUNGO3dCQUFLQyxLQUFJO3dCQUFhQyxNQUFLOzs7Ozs7Ozs7Ozs7MEJBRTlCLDhEQUFDRTswQkFDQyw0RUFBQ2Isa0VBQWtCQTtvQkFBQ0UsUUFBUUE7OEJBQzFCLDRFQUFDUCxtRUFBZ0JBO2tDQUNmLDRFQUFDbUI7O2dDQUNFVDs4Q0FDRCw4REFBQ04sMkRBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU83QjtLQXZCd0JLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9sYXlvdXQuanN4PzBjODEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcbmltcG9ydCBsb2NhbEZvbnQgZnJvbSBcIm5leHQvZm9udC9sb2NhbFwiO1xyXG5pbXBvcnQgXCIuL2dsb2JhbHMuY3NzXCI7XHJcbmltcG9ydCAncmVhY3QtdG9hc3RpZnkvZGlzdC9SZWFjdFRvYXN0aWZ5LmNzcyc7XHJcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XHJcbmltcG9ydCBzdG9yZSBmcm9tIFwiLi4vc3RvcmVcIjtcclxuaW1wb3J0IE5leHRBdXRoUHJvdmlkZXIgZnJvbSBcIi4uL1Byb3ZpZGVycy9OZXh0QXV0aFByb3ZpZGVyXCI7XHJcbmltcG9ydCAnYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzJztcclxuaW1wb3J0ICdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuYnVuZGxlLm1pbi5qcyc7XHJcbmltcG9ydCBQcmVMb2FkZXIgZnJvbSBcIi4uL2NvbXBvbmVudHMvUHJlTG9hZGVyXCI7XHJcbmltcG9ydCBMb2FkZXIgZnJvbSBcIi4uL2NvbXBvbmVudHMvTG9hZGVyL0xvYWRlclwiO1xyXG5pbXBvcnQgU2NyaXB0IGZyb20gXCJuZXh0L3NjcmlwdFwiO1xyXG5pbXBvcnQgeyBUb2FzdENvbnRhaW5lciB9IGZyb20gXCJyZWFjdC10b2FzdGlmeVwiO1xyXG5pbXBvcnQgeyBMaXZlYmxvY2tzUHJvdmlkZXIgfSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcclxuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NsaWVudFwiO1xyXG5cclxuY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHtcclxuICBhdXRoRW5kcG9pbnQ6IFwiL2FwaS9saXZlYmxvY2tzLWF1dGhcIixcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSb290TGF5b3V0KHsgY2hpbGRyZW4gfSkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8aHRtbCBsYW5nPVwiZW5cIj5cclxuICAgICAgPGhlYWQ+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvZmF2aWNvbi5wbmdcIiBzaXplcz1cImFueVwiIC8+XHJcbiAgICAgICAgPGxpbmtcclxuICAgICAgICAgIHJlbD1cInN0eWxlc2hlZXRcIlxyXG4gICAgICAgICAgaHJlZj1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2ZvbnQtYXdlc29tZS82LjIuMC9jc3MvYWxsLm1pbi5jc3NcIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCIvYXNzZXRzL3N0eWxlcy9zdHlsZS5jc3NcIiAvPlxyXG4gICAgICA8L2hlYWQ+XHJcbiAgICAgIDxib2R5PlxyXG4gICAgICAgIDxMaXZlYmxvY2tzUHJvdmlkZXIgY2xpZW50PXtjbGllbnR9PlxyXG4gICAgICAgICAgPE5leHRBdXRoUHJvdmlkZXI+XHJcbiAgICAgICAgICAgIDxtYWluPlxyXG4gICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgICA8VG9hc3RDb250YWluZXIgLz5cclxuICAgICAgICAgICAgPC9tYWluPlxyXG4gICAgICAgICAgPC9OZXh0QXV0aFByb3ZpZGVyPlxyXG4gICAgICAgIDwvTGl2ZWJsb2Nrc1Byb3ZpZGVyPlxyXG4gICAgICA8L2JvZHk+XHJcbiAgICA8L2h0bWw+XHJcbiAgKTtcclxufSJdLCJuYW1lcyI6WyJQcm92aWRlciIsInN0b3JlIiwiTmV4dEF1dGhQcm92aWRlciIsIlByZUxvYWRlciIsIkxvYWRlciIsIlNjcmlwdCIsIlRvYXN0Q29udGFpbmVyIiwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIiwiY3JlYXRlQ2xpZW50IiwiY2xpZW50IiwiYXV0aEVuZHBvaW50IiwiUm9vdExheW91dCIsImNoaWxkcmVuIiwiaHRtbCIsImxhbmciLCJoZWFkIiwibGluayIsInJlbCIsImhyZWYiLCJzaXplcyIsImJvZHkiLCJtYWluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/layout.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: function() { return /* binding */ ClientContext; },\n/* harmony export */   CreateThreadError: function() { return /* binding */ CreateThreadError; },\n/* harmony export */   LiveblocksProvider: function() { return /* binding */ LiveblocksProvider; },\n/* harmony export */   RoomContext: function() { return /* binding */ RoomContext; },\n/* harmony export */   _RoomProvider: function() { return /* binding */ _RoomProvider; },\n/* harmony export */   _useAddReaction: function() { return /* binding */ _useAddReaction; },\n/* harmony export */   _useBroadcastEvent: function() { return /* binding */ _useBroadcastEvent; },\n/* harmony export */   _useCreateThread: function() { return /* binding */ _useCreateThread; },\n/* harmony export */   _useDeleteThread: function() { return /* binding */ _useDeleteThread; },\n/* harmony export */   _useEditThreadMetadata: function() { return /* binding */ _useEditThreadMetadata; },\n/* harmony export */   _useEventListener: function() { return /* binding */ _useEventListener; },\n/* harmony export */   _useHistoryVersions: function() { return /* binding */ _useHistoryVersions; },\n/* harmony export */   _useHistoryVersionsSuspense: function() { return /* binding */ _useHistoryVersionsSuspense; },\n/* harmony export */   _useInboxNotificationThread: function() { return /* binding */ _useInboxNotificationThread; },\n/* harmony export */   _useIsInsideRoom: function() { return /* binding */ _useIsInsideRoom; },\n/* harmony export */   _useMutation: function() { return /* binding */ _useMutation; },\n/* harmony export */   _useMyPresence: function() { return /* binding */ _useMyPresence; },\n/* harmony export */   _useOther: function() { return /* binding */ _useOther; },\n/* harmony export */   _useOtherSuspense: function() { return /* binding */ _useOtherSuspense; },\n/* harmony export */   _useOthers: function() { return /* binding */ _useOthers; },\n/* harmony export */   _useOthersListener: function() { return /* binding */ _useOthersListener; },\n/* harmony export */   _useOthersMapped: function() { return /* binding */ _useOthersMapped; },\n/* harmony export */   _useOthersMappedSuspense: function() { return /* binding */ _useOthersMappedSuspense; },\n/* harmony export */   _useOthersSuspense: function() { return /* binding */ _useOthersSuspense; },\n/* harmony export */   _useRoom: function() { return /* binding */ _useRoom; },\n/* harmony export */   _useRoomNotificationSettings: function() { return /* binding */ _useRoomNotificationSettings; },\n/* harmony export */   _useRoomNotificationSettingsSuspense: function() { return /* binding */ _useRoomNotificationSettingsSuspense; },\n/* harmony export */   _useSelf: function() { return /* binding */ _useSelf; },\n/* harmony export */   _useSelfSuspense: function() { return /* binding */ _useSelfSuspense; },\n/* harmony export */   _useStorage: function() { return /* binding */ _useStorage; },\n/* harmony export */   _useStorageRoot: function() { return /* binding */ _useStorageRoot; },\n/* harmony export */   _useStorageSuspense: function() { return /* binding */ _useStorageSuspense; },\n/* harmony export */   _useThreads: function() { return /* binding */ _useThreads; },\n/* harmony export */   _useThreadsSuspense: function() { return /* binding */ _useThreadsSuspense; },\n/* harmony export */   _useUpdateMyPresence: function() { return /* binding */ _useUpdateMyPresence; },\n/* harmony export */   _useUser: function() { return /* binding */ _useUser; },\n/* harmony export */   _useUserSuspense: function() { return /* binding */ _useUserSuspense; },\n/* harmony export */   _useUserThreadsSuspense_experimental: function() { return /* binding */ _useUserThreadsSuspense_experimental; },\n/* harmony export */   _useUserThreads_experimental: function() { return /* binding */ _useUserThreads_experimental; },\n/* harmony export */   createLiveblocksContext: function() { return /* binding */ createLiveblocksContext; },\n/* harmony export */   createRoomContext: function() { return /* binding */ createRoomContext; },\n/* harmony export */   getUmbrellaStoreForClient: function() { return /* binding */ getUmbrellaStoreForClient; },\n/* harmony export */   useAttachmentUrl: function() { return /* binding */ useAttachmentUrl; },\n/* harmony export */   useAttachmentUrlSuspense: function() { return /* binding */ useAttachmentUrlSuspense; },\n/* harmony export */   useBatch: function() { return /* binding */ useBatch; },\n/* harmony export */   useCanRedo: function() { return /* binding */ useCanRedo; },\n/* harmony export */   useCanUndo: function() { return /* binding */ useCanUndo; },\n/* harmony export */   useClient: function() { return /* binding */ useClient; },\n/* harmony export */   useCommentsErrorListener: function() { return /* binding */ useCommentsErrorListener; },\n/* harmony export */   useCreateComment: function() { return /* binding */ useCreateComment; },\n/* harmony export */   useDeleteAllInboxNotifications: function() { return /* binding */ useDeleteAllInboxNotifications; },\n/* harmony export */   useDeleteComment: function() { return /* binding */ useDeleteComment; },\n/* harmony export */   useDeleteInboxNotification: function() { return /* binding */ useDeleteInboxNotification; },\n/* harmony export */   useEditComment: function() { return /* binding */ useEditComment; },\n/* harmony export */   useErrorListener: function() { return /* binding */ useErrorListener; },\n/* harmony export */   useHistory: function() { return /* binding */ useHistory; },\n/* harmony export */   useHistoryVersionData: function() { return /* binding */ useHistoryVersionData; },\n/* harmony export */   useInboxNotifications: function() { return /* binding */ useInboxNotifications; },\n/* harmony export */   useInboxNotificationsSuspense: function() { return /* binding */ useInboxNotificationsSuspense; },\n/* harmony export */   useLostConnectionListener: function() { return /* binding */ useLostConnectionListener; },\n/* harmony export */   useMarkAllInboxNotificationsAsRead: function() { return /* binding */ useMarkAllInboxNotificationsAsRead; },\n/* harmony export */   useMarkInboxNotificationAsRead: function() { return /* binding */ useMarkInboxNotificationAsRead; },\n/* harmony export */   useMarkThreadAsRead: function() { return /* binding */ useMarkThreadAsRead; },\n/* harmony export */   useMarkThreadAsResolved: function() { return /* binding */ useMarkThreadAsResolved; },\n/* harmony export */   useMarkThreadAsUnresolved: function() { return /* binding */ useMarkThreadAsUnresolved; },\n/* harmony export */   useOthersConnectionIds: function() { return /* binding */ useOthersConnectionIds; },\n/* harmony export */   useOthersConnectionIdsSuspense: function() { return /* binding */ useOthersConnectionIdsSuspense; },\n/* harmony export */   useRedo: function() { return /* binding */ useRedo; },\n/* harmony export */   useRemoveReaction: function() { return /* binding */ useRemoveReaction; },\n/* harmony export */   useRoomInfo: function() { return /* binding */ useRoomInfo; },\n/* harmony export */   useRoomInfoSuspense: function() { return /* binding */ useRoomInfoSuspense; },\n/* harmony export */   useStatus: function() { return /* binding */ useStatus; },\n/* harmony export */   useStorageStatus: function() { return /* binding */ useStorageStatus; },\n/* harmony export */   useStorageStatusSuspense: function() { return /* binding */ useStorageStatusSuspense; },\n/* harmony export */   useThreadSubscription: function() { return /* binding */ useThreadSubscription; },\n/* harmony export */   useUndo: function() { return /* binding */ useUndo; },\n/* harmony export */   useUnreadInboxNotificationsCount: function() { return /* binding */ useUnreadInboxNotificationsCount; },\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: function() { return /* binding */ useUnreadInboxNotificationsCountSuspense; },\n/* harmony export */   useUpdateRoomNotificationSettings: function() { return /* binding */ useUpdateRoomNotificationSettings; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(app-pages-browser)/./node_modules/@liveblocks/core/dist/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n// src/contexts.ts\n\nvar RoomContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useRoomOrNull() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/liveblocks.tsx\n\n\n\n\n\n// src/config.ts\nvar SECONDS = 1e3;\nvar MINUTES = 60 * SECONDS;\nvar config = {\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS\n};\n\n// src/lib/shallow2.ts\n\nfunction shallow2(a, b) {\n  if (!(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(a) || !(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(b)) {\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow)(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow)(a[key], b[key])\n  );\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/ThreadDB.ts\n\n\n// src/lib/guards.ts\n\nfunction isStartsWith(blob) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(blob) && isString(blob.startsWith);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\n\n// src/lib/querying.ts\nfunction makeThreadsFilter(query) {\n  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\nfunction matchesQuery(thread, q) {\n  return q.resolved === void 0 || thread.resolved === q.resolved;\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // NOTE: `op` can be explicitly-`undefined` here, which ideally would not\n      // mean \"filter for absence\" like it does now, as this does not match the\n      // backend behavior at the moment. For an in-depth discussion, see\n      // https://liveblocks.slack.com/archives/C02PZL7QAAW/p1728546988505989\n      matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (isStartsWith(op)) {\n    return isString(value) && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\n// src/ThreadDB.ts\nfunction sanitizeThread(thread) {\n  if (thread.deletedAt) {\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };\n  }\n  return thread;\n}\nvar ThreadDB = class _ThreadDB {\n  // The version is auto-incremented on every mutation and can be used as a reliable indicator to tell if the contents of the thread pool has changed\n  constructor() {\n    this._asc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.SortedList.from([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n    this._desc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.SortedList.from([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n    this._byId = /* @__PURE__ */ new Map();\n    this._version = 0;\n  }\n  //\n  // Public APIs\n  //\n  clone() {\n    const newPool = new _ThreadDB();\n    newPool._byId = new Map(this._byId);\n    newPool._asc = this._asc.clone();\n    newPool._desc = this._desc.clone();\n    newPool._version = this._version;\n    return newPool;\n  }\n  /** Gets the transaction count for this DB. Increments any time the DB is modified. */\n  get version() {\n    return this._version;\n  }\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  get(threadId) {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? void 0 : thread;\n  }\n  /** Returns the (possibly deleted) thread by ID. */\n  getEvenIfDeleted(threadId) {\n    return this._byId.get(threadId);\n  }\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  upsert(thread) {\n    thread = sanitizeThread(thread);\n    const id = thread.id;\n    const toRemove = this._byId.get(id);\n    if (toRemove) {\n      if (toRemove.deletedAt) return;\n      this._asc.remove(toRemove);\n      this._desc.remove(toRemove);\n    }\n    if (!thread.deletedAt) {\n      this._asc.add(thread);\n      this._desc.add(thread);\n    }\n    this._byId.set(id, thread);\n    this.touch();\n  }\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  upsertIfNewer(thread) {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  delete(threadId, deletedAt) {\n    const existing = this._byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  findMany(roomId, query, direction) {\n    const index = direction === \"desc\" ? this._desc : this._asc;\n    const crit = [];\n    if (roomId !== void 0) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    crit.push(makeThreadsFilter(query));\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n  //\n  // Private APIs\n  //\n  touch() {\n    ++this._version;\n  }\n};\n\n// src/umbrella-store.ts\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return `${roomId}-${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(query ?? {})}`;\n}\nfunction makeUserThreadsQueryKey(query) {\n  return `USER_THREADS:${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.stringify)(query ?? {})}`;\n}\nfunction makeNotificationSettingsQueryKey(roomId) {\n  return `${roomId}:NOTIFICATION_SETTINGS`;\n}\nfunction makeVersionsQueryKey(roomId) {\n  return `${roomId}-VERSIONS`;\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop2 = Promise.resolve();\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar PaginatedResource = class {\n  constructor(fetchPage) {\n    this._cachedPromise = null;\n    this._paginationState = null;\n    this._fetchPage = fetchPage;\n    this._eventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    this._pendingFetchMore = null;\n    this.observable = this._eventSource.observable;\n    autobind(this);\n  }\n  patchPaginationState(patch) {\n    const state = this._paginationState;\n    if (state === null) return;\n    this._paginationState = { ...state, ...patch };\n    this._eventSource.notify();\n  }\n  async _fetchMore() {\n    const state = this._paginationState;\n    if (!state?.cursor) {\n      return;\n    }\n    this.patchPaginationState({ isFetchingMore: true });\n    try {\n      const nextCursor = await this._fetchPage(state.cursor);\n      this.patchPaginationState({\n        cursor: nextCursor,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.patchPaginationState({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this._paginationState;\n    if (state?.cursor === null) {\n      return noop2;\n    }\n    if (!this._pendingFetchMore) {\n      this._pendingFetchMore = this._fetchMore().finally(() => {\n        this._pendingFetchMore = null;\n      });\n    }\n    return this._pendingFetchMore;\n  }\n  get() {\n    const usable = this._cachedPromise;\n    if (usable === null || usable.status === \"pending\") {\n      return ASYNC_LOADING;\n    }\n    if (usable.status === \"rejected\") {\n      return { isLoading: false, error: usable.reason };\n    }\n    const state = this._paginationState;\n    return {\n      isLoading: false,\n      data: {\n        fetchMore: this.fetchMore,\n        isFetchingMore: state.isFetchingMore,\n        fetchMoreError: state.fetchMoreError,\n        hasFetchedAll: state.cursor === null\n      }\n    };\n  }\n  waitUntilLoaded() {\n    if (this._cachedPromise) {\n      return this._cachedPromise;\n    }\n    const initialFetcher = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.autoRetry)(\n      () => this._fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(\n      initialFetcher.then((cursor) => {\n        this._paginationState = {\n          cursor,\n          isFetchingMore: false,\n          fetchMoreError: void 0\n        };\n      })\n    );\n    promise.then(\n      () => this._eventSource.notify(),\n      () => {\n        this._eventSource.notify();\n        setTimeout(() => {\n          this._cachedPromise = null;\n          this._eventSource.notify();\n        }, 5e3);\n      }\n    );\n    this._cachedPromise = promise;\n    return promise;\n  }\n};\nvar SinglePageResource = class {\n  constructor(fetchPage) {\n    this._cachedPromise = null;\n    this._fetchPage = fetchPage;\n    this._eventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n    this.observable = this._eventSource.observable;\n    autobind(this);\n  }\n  get() {\n    const usable = this._cachedPromise;\n    if (usable === null || usable.status === \"pending\") {\n      return ASYNC_LOADING;\n    }\n    if (usable.status === \"rejected\") {\n      return { isLoading: false, error: usable.reason };\n    }\n    return {\n      isLoading: false,\n      data: void 0\n    };\n  }\n  waitUntilLoaded() {\n    if (this._cachedPromise) {\n      return this._cachedPromise;\n    }\n    const initialFetcher = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.autoRetry)(\n      () => this._fetchPage(),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialFetcher);\n    promise.then(\n      () => this._eventSource.notify(),\n      () => {\n        this._eventSource.notify();\n        setTimeout(() => {\n          this._cachedPromise = null;\n          this._eventSource.notify();\n        }, 5e3);\n      }\n    );\n    this._cachedPromise = promise;\n    return promise;\n  }\n};\nvar UmbrellaStore = class {\n  constructor(client) {\n    this._prevVersion = -1;\n    this._prevState = null;\n    this._stateCached = null;\n    // Notifications\n    this._notificationsLastRequestedAt = null;\n    // Room Threads\n    this._roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    this._roomThreads = /* @__PURE__ */ new Map();\n    // User Threads\n    this._userThreadsLastRequestedAt = null;\n    this._userThreads = /* @__PURE__ */ new Map();\n    // Room versions\n    this._roomVersions = /* @__PURE__ */ new Map();\n    this._roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n    // Room notification settings\n    this._roomNotificationSettings = /* @__PURE__ */ new Map();\n    this._client = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].as();\n    const inboxFetcher = async (cursor) => {\n      const result = await this._client.getInboxNotifications({ cursor });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      if (this._notificationsLastRequestedAt === null) {\n        this._notificationsLastRequestedAt = result.requestedAt;\n      }\n      const nextCursor = result.nextCursor;\n      return nextCursor;\n    };\n    this._notifications = new PaginatedResource(inboxFetcher);\n    this._notifications.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._rawThreadsDB = new ThreadDB();\n    this._store = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createStore)({\n      optimisticUpdates: [],\n      notificationsById: {},\n      settingsByRoomId: {},\n      versionsByRoomId: {}\n    });\n    autobind(this);\n  }\n  get() {\n    const rawState = this._store.get();\n    if (this._prevVersion !== this._rawThreadsDB.version || // Note: Version check is only needed temporarily, until we can get rid of the Zustand-like update model\n    this._prevState !== rawState || this._stateCached === null) {\n      this._stateCached = internalToExternalState(rawState, this._rawThreadsDB);\n      this._prevState = rawState;\n      this._prevVersion = this._rawThreadsDB.version;\n    }\n    return this._stateCached;\n  }\n  batch(callback) {\n    return this._store.batch(callback);\n  }\n  getFullState() {\n    return this.get();\n  }\n  /**\n   * Returns the async result of the given query and room id. If the query is success,\n   * then it will return the threads that match that provided query and room id.\n   *\n   */\n  getRoomThreadsLoadingState(roomId, query) {\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    const paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = this.getFullState().threadsDB.findMany(\n      roomId,\n      query ?? {},\n      \"asc\"\n    );\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  getUserThreadsLoadingState(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = paginatedResource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const threads = this.getFullState().threadsDB.findMany(\n      void 0,\n      // Do _not_ filter by roomId\n      query ?? {},\n      \"desc\"\n    );\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      threads,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  getInboxNotificationsLoadingState() {\n    const asyncResult = this._notifications.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    const page = asyncResult.data;\n    return {\n      isLoading: false,\n      inboxNotifications: this.getFullState().cleanedNotifications,\n      hasFetchedAll: page.hasFetchedAll,\n      isFetchingMore: page.isFetchingMore,\n      fetchMoreError: page.fetchMoreError,\n      fetchMore: page.fetchMore\n    };\n  }\n  // NOTE: This will read the async result, but WILL NOT start loading at the moment!\n  getNotificationSettingsLoadingState(roomId) {\n    const queryKey = makeNotificationSettingsQueryKey(roomId);\n    const resource = this._roomNotificationSettings.get(queryKey);\n    if (resource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = resource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    return {\n      isLoading: false,\n      settings: (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(this.get().settingsByRoomId[roomId])\n    };\n  }\n  getRoomVersionsLoadingState(roomId) {\n    const queryKey = makeVersionsQueryKey(roomId);\n    const resource = this._roomVersions.get(queryKey);\n    if (resource === void 0) {\n      return ASYNC_LOADING;\n    }\n    const asyncResult = resource.get();\n    if (asyncResult.isLoading || asyncResult.error) {\n      return asyncResult;\n    }\n    return {\n      isLoading: false,\n      versions: Object.values(this.get().versionsByRoomId[roomId] ?? {})\n    };\n  }\n  /**\n   * @private Only used by the E2E test suite.\n   */\n  _hasOptimisticUpdates() {\n    return this._store.get().optimisticUpdates.length > 0;\n  }\n  subscribe(callback) {\n    return this._store.subscribe(callback);\n  }\n  // Direct low-level cache mutations ------------------------------------------------- {{{\n  mutateThreadsDB(mutate) {\n    const db = this._rawThreadsDB;\n    const old = db.version;\n    mutate(db);\n    if (old !== db.version) {\n      this._store.set((state) => ({ ...state }));\n    }\n  }\n  updateInboxNotificationsCache(mapFn) {\n    this._store.set((state) => {\n      const inboxNotifications = mapFn(state.notificationsById);\n      return inboxNotifications !== state.notificationsById ? { ...state, notificationsById: inboxNotifications } : state;\n    });\n  }\n  setNotificationSettings(roomId, settings) {\n    this._store.set((state) => ({\n      ...state,\n      settingsByRoomId: {\n        ...state.settingsByRoomId,\n        [roomId]: settings\n      }\n    }));\n  }\n  updateRoomVersions(roomId, versions) {\n    this._store.set((state) => {\n      const versionsById = Object.fromEntries(\n        versions.map((version2) => [version2.id, version2])\n      );\n      return {\n        ...state,\n        versionsByRoomId: {\n          ...state.versionsByRoomId,\n          [roomId]: {\n            // Merge with existing versions for the room, or start with an empty object\n            ...state.versionsByRoomId[roomId] ?? {},\n            ...versionsById\n          }\n        }\n      };\n    });\n  }\n  updateOptimisticUpdatesCache(mapFn) {\n    this._store.set((state) => ({\n      ...state,\n      optimisticUpdates: mapFn(state.optimisticUpdates)\n    }));\n  }\n  // ---------------------------------------------------------------------------------- }}}\n  /** @internal - Only call this method from unit tests. */\n  force_set(callback) {\n    return this._store.set(callback);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found in\n   * the cache.\n   */\n  updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const existing = cache[inboxNotificationId];\n        if (!existing) {\n          return cache;\n        }\n        const inboxNotifications = {\n          ...cache,\n          [inboxNotificationId]: callback(existing)\n        };\n        return inboxNotifications;\n      });\n    });\n  }\n  /**\n   * Updates *all* inbox notifications by running a mapper function over all of\n   * them, replacing the corresponding optimistic update.\n   */\n  updateAllInboxNotifications(optimisticUpdateId, mapFn) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.mapValues)(cache, mapFn));\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache((cache) => {\n        const { [inboxNotificationId]: removed, ...newCache } = cache;\n        return removed === void 0 ? cache : newCache;\n      });\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.updateInboxNotificationsCache(() => ({}));\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticUpdateId, thread) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.mutateThreadsDB((db) => db.upsert(thread));\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache; or\n   * - The thread ID in the cache was updated more recently than the optimistic\n   *   update's timestamp (if given)\n   */\n  updateThread(threadId, optimisticUpdateId, callback, updatedAt) {\n    this._store.batch(() => {\n      if (optimisticUpdateId !== null) {\n        this.removeOptimisticUpdate(optimisticUpdateId);\n      }\n      this.mutateThreadsDB((db) => {\n        const existing = db.get(threadId);\n        if (!existing) return;\n        if (!!updatedAt && existing.updatedAt > updatedAt) return;\n        db.upsert(callback(existing));\n      });\n    });\n  }\n  patchThread(threadId, optimisticUpdateId, patch, updatedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {\n    this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found in the cache; or\n   * - The thread ID was already deleted from the cache\n   */\n  deleteThread(threadId, optimisticUpdateId) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticUpdateId) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      const existingThread = this._rawThreadsDB.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n      this.mutateThreadsDB(\n        (db) => db.upsert(applyUpsertComment(existingThread, newComment))\n      );\n      this.updateInboxNotificationsCache((cache) => {\n        const existingNotification = Object.values(cache).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n        );\n        if (!existingNotification) {\n          return cache;\n        }\n        return {\n          ...cache,\n          [existingNotification.id]: {\n            ...existingNotification,\n            notifiedAt: newComment.createdAt,\n            readAt: newComment.createdAt\n          }\n        };\n      });\n    });\n  }\n  editComment(threadId, optimisticUpdateId, editedComment) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {\n    return this.updateThread(\n      threadId,\n      optimisticUpdateId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadAndNotification(thread, inboxNotification) {\n    this._store.batch(() => {\n      this.mutateThreadsDB((db) => db.upsertIfNewer(thread));\n      if (inboxNotification !== void 0) {\n        this.updateInboxNotificationsCache((cache) => ({\n          ...cache,\n          [inboxNotification.id]: inboxNotification\n        }));\n      }\n    });\n  }\n  updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads = [], deletedInboxNotifications = []) {\n    this._store.batch(() => {\n      this.mutateThreadsDB(\n        (db) => applyThreadDeltaUpdates(db, { newThreads: threads, deletedThreads })\n      );\n      this.updateInboxNotificationsCache(\n        (cache) => applyNotificationsUpdates(cache, {\n          newInboxNotifications: inboxNotifications,\n          deletedNotifications: deletedInboxNotifications\n        })\n      );\n    });\n  }\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  updateRoomNotificationSettings_confirmOptimisticUpdate(roomId, optimisticUpdateId, settings) {\n    this._store.batch(() => {\n      this.removeOptimisticUpdate(optimisticUpdateId);\n      this.setNotificationSettings(roomId, settings);\n    });\n  }\n  addOptimisticUpdate(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    this.updateOptimisticUpdatesCache((cache) => [...cache, newUpdate]);\n    return id;\n  }\n  removeOptimisticUpdate(optimisticUpdateId) {\n    this.updateOptimisticUpdatesCache(\n      (cache) => cache.filter((ou) => ou.id !== optimisticUpdateId)\n    );\n  }\n  async fetchNotificationsDeltaUpdate(signal) {\n    const lastRequestedAt = this._notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this._client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  waitUntilNotificationsLoaded() {\n    return this._notifications.waitUntilLoaded();\n  }\n  waitUntilRoomThreadsLoaded(roomId, query) {\n    const threadsFetcher = async (cursor) => {\n      const room = this._client.getRoom(roomId);\n      if (room === null) {\n        throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(`Room '${roomId}' is not available on client`, 479);\n      }\n      const result = await room.getThreads({ cursor, query });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n        this._roomThreadsLastRequestedAtByRoom.set(roomId, result.requestedAt);\n      }\n      return result.nextCursor;\n    };\n    const queryKey = makeRoomThreadsQueryKey(roomId, query);\n    let paginatedResource = this._roomThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room.getThreadsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateThreadsAndNotifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n    if (lastRequestedAt < updates.requestedAt) {\n      this._roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  waitUntilUserThreadsLoaded(query) {\n    const queryKey = makeUserThreadsQueryKey(query);\n    const threadsFetcher = async (cursor) => {\n      const result = await this._client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getUserThreads_experimental({\n        cursor,\n        query\n      });\n      this.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications\n      );\n      if (this._userThreadsLastRequestedAt === null) {\n        this._userThreadsLastRequestedAt = result.requestedAt;\n      }\n      return result.nextCursor;\n    };\n    let paginatedResource = this._userThreads.get(queryKey);\n    if (paginatedResource === void 0) {\n      paginatedResource = new PaginatedResource(threadsFetcher);\n    }\n    paginatedResource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._userThreads.set(queryKey, paginatedResource);\n    return paginatedResource.waitUntilLoaded();\n  }\n  async fetchUserThreadsDeltaUpdate(signal) {\n    const lastRequestedAt = this._userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this._client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this._notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadsAndNotifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  waitUntilRoomVersionsLoaded(roomId) {\n    const queryKey = makeVersionsQueryKey(roomId);\n    let resource = this._roomVersions.get(queryKey);\n    if (resource === void 0) {\n      const versionsFetcher = async () => {\n        const room = this._client.getRoom(roomId);\n        if (room === null) {\n          throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(\n            `Room '${roomId}' is not available on client`,\n            479\n          );\n        }\n        const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].listTextVersions();\n        this.updateRoomVersions(roomId, result.versions);\n        const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);\n        if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n          this._roomVersionsLastRequestedAtByRoom.set(\n            roomId,\n            result.requestedAt\n          );\n        }\n      };\n      resource = new SinglePageResource(versionsFetcher);\n    }\n    resource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomVersions.set(queryKey, resource);\n    return resource.waitUntilLoaded();\n  }\n  async fetchRoomVersionsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateRoomVersions(roomId, updates.versions);\n    if (lastRequestedAt < updates.requestedAt) {\n      this._roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  waitUntilRoomNotificationSettingsLoaded(roomId) {\n    const queryKey = makeNotificationSettingsQueryKey(roomId);\n    let resource = this._roomNotificationSettings.get(queryKey);\n    if (resource === void 0) {\n      const notificationSettingsFetcher = async () => {\n        const room = this._client.getRoom(roomId);\n        if (room === null) {\n          throw new _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError(\n            `Room '${roomId}' is not available on client`,\n            479\n          );\n        }\n        const result = await room.getNotificationSettings();\n        this.setNotificationSettings(roomId, result);\n      };\n      resource = new SinglePageResource(notificationSettingsFetcher);\n    }\n    resource.observable.subscribe(\n      () => (\n        // Note that the store itself does not change, but it's only vehicle at\n        // the moment to trigger a re-render, so we'll do a no-op update here.\n        this._store.set((store) => ({ ...store }))\n      )\n    );\n    this._roomNotificationSettings.set(queryKey, resource);\n    return resource.waitUntilLoaded();\n  }\n  async refreshRoomNotificationSettings(roomId, signal) {\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.nn)(\n      this._client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getNotificationSettings({ signal });\n    this.setNotificationSettings(roomId, result);\n  }\n};\nfunction internalToExternalState(state, rawThreadsDB) {\n  const threadsDB = rawThreadsDB.clone();\n  const computed = {\n    notificationsById: { ...state.notificationsById },\n    settingsByRoomId: { ...state.settingsByRoomId }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        });\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        const inboxNotification = Object.values(\n          computed.notificationsById\n        ).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        computed.notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        });\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        computed.notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in computed.notificationsById) {\n          const ibn = computed.notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          computed.notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete computed.notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        computed.notificationsById = {};\n        break;\n      }\n      case \"update-notification-settings\": {\n        const settings = computed.settingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        computed.settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  const cleanedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(computed.notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    cleanedNotifications,\n    notificationsById: computed.notificationsById,\n    settingsByRoomId: computed.settingsByRoomId,\n    threadsDB,\n    versionsByRoomId: state.versionsByRoomId\n  };\n}\nfunction applyThreadDeltaUpdates(db, updates) {\n  updates.newThreads.forEach((thread) => db.upsertIfNewer(thread));\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existing = db.getEvenIfDeleted(id);\n    if (!existing) return;\n    db.delete(id, deletedAt);\n  });\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction identity(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nfunction selectUnreadInboxNotificationsCount(inboxNotifications) {\n  let count = 0;\n  for (const notification of inboxNotifications) {\n    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!result.inboxNotifications) {\n    return result;\n  }\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(result.inboxNotifications)\n  };\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const notificationsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n  const userThreadsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: client }, props.children);\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual) {\n  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.waitUntilNotificationsLoaded();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.getInboxNotificationsLoadingState,\n    store.getInboxNotificationsLoadingState,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useInboxNotifications_withClient(client, identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.waitUntilNotificationsLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId,\n            (inboxNotification) => ({ ...inboxNotification, readAt })\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.updateAllInboxNotifications(\n          optimisticUpdateId,\n          (inboxNotification) => ({ ...inboxNotification, readAt })\n        );\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(\n            inboxNotificationId,\n            optimisticUpdateId\n          );\n        },\n        () => {\n          store.removeOptimisticUpdate(optimisticUpdateId);\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticUpdateId = store.addOptimisticUpdate({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticUpdateId);\n      },\n      () => {\n        store.removeOptimisticUpdate(optimisticUpdateId);\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  const getter = store.getFullState;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(`Inbox notification with ID \"${inboxNotificationId}\" not found`);\n      if (inboxNotification.kind !== \"thread\") {\n        (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n        );\n      }\n      const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\n        `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n      );\n      return thread;\n    },\n    [inboxNotificationId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    // Re-evaluate if we need to update any time the notification changes over time\n    getter,\n    getter,\n    selector\n  );\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void usersStore.get(userId);\n  }, [usersStore, userId, result]);\n  return result;\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.get(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  const result = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void roomsInfoStore.get(roomId);\n  }, [roomsInfoStore, roomId, result]);\n  return result;\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.get(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClientContext.Provider, { value: props.client }, props.children);\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createClient)(options), []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client }, children);\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      void store.waitUntilUserThreadsLoaded(options.query);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const getter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getUserThreadsLoadingState(options.query),\n    [store, options.query]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {\n  query: {\n    metadata: {}\n  }\n}) {\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  use(store.waitUntilUserThreadsLoaded(options.query));\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\n\n// src/types/errors.ts\nvar CreateThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateThreadError\";\n  }\n};\nvar DeleteThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteThreadError\";\n  }\n};\nvar EditThreadMetadataError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit thread metadata failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditThreadMetadataError\";\n  }\n};\nvar MarkThreadAsResolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as resolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsResolvedError\";\n  }\n};\nvar MarkThreadAsUnresolvedError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark thread as unresolved failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkThreadAsUnresolvedError\";\n  }\n};\nvar CreateCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateCommentError\";\n  }\n};\nvar EditCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditCommentError\";\n  }\n};\nvar DeleteCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteCommentError\";\n  }\n};\nvar AddReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Add reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"AddReactionError\";\n  }\n};\nvar RemoveReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Remove reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"RemoveReactionError\";\n  }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark inbox notification as read failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n  constructor(cause, context) {\n    super(\"Update notification settings failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n};\n\n// src/room.tsx\n\n\n\n\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\nvar SMOOTH_DELAY = 1e3;\nvar noop3 = () => {\n};\nvar identity2 = (x) => x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n  roomId\n)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don\\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\\u2019re on React 18+ already.\";\nfunction useSyncExternalStore2(s, gs, gss) {\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(s, gs, gss, identity2);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(room) {\n  const self = room.getSelf();\n  if (self === null || self.id === void 0) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\nfunction handleApiError(err) {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join(\"\\n\");\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.error(detailedMessage);\n  }\n  return new Error(message);\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const commentsErrorEventSource = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makeEventSource)();\n  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n    store.removeOptimisticUpdate(optimisticUpdateId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.HttpError) {\n      handleApiError(innerError);\n      return;\n    }\n    throw innerError;\n  }\n  const threadsPollersByRoomId = /* @__PURE__ */ new Map();\n  const versionsPollersByRoomId = /* @__PURE__ */ new Map();\n  const roomNotificationSettingsPollersByRoomId = /* @__PURE__ */ new Map();\n  function getOrCreateThreadsPollerForRoomId(roomId) {\n    let poller = threadsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.ROOM_THREADS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n      );\n      threadsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  function getOrCreateVersionsPollerForRoomId(roomId) {\n    let poller = versionsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.HISTORY_VERSIONS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n      );\n      versionsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  function getOrCreateNotificationsSettingsPollerForRoomId(roomId) {\n    let poller = roomNotificationSettingsPollersByRoomId.get(roomId);\n    if (!poller) {\n      poller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.makePoller)(\n        async (signal) => {\n          try {\n            return await store.refreshRoomNotificationSettings(roomId, signal);\n          } catch (err) {\n            _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);\n            throw err;\n          }\n        },\n        config.NOTIFICATION_SETTINGS_POLL_INTERVAL,\n        { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n      );\n      roomNotificationSettingsPollersByRoomId.set(roomId, poller);\n    }\n    return poller;\n  }\n  return {\n    store,\n    commentsErrorEventSource: commentsErrorEventSource.observable,\n    onMutationFailure,\n    getOrCreateThreadsPollerForRoomId,\n    getOrCreateVersionsPollerForRoomId,\n    getOrCreateNotificationsSettingsPollerForRoomId\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomProvider, { ...props }));\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    },\n    useCommentsErrorListener\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (!isString(roomId)) {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const oldReactVersion = majorReactVersion < 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.errorIf)(\n      oldReactVersion && props.unstable_batchedUpdates === void 0,\n      missing_unstable_batchedUpdates(majorReactVersion, roomId)\n    );\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.deprecateIf)(\n      !oldReactVersion && props.unstable_batchedUpdates !== void 0,\n      superfluous_unstable_batchedUpdates\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    unstable_batchedUpdates: props.unstable_batchedUpdates,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification } = info;\n      const existingThread = store.getFullState().threadsDB.getEvenIfDeleted(message.threadId);\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RoomContext.Provider, { value: room }, props.children);\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useErrorListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => room.events.error.subscribe((e) => savedCallback.current(e)),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore2(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore2(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity2;\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity2,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,\n    [room, rootOrNull]\n  );\n  const getSnapshot = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomThreadsLoaded(room.id, options.query);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getRoomThreadsLoadingState(room.id, options.query),\n    [store, room.id, options.query]\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n    // NOTE: Using 2-level-deep shallow check here, because the result of selectThreads() is not stable!\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useCommentsErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  const { commentsErrorEventSource } = getRoomExtrasForClient(client);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return commentsErrorEventSource.subscribe(savedCallback.current);\n  }, [savedCallback, commentsErrorEventSource]);\n}\nfunction useCreateThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId: room.id,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId: room.id\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createThread({ threadId, commentId, body, metadata, attachmentIds }).then(\n        (thread) => {\n          store.createThread(optimisticUpdateId, thread);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateThreadError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body,\n            metadata\n          })\n        )\n      );\n      return newThread;\n    },\n    [client, room]\n  );\n}\nfunction useDeleteThread() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(room);\n      const existing = store.getFullState().threadsDB.get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-thread\",\n        roomId: room.id,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      room.deleteThread(threadId).then(\n        () => {\n          store.deleteThread(threadId, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useEditThreadMetadata() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      room.editThreadMetadata({ threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { metadata: metadata2 },\n            updatedAt\n          )\n        ),\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditThreadMetadataError(error, {\n            roomId: room.id,\n            threadId,\n            metadata\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useCreateComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(room),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.createComment({ threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticUpdateId);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateCommentError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n      return comment;\n    },\n    [client, room]\n  );\n}\nfunction useEditComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.getFullState().threadsDB.getEvenIfDeleted(threadId);\n      if (existing === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = existing.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      room.editComment({ threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticUpdateId, editedComment);\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useDeleteComment() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId: room.id\n      });\n      room.deleteComment({ threadId, commentId }).then(\n        () => {\n          store.deleteComment(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            deletedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new DeleteCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useAddReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(room);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      room.addReaction({ threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new AddReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useRemoveReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(room);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      room.removeReaction({ threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticUpdateId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new RemoveReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsRead() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.getFullState().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      room.markInboxNotificationAsRead(inboxNotification.id).then(\n        () => {\n          store.updateInboxNotification(\n            inboxNotification.id,\n            optimisticUpdateId,\n            (inboxNotification2) => ({ ...inboxNotification2, readAt: now })\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            err,\n            optimisticUpdateId,\n            (error) => new MarkInboxNotificationAsReadError(error, {\n              inboxNotificationId: inboxNotification.id\n            })\n          );\n          return;\n        }\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsResolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsResolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      room.markThreadAsUnresolved(threadId).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticUpdateId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new MarkThreadAsUnresolvedError(error, {\n            roomId: room.id,\n            threadId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const selector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (state) => {\n      const notification = state.cleanedNotifications.find(\n        (inboxNotification) => inboxNotification.kind === \"thread\" && inboxNotification.threadId === threadId\n      );\n      const thread = state.threadsDB.get(threadId);\n      if (notification === void 0 || thread === void 0) {\n        return { status: \"not-subscribed\" };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: notification.readAt\n      };\n    },\n    [threadId]\n  );\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    store.getFullState,\n    store.getFullState,\n    selector\n  );\n}\nfunction useRoomNotificationSettings() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomNotificationSettingsLoaded(room.id);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getNotificationSettingsLoadingState(room.id),\n    [store, room.id]\n  );\n  const settings = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomNotificationSettingsSuspense() {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n  use(store.waitUntilRoomNotificationSettingsLoaded(room.id));\n  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!settings.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!settings.isLoading, \"Did not expect loading\");\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    isLoading: true\n  });\n  const room = useRoom();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const getter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => store.getRoomVersionsLoadingState(room.id),\n    [store, room.id]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(\n    () => {\n      void store.waitUntilRoomVersionsLoaded(room.id);\n    }\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  const state = (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    store.subscribe,\n    getter,\n    getter,\n    identity2,\n    shallow2\n  );\n  return state;\n}\nfunction useHistoryVersionsSuspense() {\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n  use(store.waitUntilRoomVersionsLoaded(room.id));\n  const result = useHistoryVersions();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (settings) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticUpdateId = store.addOptimisticUpdate({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateRoomNotificationSettings_confirmOptimisticUpdate(\n            room.id,\n            optimisticUpdateId,\n            settings2\n          );\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new UpdateNotificationSettingsError(error, {\n            roomId: room.id\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n    );\n  }\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {\n  query: { metadata: {} }\n}) {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  use(store.waitUntilRoomThreadsLoaded(room.id, options.query));\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    void attachmentUrlsStore.get(attachmentId);\n  }, [attachmentUrlsStore, attachmentId]);\n  return (0,use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__.useSyncExternalStoreWithSelector)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal];\n  const getAttachmentUrlState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    () => attachmentUrlsStore.getState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.get(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = useSyncExternalStore2(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useRoomNotificationSettings = useRoomNotificationSettings;\nvar _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-A7GJNN4L.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2NodW5rLUE3R0pOTjRMLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytCO0FBQy9CLGtCQUFrQixnREFBbUI7QUFDckM7QUFDQSxTQUFTLDZDQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUTBCO0FBT1g7QUFDOEQ7QUFDb0I7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwRDtBQUMxRDtBQUNBLE9BQU8sK0RBQWEsUUFBUSwrREFBYTtBQUN6QyxXQUFXLHlEQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBTztBQUNwRTtBQUNBOztBQUVBO0FBQ2dEOztBQUVoRDtBQUMwQztBQUMxQztBQUNBLGNBQWMsNkNBQU07QUFDcEIsRUFBRSxnREFBUztBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBVztBQUN0QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFhMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVM7QUFDbkM7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQVc7QUFDN0I7QUFDQSwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFRO0FBQ1osaUJBQWlCLFlBQVksNEJBQTRCLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkUsUUFB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VUFBVSxtQ0FBbUM7QUFDN0MsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQixrREFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtHQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLEVBQUUsd0RBQU07QUFDUixFQUFFLHdEQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFEQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUQ7QUFhL0I7QUFDTTtBQUNzRzs7QUFFdEk7QUFDZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLGFBQWE7O0FBRW5ILGFBQWEsMEJBQTBCLG1CQUFtQjs7QUFFMUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsR0FBRyw2QkFBNkIsd0JBQXdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUywrR0FBaUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLElBQUksWUFBWTtBQUMzRTtBQUNBO0FBQ0EsSUFBSSxxREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQWdCO0FBQ25EO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVkscURBQVEsa0NBQWtDLE9BQU8sWUFBWSxZQUFZO0FBQ3JGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVkscURBQVEsMkNBQTJDLE9BQU8sWUFBWSxZQUFZO0FBQzlGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVkscURBQVEsNENBQTRDLE9BQU8sWUFBWSxZQUFZO0FBQy9GO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQW9CLGlDQUFpQyw0QkFBNEIsa0JBQWtCLGdEQUFvQixpQkFBaUIsVUFBVTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLHVEQUFVO0FBQ2pEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBZTtBQUNqQztBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQ0FBYztBQUNyRDtBQUNBLElBQUkseURBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVcsTUFBTSxzQkFBc0IsMkNBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQSwyQkFBMkIsMkRBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxhQUFhLDJEQUFhO0FBQzFCLGFBQWEsMkRBQWE7QUFDMUIsYUFBYSwyREFBYTtBQUMxQixhQUFhLDJEQUFhO0FBQzFCLGFBQWEsMkRBQWE7QUFDMUIsYUFBYSwyREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixnREFBb0IseUJBQXlCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFlO0FBQzdDO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBa0I7QUFDM0Isd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0dBQWlDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtHQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscURBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQWtCO0FBQ3RDLHlGQUF5RixjQUFjO0FBQ3ZHO0FBQ0E7QUFDQSxzQkFBc0IsOENBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxTQUFTLCtHQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBDQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsQ0FBQztBQUNELFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsOENBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrR0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQyxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFjO0FBQ3JDLHdCQUF3QixpRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEJBQTBCLG9EQUFvRDtBQUM5RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBa0I7QUFDM0I7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJCQUEyQjtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWtCO0FBQzNCLE9BQU8sNkJBQTZCO0FBQ3BDLHdCQUF3QixpRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkIsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBa0I7QUFDM0IsT0FBTyx3Q0FBd0M7QUFDL0M7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0EsUUFBUSxxREFBUTtBQUNoQiwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQVE7QUFDaEIsZ0VBQWdFLFVBQVUsZUFBZSxTQUFTO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWtCO0FBQzNCLE9BQU8scUJBQXFCO0FBQzVCO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUFrQjtBQUMzQixPQUFPLDRCQUE0QjtBQUNuQztBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBa0I7QUFDM0IsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUFrQjtBQUMzQjtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQ0FBb0M7QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOENBQWtCO0FBQzNCO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUFrQjtBQUMzQjtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixtQkFBbUIsOENBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLCtHQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQXlEO0FBQ25FO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsOENBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrR0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQU87QUFDVCxFQUFFLHdEQUFPO0FBQ1QsU0FBUywwQ0FBYztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCLDJDQUFlO0FBQzNDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSw0Q0FBZ0I7QUFDbEIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLG9DQUFvQyx1REFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLDhDQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0dBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFPO0FBQ1QsRUFBRSx3REFBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhDQUFrQjtBQUMzQjtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0EsRUFBRSx3REFBTztBQUNULEVBQUUsd0RBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCLE9BQU8sdURBQVU7QUFDakQsZ0NBQWdDLDhDQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBLEdBQUc7QUFDSCxTQUFTLCtHQUFpQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCLE9BQU8sdURBQVU7QUFDakQsZ0NBQWdDLDhDQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFPO0FBQ1QsRUFBRSx3REFBTztBQUNULEVBQUUsd0RBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWtGRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9yZWFjdC9kaXN0L2NodW5rLUE3R0pOTjRMLm1qcz83NTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb250ZXh0cy50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgUm9vbUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlUm9vbU9yTnVsbCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUm9vbUNvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlSXNJbnNpZGVSb29tKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbU9yTnVsbCgpO1xuICByZXR1cm4gcm9vbSAhPT0gbnVsbDtcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGNyZWF0ZUNsaWVudCxcbiAga0ludGVybmFsIGFzIGtJbnRlcm5hbDIsXG4gIG1ha2VQb2xsZXIsXG4gIHJhaXNlLFxuICBzaGFsbG93IGFzIHNoYWxsb3czXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQgUmVhY3QyLCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsXG4gIHVzZU1lbW9cbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanNcIjtcblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIFNFQ09ORFMgPSAxZTM7XG52YXIgTUlOVVRFUyA9IDYwICogU0VDT05EUztcbnZhciBjb25maWcgPSB7XG4gIE5PVElGSUNBVElPTlNfUE9MTF9JTlRFUlZBTDogMSAqIE1JTlVURVMsXG4gIE5PVElGSUNBVElPTlNfTUFYX1NUQUxFX1RJTUU6IDUgKiBTRUNPTkRTLFxuICBST09NX1RIUkVBRFNfUE9MTF9JTlRFUlZBTDogNSAqIE1JTlVURVMsXG4gIFJPT01fVEhSRUFEU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIFVTRVJfVEhSRUFEU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgVVNFUl9USFJFQURTX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgSElTVE9SWV9WRVJTSU9OU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgSElTVE9SWV9WRVJTSU9OU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIE5PVElGSUNBVElPTl9TRVRUSU5HU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EU1xufTtcblxuLy8gc3JjL2xpYi9zaGFsbG93Mi50c1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgc2hhbGxvdyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzaGFsbG93MihhLCBiKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChhKSB8fCAhaXNQbGFpbk9iamVjdChiKSkge1xuICAgIHJldHVybiBzaGFsbG93KGEsIGIpO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgJiYgc2hhbGxvdyhhW2tleV0sIGJba2V5XSlcbiAgKTtcbn1cblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZHVjZXIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2xpYi91c2UtbGF0ZXN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTGF0ZXN0KHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbnZhciBub29wID0gKHN0YXRlKSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIHVzZUluaXRpYWwodmFsdWUpIHtcbiAgcmV0dXJuIHVzZVJlZHVjZXIobm9vcCwgdmFsdWUpWzBdO1xufVxuZnVuY3Rpb24gdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKGxhdGVzdFZhbHVlKSB7XG4gIGNvbnN0IGZyb3plblZhbHVlID0gdXNlSW5pdGlhbChsYXRlc3RWYWx1ZSk7XG4gIGlmICh0eXBlb2YgZnJvemVuVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHJlZiA9IHVzZUxhdGVzdChsYXRlc3RWYWx1ZSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzKSA9PiByZWYuY3VycmVudCguLi5hcmdzKSwgW1xuICAgICAgcmVmXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb3plblZhbHVlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvdXNlLXBvbHlmaWxsLnRzXG52YXIgdXNlID0gKFxuICAvLyBSZWFjdC51c2UgfHxcbiAgKHByb21pc2UpID0+IHtcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRocm93IHByb21pc2U7XG4gICAgfVxuICB9XG4pO1xuXG4vLyBzcmMvdW1icmVsbGEtc3RvcmUudHNcbmltcG9ydCB7XG4gIGF1dG9SZXRyeSxcbiAgY29tcGFjdE9iamVjdCxcbiAgY29uc29sZSBhcyBjb25zb2xlMixcbiAgY3JlYXRlU3RvcmUsXG4gIEh0dHBFcnJvcixcbiAga0ludGVybmFsLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1hcFZhbHVlcyxcbiAgbmFub2lkLFxuICBubixcbiAgc3RyaW5naWZ5XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy9saWIvYXV0b2JpbmQudHNcbmZ1bmN0aW9uIGF1dG9iaW5kKHNlbGYpIHtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHNlZW4uYWRkKFwiY29uc3RydWN0b3JcIik7XG4gIGxldCBvYmogPSBzZWxmLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgZG8ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3Qub3duS2V5cyhvYmopKSB7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yPy52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHNlbGZba2V5XSA9IHNlbGZba2V5XS5iaW5kKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKG9iaiA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSkgJiYgb2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcbn1cblxuLy8gc3JjL1RocmVhZERCLnRzXG5pbXBvcnQgeyBTb3J0ZWRMaXN0IH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgYXMgaXNQbGFpbk9iamVjdDIgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuZnVuY3Rpb24gaXNTdGFydHNXaXRoKGJsb2IpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QyKGJsb2IpICYmIGlzU3RyaW5nKGJsb2Iuc3RhcnRzV2l0aCk7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuXG4vLyBzcmMvbGliL3F1ZXJ5aW5nLnRzXG5mdW5jdGlvbiBtYWtlVGhyZWFkc0ZpbHRlcihxdWVyeSkge1xuICByZXR1cm4gKHRocmVhZCkgPT4gbWF0Y2hlc1F1ZXJ5KHRocmVhZCwgcXVlcnkpICYmIG1hdGNoZXNNZXRhZGF0YSh0aHJlYWQsIHF1ZXJ5KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNRdWVyeSh0aHJlYWQsIHEpIHtcbiAgcmV0dXJuIHEucmVzb2x2ZWQgPT09IHZvaWQgMCB8fCB0aHJlYWQucmVzb2x2ZWQgPT09IHEucmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtYXRjaGVzTWV0YWRhdGEodGhyZWFkLCBxKSB7XG4gIGNvbnN0IG1ldGFkYXRhID0gdGhyZWFkLm1ldGFkYXRhO1xuICByZXR1cm4gcS5tZXRhZGF0YSA9PT0gdm9pZCAwIHx8IE9iamVjdC5lbnRyaWVzKHEubWV0YWRhdGEpLmV2ZXJ5KFxuICAgIChba2V5LCBvcF0pID0+IChcbiAgICAgIC8vIE5PVEU6IGBvcGAgY2FuIGJlIGV4cGxpY2l0bHktYHVuZGVmaW5lZGAgaGVyZSwgd2hpY2ggaWRlYWxseSB3b3VsZCBub3RcbiAgICAgIC8vIG1lYW4gXCJmaWx0ZXIgZm9yIGFic2VuY2VcIiBsaWtlIGl0IGRvZXMgbm93LCBhcyB0aGlzIGRvZXMgbm90IG1hdGNoIHRoZVxuICAgICAgLy8gYmFja2VuZCBiZWhhdmlvciBhdCB0aGUgbW9tZW50LiBGb3IgYW4gaW4tZGVwdGggZGlzY3Vzc2lvbiwgc2VlXG4gICAgICAvLyBodHRwczovL2xpdmVibG9ja3Muc2xhY2suY29tL2FyY2hpdmVzL0MwMlBaTDdRQUFXL3AxNzI4NTQ2OTg4NTA1OTg5XG4gICAgICBtYXRjaGVzT3BlcmF0b3IobWV0YWRhdGFba2V5XSwgb3ApXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hlc09wZXJhdG9yKHZhbHVlLCBvcCkge1xuICBpZiAoaXNTdGFydHNXaXRoKG9wKSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChvcC5zdGFydHNXaXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG9wO1xuICB9XG59XG5cbi8vIHNyYy9UaHJlYWREQi50c1xuZnVuY3Rpb24gc2FuaXRpemVUaHJlYWQodGhyZWFkKSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0KSB7XG4gICAgaWYgKHRocmVhZC5jb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4geyAuLi50aHJlYWQsIGNvbW1lbnRzOiBbXSB9O1xuICAgIH1cbiAgfVxuICBjb25zdCBoYXNDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLnNvbWUoKGMpID0+ICFjLmRlbGV0ZWRBdCk7XG4gIGlmICghaGFzQ29tbWVudCkge1xuICAgIHJldHVybiB7IC4uLnRocmVhZCwgZGVsZXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgY29tbWVudHM6IFtdIH07XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbnZhciBUaHJlYWREQiA9IGNsYXNzIF9UaHJlYWREQiB7XG4gIC8vIFRoZSB2ZXJzaW9uIGlzIGF1dG8taW5jcmVtZW50ZWQgb24gZXZlcnkgbXV0YXRpb24gYW5kIGNhbiBiZSB1c2VkIGFzIGEgcmVsaWFibGUgaW5kaWNhdG9yIHRvIHRlbGwgaWYgdGhlIGNvbnRlbnRzIG9mIHRoZSB0aHJlYWQgcG9vbCBoYXMgY2hhbmdlZFxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hc2MgPSBTb3J0ZWRMaXN0LmZyb20oW10sICh0MSwgdDIpID0+IHtcbiAgICAgIGNvbnN0IGQxID0gdDEuY3JlYXRlZEF0O1xuICAgICAgY29uc3QgZDIgPSB0Mi5jcmVhdGVkQXQ7XG4gICAgICByZXR1cm4gZDEgPCBkMiA/IHRydWUgOiBkMSA9PT0gZDIgPyB0MS5pZCA8IHQyLmlkIDogZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy5fZGVzYyA9IFNvcnRlZExpc3QuZnJvbShbXSwgKHQxLCB0MikgPT4ge1xuICAgICAgY29uc3QgZDIgPSB0Mi51cGRhdGVkQXQ7XG4gICAgICBjb25zdCBkMSA9IHQxLnVwZGF0ZWRBdDtcbiAgICAgIHJldHVybiBkMiA8IGQxID8gdHJ1ZSA6IGQyID09PSBkMSA/IHQyLmlkIDwgdDEuaWQgOiBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLl9ieUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl92ZXJzaW9uID0gMDtcbiAgfVxuICAvL1xuICAvLyBQdWJsaWMgQVBJc1xuICAvL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBuZXdQb29sID0gbmV3IF9UaHJlYWREQigpO1xuICAgIG5ld1Bvb2wuX2J5SWQgPSBuZXcgTWFwKHRoaXMuX2J5SWQpO1xuICAgIG5ld1Bvb2wuX2FzYyA9IHRoaXMuX2FzYy5jbG9uZSgpO1xuICAgIG5ld1Bvb2wuX2Rlc2MgPSB0aGlzLl9kZXNjLmNsb25lKCk7XG4gICAgbmV3UG9vbC5fdmVyc2lvbiA9IHRoaXMuX3ZlcnNpb247XG4gICAgcmV0dXJuIG5ld1Bvb2w7XG4gIH1cbiAgLyoqIEdldHMgdGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIERCLiBJbmNyZW1lbnRzIGFueSB0aW1lIHRoZSBEQiBpcyBtb2RpZmllZC4gKi9cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cbiAgLyoqIFJldHVybnMgYW4gZXhpc3RpbmcgdGhyZWFkIGJ5IElELiBXaWxsIG5ldmVyIHJldHVybiBhIGRlbGV0ZWQgdGhyZWFkLiAqL1xuICBnZXQodGhyZWFkSWQpIHtcbiAgICBjb25zdCB0aHJlYWQgPSB0aGlzLmdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpO1xuICAgIHJldHVybiB0aHJlYWQ/LmRlbGV0ZWRBdCA/IHZvaWQgMCA6IHRocmVhZDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgKHBvc3NpYmx5IGRlbGV0ZWQpIHRocmVhZCBieSBJRC4gKi9cbiAgZ2V0RXZlbklmRGVsZXRlZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiB0aGlzLl9ieUlkLmdldCh0aHJlYWRJZCk7XG4gIH1cbiAgLyoqIEFkZHMgb3IgdXBkYXRlcyBhIHRocmVhZCBpbiB0aGUgREIuIElmIHRoZSBuZXdseSBnaXZlbiB0aHJlYWQgaXMgYSBkZWxldGVkIG9uZSwgaXQgd2lsbCBnZXQgZGVsZXRlZC4gKi9cbiAgdXBzZXJ0KHRocmVhZCkge1xuICAgIHRocmVhZCA9IHNhbml0aXplVGhyZWFkKHRocmVhZCk7XG4gICAgY29uc3QgaWQgPSB0aHJlYWQuaWQ7XG4gICAgY29uc3QgdG9SZW1vdmUgPSB0aGlzLl9ieUlkLmdldChpZCk7XG4gICAgaWYgKHRvUmVtb3ZlKSB7XG4gICAgICBpZiAodG9SZW1vdmUuZGVsZXRlZEF0KSByZXR1cm47XG4gICAgICB0aGlzLl9hc2MucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgIHRoaXMuX2Rlc2MucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKCF0aHJlYWQuZGVsZXRlZEF0KSB7XG4gICAgICB0aGlzLl9hc2MuYWRkKHRocmVhZCk7XG4gICAgICB0aGlzLl9kZXNjLmFkZCh0aHJlYWQpO1xuICAgIH1cbiAgICB0aGlzLl9ieUlkLnNldChpZCwgdGhyZWFkKTtcbiAgICB0aGlzLnRvdWNoKCk7XG4gIH1cbiAgLyoqIExpa2UgLnVwc2VydCgpLCBleGNlcHQgaXQgd29uJ3QgdXBkYXRlIGlmIGEgdGhyZWFkIGJ5IHRoaXMgSUQgYWxyZWFkeSBleGlzdHMuICovXG4gIC8vIFRPRE8gQ29uc2lkZXIgcmVuYW1pbmcgdGhpcyB0byBqdXN0IC51cHNlcnQoKS4gSSdtIG5vdCBzdXJlIGlmIHdlIHJlYWxseVxuICAvLyBUT0RPIG5lZWQgdGhlIHJhdyAudXBzZXJ0KCkuIFdvdWxkIGJlIG5pY2UgaWYgdGhpcyBiZWhhdmlvciB3YXMgdGhlIGRlZmF1bHQuXG4gIHVwc2VydElmTmV3ZXIodGhyZWFkKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldCh0aHJlYWQuaWQpO1xuICAgIGlmICghZXhpc3RpbmcgfHwgdGhyZWFkLnVwZGF0ZWRBdCA+PSBleGlzdGluZy51cGRhdGVkQXQpIHtcbiAgICAgIHRoaXMudXBzZXJ0KHRocmVhZCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNYXJrcyBhIHRocmVhZCBhcyBkZWxldGVkLiBJdCB3aWxsIG5vIGxvbmdlciBwb3AgdXAgaW4gLmZpbmRNYW55KClcbiAgICogcXVlcmllcywgYnV0IGl0IGNhbiBzdGlsbCBiZSBhY2Nlc3NlZCB2aWEgYC5nZXRFdmVuSWZEZWxldGVkKClgLlxuICAgKi9cbiAgZGVsZXRlKHRocmVhZElkLCBkZWxldGVkQXQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuX2J5SWQuZ2V0KHRocmVhZElkKTtcbiAgICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLmRlbGV0ZWRBdCkge1xuICAgICAgdGhpcy51cHNlcnQoeyAuLi5leGlzdGluZywgZGVsZXRlZEF0LCB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRocmVhZHMgbWF0Y2hpbmcgYSBnaXZlbiByb29tSWQgYW5kIHF1ZXJ5LiBJZiByb29tSWQgaXMgbm90XG4gICAqIHNwZWNpZmllZCwgaXQgd2lsbCByZXR1cm4gYWxsIHRocmVhZHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBhY3Jvc3MgYWxsXG4gICAqIHJvb21zLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSByZXN1bHRzIGluIHRoZSByZXF1ZXN0ZWQgb3JkZXIuIFBsZWFzZSBub3RlOlxuICAgKiAgICdhc2MnICBtZWFucyBieSBjcmVhdGVkQXQgQVNDXG4gICAqICAgJ2Rlc2MnIG1lYW5zIGJ5IHVwZGF0ZWRBdCBERVNDXG4gICAqXG4gICAqIFdpbGwgbmV2ZXIgcmV0dXJuIGRlbGV0ZWQgdGhyZWFkcyBpbiB0aGUgcmVzdWx0LlxuICAgKi9cbiAgZmluZE1hbnkocm9vbUlkLCBxdWVyeSwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaW5kZXggPSBkaXJlY3Rpb24gPT09IFwiZGVzY1wiID8gdGhpcy5fZGVzYyA6IHRoaXMuX2FzYztcbiAgICBjb25zdCBjcml0ID0gW107XG4gICAgaWYgKHJvb21JZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjcml0LnB1c2goKHQpID0+IHQucm9vbUlkID09PSByb29tSWQpO1xuICAgIH1cbiAgICBjcml0LnB1c2gobWFrZVRocmVhZHNGaWx0ZXIocXVlcnkpKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbmRleC5maWx0ZXIoKHQpID0+IGNyaXQuZXZlcnkoKHByZWQpID0+IHByZWQodCkpKSk7XG4gIH1cbiAgLy9cbiAgLy8gUHJpdmF0ZSBBUElzXG4gIC8vXG4gIHRvdWNoKCkge1xuICAgICsrdGhpcy5fdmVyc2lvbjtcbiAgfVxufTtcblxuLy8gc3JjL3VtYnJlbGxhLXN0b3JlLnRzXG5mdW5jdGlvbiBtYWtlUm9vbVRocmVhZHNRdWVyeUtleShyb29tSWQsIHF1ZXJ5KSB7XG4gIHJldHVybiBgJHtyb29tSWR9LSR7c3RyaW5naWZ5KHF1ZXJ5ID8/IHt9KX1gO1xufVxuZnVuY3Rpb24gbWFrZVVzZXJUaHJlYWRzUXVlcnlLZXkocXVlcnkpIHtcbiAgcmV0dXJuIGBVU0VSX1RIUkVBRFM6JHtzdHJpbmdpZnkocXVlcnkgPz8ge30pfWA7XG59XG5mdW5jdGlvbiBtYWtlTm90aWZpY2F0aW9uU2V0dGluZ3NRdWVyeUtleShyb29tSWQpIHtcbiAgcmV0dXJuIGAke3Jvb21JZH06Tk9USUZJQ0FUSU9OX1NFVFRJTkdTYDtcbn1cbmZ1bmN0aW9uIG1ha2VWZXJzaW9uc1F1ZXJ5S2V5KHJvb21JZCkge1xuICByZXR1cm4gYCR7cm9vbUlkfS1WRVJTSU9OU2A7XG59XG5mdW5jdGlvbiB1c2lmeShwcm9taXNlKSB7XG4gIGlmIChcInN0YXR1c1wiIGluIHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBjb25zdCB1c2FibGUgPSBwcm9taXNlO1xuICB1c2FibGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIHVzYWJsZS50aGVuKFxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdXNhYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICB1c2FibGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIHVzYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICB1c2FibGUucmVhc29uID0gZXJyO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzYWJsZTtcbn1cbnZhciBub29wMiA9IFByb21pc2UucmVzb2x2ZSgpO1xudmFyIEFTWU5DX0xPQURJTkcgPSBPYmplY3QuZnJlZXplKHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xudmFyIFBhZ2luYXRlZFJlc291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihmZXRjaFBhZ2UpIHtcbiAgICB0aGlzLl9jYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wYWdpbmF0aW9uU3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX2ZldGNoUGFnZSA9IGZldGNoUGFnZTtcbiAgICB0aGlzLl9ldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICAgIHRoaXMuX3BlbmRpbmdGZXRjaE1vcmUgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2YWJsZSA9IHRoaXMuX2V2ZW50U291cmNlLm9ic2VydmFibGU7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgcGF0Y2hQYWdpbmF0aW9uU3RhdGUocGF0Y2gpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHJldHVybjtcbiAgICB0aGlzLl9wYWdpbmF0aW9uU3RhdGUgPSB7IC4uLnN0YXRlLCAuLi5wYXRjaCB9O1xuICAgIHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICB9XG4gIGFzeW5jIF9mZXRjaE1vcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wYWdpbmF0aW9uU3RhdGU7XG4gICAgaWYgKCFzdGF0ZT8uY3Vyc29yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGF0Y2hQYWdpbmF0aW9uU3RhdGUoeyBpc0ZldGNoaW5nTW9yZTogdHJ1ZSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dEN1cnNvciA9IGF3YWl0IHRoaXMuX2ZldGNoUGFnZShzdGF0ZS5jdXJzb3IpO1xuICAgICAgdGhpcy5wYXRjaFBhZ2luYXRpb25TdGF0ZSh7XG4gICAgICAgIGN1cnNvcjogbmV4dEN1cnNvcixcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHZvaWQgMCxcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMucGF0Y2hQYWdpbmF0aW9uU3RhdGUoe1xuICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2UsXG4gICAgICAgIGZldGNoTW9yZUVycm9yOiBlcnJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmZXRjaE1vcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wYWdpbmF0aW9uU3RhdGU7XG4gICAgaWYgKHN0YXRlPy5jdXJzb3IgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub29wMjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRmV0Y2hNb3JlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRmV0Y2hNb3JlID0gdGhpcy5fZmV0Y2hNb3JlKCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGZXRjaE1vcmUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nRmV0Y2hNb3JlO1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB1c2FibGUgPSB0aGlzLl9jYWNoZWRQcm9taXNlO1xuICAgIGlmICh1c2FibGUgPT09IG51bGwgfHwgdXNhYmxlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHJldHVybiBBU1lOQ19MT0FESU5HO1xuICAgIH1cbiAgICBpZiAodXNhYmxlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICByZXR1cm4geyBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvcjogdXNhYmxlLnJlYXNvbiB9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BhZ2luYXRpb25TdGF0ZTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZmV0Y2hNb3JlOiB0aGlzLmZldGNoTW9yZSxcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IHN0YXRlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogc3RhdGUuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICAgIGhhc0ZldGNoZWRBbGw6IHN0YXRlLmN1cnNvciA9PT0gbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgd2FpdFVudGlsTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEZldGNoZXIgPSBhdXRvUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLl9mZXRjaFBhZ2UoXG4gICAgICAgIC8qIGN1cnNvciAqL1xuICAgICAgICB2b2lkIDBcbiAgICAgICksXG4gICAgICA1LFxuICAgICAgWzVlMywgNWUzLCAxZTQsIDE1ZTNdXG4gICAgKTtcbiAgICBjb25zdCBwcm9taXNlID0gdXNpZnkoXG4gICAgICBpbml0aWFsRmV0Y2hlci50aGVuKChjdXJzb3IpID0+IHtcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvblN0YXRlID0ge1xuICAgICAgICAgIGN1cnNvcixcbiAgICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2UsXG4gICAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICgpID0+IHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9ldmVudFNvdXJjZS5ub3RpZnkoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLl9jYWNoZWRQcm9taXNlID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcbnZhciBTaW5nbGVQYWdlUmVzb3VyY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2ZldGNoUGFnZSA9IGZldGNoUGFnZTtcbiAgICB0aGlzLl9ldmVudFNvdXJjZSA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICAgIHRoaXMub2JzZXJ2YWJsZSA9IHRoaXMuX2V2ZW50U291cmNlLm9ic2VydmFibGU7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHVzYWJsZSA9IHRoaXMuX2NhY2hlZFByb21pc2U7XG4gICAgaWYgKHVzYWJsZSA9PT0gbnVsbCB8fCB1c2FibGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGlmICh1c2FibGUuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgIHJldHVybiB7IGlzTG9hZGluZzogZmFsc2UsIGVycm9yOiB1c2FibGUucmVhc29uIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZGF0YTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRmV0Y2hlciA9IGF1dG9SZXRyeShcbiAgICAgICgpID0+IHRoaXMuX2ZldGNoUGFnZSgpLFxuICAgICAgNSxcbiAgICAgIFs1ZTMsIDVlMywgMWU0LCAxNWUzXVxuICAgICk7XG4gICAgY29uc3QgcHJvbWlzZSA9IHVzaWZ5KGluaXRpYWxGZXRjaGVyKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB0aGlzLl9ldmVudFNvdXJjZS5ub3RpZnkoKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5fZXZlbnRTb3VyY2Uubm90aWZ5KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2NhY2hlZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5fY2FjaGVkUHJvbWlzZSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn07XG52YXIgVW1icmVsbGFTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5fcHJldlZlcnNpb24gPSAtMTtcbiAgICB0aGlzLl9wcmV2U3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlQ2FjaGVkID0gbnVsbDtcbiAgICAvLyBOb3RpZmljYXRpb25zXG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IG51bGw7XG4gICAgLy8gUm9vbSBUaHJlYWRzXG4gICAgdGhpcy5fcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jvb21UaHJlYWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvLyBVc2VyIFRocmVhZHNcbiAgICB0aGlzLl91c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9IG51bGw7XG4gICAgdGhpcy5fdXNlclRocmVhZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIFJvb20gdmVyc2lvbnNcbiAgICB0aGlzLl9yb29tVmVyc2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLy8gUm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3NcbiAgICB0aGlzLl9yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudFtrSW50ZXJuYWxdLmFzKCk7XG4gICAgY29uc3QgaW5ib3hGZXRjaGVyID0gYXN5bmMgKGN1cnNvcikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY2xpZW50LmdldEluYm94Tm90aWZpY2F0aW9ucyh7IGN1cnNvciB9KTtcbiAgICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRDdXJzb3IgPSByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgIHJldHVybiBuZXh0Q3Vyc29yO1xuICAgIH07XG4gICAgdGhpcy5fbm90aWZpY2F0aW9ucyA9IG5ldyBQYWdpbmF0ZWRSZXNvdXJjZShpbmJveEZldGNoZXIpO1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbnMub2JzZXJ2YWJsZS5zdWJzY3JpYmUoXG4gICAgICAoKSA9PiAoXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc3RvcmUgaXRzZWxmIGRvZXMgbm90IGNoYW5nZSwgYnV0IGl0J3Mgb25seSB2ZWhpY2xlIGF0XG4gICAgICAgIC8vIHRoZSBtb21lbnQgdG8gdHJpZ2dlciBhIHJlLXJlbmRlciwgc28gd2UnbGwgZG8gYSBuby1vcCB1cGRhdGUgaGVyZS5cbiAgICAgICAgdGhpcy5fc3RvcmUuc2V0KChzdG9yZSkgPT4gKHsgLi4uc3RvcmUgfSkpXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9yYXdUaHJlYWRzREIgPSBuZXcgVGhyZWFkREIoKTtcbiAgICB0aGlzLl9zdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVzOiBbXSxcbiAgICAgIG5vdGlmaWNhdGlvbnNCeUlkOiB7fSxcbiAgICAgIHNldHRpbmdzQnlSb29tSWQ6IHt9LFxuICAgICAgdmVyc2lvbnNCeVJvb21JZDoge31cbiAgICB9KTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgcmF3U3RhdGUgPSB0aGlzLl9zdG9yZS5nZXQoKTtcbiAgICBpZiAodGhpcy5fcHJldlZlcnNpb24gIT09IHRoaXMuX3Jhd1RocmVhZHNEQi52ZXJzaW9uIHx8IC8vIE5vdGU6IFZlcnNpb24gY2hlY2sgaXMgb25seSBuZWVkZWQgdGVtcG9yYXJpbHksIHVudGlsIHdlIGNhbiBnZXQgcmlkIG9mIHRoZSBadXN0YW5kLWxpa2UgdXBkYXRlIG1vZGVsXG4gICAgdGhpcy5fcHJldlN0YXRlICE9PSByYXdTdGF0ZSB8fCB0aGlzLl9zdGF0ZUNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fc3RhdGVDYWNoZWQgPSBpbnRlcm5hbFRvRXh0ZXJuYWxTdGF0ZShyYXdTdGF0ZSwgdGhpcy5fcmF3VGhyZWFkc0RCKTtcbiAgICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHJhd1N0YXRlO1xuICAgICAgdGhpcy5fcHJldlZlcnNpb24gPSB0aGlzLl9yYXdUaHJlYWRzREIudmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQ2FjaGVkO1xuICB9XG4gIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLmJhdGNoKGNhbGxiYWNrKTtcbiAgfVxuICBnZXRGdWxsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzeW5jIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gcXVlcnkgYW5kIHJvb20gaWQuIElmIHRoZSBxdWVyeSBpcyBzdWNjZXNzLFxuICAgKiB0aGVuIGl0IHdpbGwgcmV0dXJuIHRoZSB0aHJlYWRzIHRoYXQgbWF0Y2ggdGhhdCBwcm92aWRlZCBxdWVyeSBhbmQgcm9vbSBpZC5cbiAgICpcbiAgICovXG4gIGdldFJvb21UaHJlYWRzTG9hZGluZ1N0YXRlKHJvb21JZCwgcXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb21JZCwgcXVlcnkpO1xuICAgIGNvbnN0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fcm9vbVRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jUmVzdWx0ID0gcGFnaW5hdGVkUmVzb3VyY2UuZ2V0KCk7XG4gICAgaWYgKGFzeW5jUmVzdWx0LmlzTG9hZGluZyB8fCBhc3luY1Jlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWRzID0gdGhpcy5nZXRGdWxsU3RhdGUoKS50aHJlYWRzREIuZmluZE1hbnkoXG4gICAgICByb29tSWQsXG4gICAgICBxdWVyeSA/PyB7fSxcbiAgICAgIFwiYXNjXCJcbiAgICApO1xuICAgIGNvbnN0IHBhZ2UgPSBhc3luY1Jlc3VsdC5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdGhyZWFkcyxcbiAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgfTtcbiAgfVxuICBnZXRVc2VyVGhyZWFkc0xvYWRpbmdTdGF0ZShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVVzZXJUaHJlYWRzUXVlcnlLZXkocXVlcnkpO1xuICAgIGNvbnN0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fdXNlclRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIEFTWU5DX0xPQURJTkc7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jUmVzdWx0ID0gcGFnaW5hdGVkUmVzb3VyY2UuZ2V0KCk7XG4gICAgaWYgKGFzeW5jUmVzdWx0LmlzTG9hZGluZyB8fCBhc3luY1Jlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWRzID0gdGhpcy5nZXRGdWxsU3RhdGUoKS50aHJlYWRzREIuZmluZE1hbnkoXG4gICAgICB2b2lkIDAsXG4gICAgICAvLyBEbyBfbm90XyBmaWx0ZXIgYnkgcm9vbUlkXG4gICAgICBxdWVyeSA/PyB7fSxcbiAgICAgIFwiZGVzY1wiXG4gICAgKTtcbiAgICBjb25zdCBwYWdlID0gYXN5bmNSZXN1bHQuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIHRocmVhZHMsXG4gICAgICBoYXNGZXRjaGVkQWxsOiBwYWdlLmhhc0ZldGNoZWRBbGwsXG4gICAgICBpc0ZldGNoaW5nTW9yZTogcGFnZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgZmV0Y2hNb3JlOiBwYWdlLmZldGNoTW9yZVxuICAgIH07XG4gIH1cbiAgLy8gTk9URTogVGhpcyB3aWxsIHJlYWQgdGhlIGFzeW5jIHJlc3VsdCwgYnV0IFdJTEwgTk9UIHN0YXJ0IGxvYWRpbmcgYXQgdGhlIG1vbWVudCFcbiAgZ2V0SW5ib3hOb3RpZmljYXRpb25zTG9hZGluZ1N0YXRlKCkge1xuICAgIGNvbnN0IGFzeW5jUmVzdWx0ID0gdGhpcy5fbm90aWZpY2F0aW9ucy5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2UgPSBhc3luY1Jlc3VsdC5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB0aGlzLmdldEZ1bGxTdGF0ZSgpLmNsZWFuZWROb3RpZmljYXRpb25zLFxuICAgICAgaGFzRmV0Y2hlZEFsbDogcGFnZS5oYXNGZXRjaGVkQWxsLFxuICAgICAgaXNGZXRjaGluZ01vcmU6IHBhZ2UuaXNGZXRjaGluZ01vcmUsXG4gICAgICBmZXRjaE1vcmVFcnJvcjogcGFnZS5mZXRjaE1vcmVFcnJvcixcbiAgICAgIGZldGNoTW9yZTogcGFnZS5mZXRjaE1vcmVcbiAgICB9O1xuICB9XG4gIC8vIE5PVEU6IFRoaXMgd2lsbCByZWFkIHRoZSBhc3luYyByZXN1bHQsIGJ1dCBXSUxMIE5PVCBzdGFydCBsb2FkaW5nIGF0IHRoZSBtb21lbnQhXG4gIGdldE5vdGlmaWNhdGlvblNldHRpbmdzTG9hZGluZ1N0YXRlKHJvb21JZCkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZU5vdGlmaWNhdGlvblNldHRpbmdzUXVlcnlLZXkocm9vbUlkKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuX3Jvb21Ob3RpZmljYXRpb25TZXR0aW5ncy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ3M6IG5uKHRoaXMuZ2V0KCkuc2V0dGluZ3NCeVJvb21JZFtyb29tSWRdKVxuICAgIH07XG4gIH1cbiAgZ2V0Um9vbVZlcnNpb25zTG9hZGluZ1N0YXRlKHJvb21JZCkge1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVZlcnNpb25zUXVlcnlLZXkocm9vbUlkKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuX3Jvb21WZXJzaW9ucy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gQVNZTkNfTE9BRElORztcbiAgICB9XG4gICAgY29uc3QgYXN5bmNSZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICBpZiAoYXN5bmNSZXN1bHQuaXNMb2FkaW5nIHx8IGFzeW5jUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gYXN5bmNSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgdmVyc2lvbnM6IE9iamVjdC52YWx1ZXModGhpcy5nZXQoKS52ZXJzaW9uc0J5Um9vbUlkW3Jvb21JZF0gPz8ge30pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGUgT25seSB1c2VkIGJ5IHRoZSBFMkUgdGVzdCBzdWl0ZS5cbiAgICovXG4gIF9oYXNPcHRpbWlzdGljVXBkYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0KCkub3B0aW1pc3RpY1VwZGF0ZXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfVxuICAvLyBEaXJlY3QgbG93LWxldmVsIGNhY2hlIG11dGF0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHt7e1xuICBtdXRhdGVUaHJlYWRzREIobXV0YXRlKSB7XG4gICAgY29uc3QgZGIgPSB0aGlzLl9yYXdUaHJlYWRzREI7XG4gICAgY29uc3Qgb2xkID0gZGIudmVyc2lvbjtcbiAgICBtdXRhdGUoZGIpO1xuICAgIGlmIChvbGQgIT09IGRiLnZlcnNpb24pIHtcbiAgICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+ICh7IC4uLnN0YXRlIH0pKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUobWFwRm4pIHtcbiAgICB0aGlzLl9zdG9yZS5zZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbnMgPSBtYXBGbihzdGF0ZS5ub3RpZmljYXRpb25zQnlJZCk7XG4gICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25zICE9PSBzdGF0ZS5ub3RpZmljYXRpb25zQnlJZCA/IHsgLi4uc3RhdGUsIG5vdGlmaWNhdGlvbnNCeUlkOiBpbmJveE5vdGlmaWNhdGlvbnMgfSA6IHN0YXRlO1xuICAgIH0pO1xuICB9XG4gIHNldE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zdG9yZS5zZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXR0aW5nc0J5Um9vbUlkOiB7XG4gICAgICAgIC4uLnN0YXRlLnNldHRpbmdzQnlSb29tSWQsXG4gICAgICAgIFtyb29tSWRdOiBzZXR0aW5nc1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICB1cGRhdGVSb29tVmVyc2lvbnMocm9vbUlkLCB2ZXJzaW9ucykge1xuICAgIHRoaXMuX3N0b3JlLnNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHZlcnNpb25zQnlJZCA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgdmVyc2lvbnMubWFwKCh2ZXJzaW9uMikgPT4gW3ZlcnNpb24yLmlkLCB2ZXJzaW9uMl0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHZlcnNpb25zQnlSb29tSWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52ZXJzaW9uc0J5Um9vbUlkLFxuICAgICAgICAgIFtyb29tSWRdOiB7XG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHZlcnNpb25zIGZvciB0aGUgcm9vbSwgb3Igc3RhcnQgd2l0aCBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIC4uLnN0YXRlLnZlcnNpb25zQnlSb29tSWRbcm9vbUlkXSA/PyB7fSxcbiAgICAgICAgICAgIC4uLnZlcnNpb25zQnlJZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVPcHRpbWlzdGljVXBkYXRlc0NhY2hlKG1hcEZuKSB7XG4gICAgdGhpcy5fc3RvcmUuc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZXM6IG1hcEZuKHN0YXRlLm9wdGltaXN0aWNVcGRhdGVzKVxuICAgIH0pKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIH19fVxuICAvKiogQGludGVybmFsIC0gT25seSBjYWxsIHRoaXMgbWV0aG9kIGZyb20gdW5pdCB0ZXN0cy4gKi9cbiAgZm9yY2Vfc2V0KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlLnNldChjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgaW5ib3ggbm90aWZpY2F0aW9uIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGVcbiAgICogY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWYgdGhlIGluYm94IG5vdGlmaWNhdGlvbiBJRCBpc24ndCBmb3VuZCBpblxuICAgKiB0aGUgY2FjaGUuXG4gICAqL1xuICB1cGRhdGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKChjYWNoZSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGNhY2hlW2luYm94Tm90aWZpY2F0aW9uSWRdO1xuICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9ucyA9IHtcbiAgICAgICAgICAuLi5jYWNoZSxcbiAgICAgICAgICBbaW5ib3hOb3RpZmljYXRpb25JZF06IGNhbGxiYWNrKGV4aXN0aW5nKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25zO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgKmFsbCogaW5ib3ggbm90aWZpY2F0aW9ucyBieSBydW5uaW5nIGEgbWFwcGVyIGZ1bmN0aW9uIG92ZXIgYWxsIG9mXG4gICAqIHRoZW0sIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhvcHRpbWlzdGljVXBkYXRlSWQsIG1hcEZuKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKChjYWNoZSkgPT4gbWFwVmFsdWVzKGNhY2hlLCBtYXBGbikpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGluYm94IG5vdGlmaWNhdGlvbiwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nXG4gICAqIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCwgb3B0aW1pc3RpY1VwZGF0ZUlkKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uc0NhY2hlKChjYWNoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IFtpbmJveE5vdGlmaWNhdGlvbklkXTogcmVtb3ZlZCwgLi4ubmV3Q2FjaGUgfSA9IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZCA9PT0gdm9pZCAwID8gY2FjaGUgOiBuZXdDYWNoZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzICphbGwqIGluYm94IG5vdGlmaWNhdGlvbnMsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljXG4gICAqIHVwZGF0ZS5cbiAgICovXG4gIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKCkgPT4gKHt9KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbmV3IHRocmVhZCwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNVcGRhdGVJZCwgdGhyZWFkKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLm11dGF0ZVRocmVhZHNEQigoZGIpID0+IGRiLnVwc2VydCh0aHJlYWQpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyB0aHJlYWQgd2l0aCBhIG5ldyB2YWx1ZSwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nXG4gICAqIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IHVwZGF0ZSBhbnl0aGluZyBpZjpcbiAgICogLSBUaGUgdGhyZWFkIElEIGlzbid0IGZvdW5kIGluIHRoZSBjYWNoZTsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWQgZnJvbSB0aGUgY2FjaGU7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCBpbiB0aGUgY2FjaGUgd2FzIHVwZGF0ZWQgbW9yZSByZWNlbnRseSB0aGFuIHRoZSBvcHRpbWlzdGljXG4gICAqICAgdXBkYXRlJ3MgdGltZXN0YW1wIChpZiBnaXZlbilcbiAgICovXG4gIHVwZGF0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBjYWxsYmFjaywgdXBkYXRlZEF0KSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgaWYgKG9wdGltaXN0aWNVcGRhdGVJZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubXV0YXRlVGhyZWFkc0RCKChkYikgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGRiLmdldCh0aHJlYWRJZCk7XG4gICAgICAgIGlmICghZXhpc3RpbmcpIHJldHVybjtcbiAgICAgICAgaWYgKCEhdXBkYXRlZEF0ICYmIGV4aXN0aW5nLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkgcmV0dXJuO1xuICAgICAgICBkYi51cHNlcnQoY2FsbGJhY2soZXhpc3RpbmcpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHBhdGNoVGhyZWFkKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIHBhdGNoLCB1cGRhdGVkQXQpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+ICh7IC4uLnRocmVhZCwgLi4uY29tcGFjdE9iamVjdChwYXRjaCkgfSksXG4gICAgICB1cGRhdGVkQXRcbiAgICApO1xuICB9XG4gIGFkZFJlYWN0aW9uKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24sIGNyZWF0ZWRBdCkge1xuICAgIHRoaXMudXBkYXRlVGhyZWFkKFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAodGhyZWFkKSA9PiBhcHBseUFkZFJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCByZWFjdGlvbiksXG4gICAgICBjcmVhdGVkQXRcbiAgICApO1xuICB9XG4gIHJlbW92ZVJlYWN0aW9uKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSB7XG4gICAgdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5UmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCksXG4gICAgICByZW1vdmVkQXRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTb2Z0LWRlbGV0ZXMgYW4gZXhpc3RpbmcgdGhyZWFkIGJ5IHNldHRpbmcgaXRzIGBkZWxldGVkQXRgIHZhbHVlLFxuICAgKiByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgdXBkYXRlIGFueXRoaW5nIGlmOlxuICAgKiAtIFRoZSB0aHJlYWQgSUQgaXNuJ3QgZm91bmQgaW4gdGhlIGNhY2hlOyBvclxuICAgKiAtIFRoZSB0aHJlYWQgSUQgd2FzIGFscmVhZHkgZGVsZXRlZCBmcm9tIHRoZSBjYWNoZVxuICAgKi9cbiAgZGVsZXRlVGhyZWFkKHRocmVhZElkLCBvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgIC8vIEEgZGVsZXRpb24gaXMgYWN0dWFsbHkgYW4gdXBkYXRlIG9mIHRoZSBkZWxldGVkQXQgcHJvcGVydHkgaW50ZXJuYWxseVxuICAgICAgKHRocmVhZCkgPT4gKHsgLi4udGhyZWFkLCB1cGRhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleGlzdGluZyBjb21tZW50IGFuZCBlbnN1cmVzIHRoZSBhc3NvY2lhdGVkIG5vdGlmaWNhdGlvbiBpc1xuICAgKiB1cGRhdGVkIGNvcnJlY3RseSwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgY3JlYXRlQ29tbWVudChuZXdDb21tZW50LCBvcHRpbWlzdGljVXBkYXRlSWQpIHtcbiAgICB0aGlzLl9zdG9yZS5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVGhyZWFkID0gdGhpcy5fcmF3VGhyZWFkc0RCLmdldChuZXdDb21tZW50LnRocmVhZElkKTtcbiAgICAgIGlmICghZXhpc3RpbmdUaHJlYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tdXRhdGVUaHJlYWRzREIoXG4gICAgICAgIChkYikgPT4gZGIudXBzZXJ0KGFwcGx5VXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudCkpXG4gICAgICApO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZSgoY2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKGNhY2hlKS5maW5kKFxuICAgICAgICAgIChub3RpZmljYXRpb24pID0+IG5vdGlmaWNhdGlvbi5raW5kID09PSBcInRocmVhZFwiICYmIG5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gbmV3Q29tbWVudC50aHJlYWRJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoIWV4aXN0aW5nTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2FjaGUsXG4gICAgICAgICAgW2V4aXN0aW5nTm90aWZpY2F0aW9uLmlkXToge1xuICAgICAgICAgICAgLi4uZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgICAgICBub3RpZmllZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIHJlYWRBdDogbmV3Q29tbWVudC5jcmVhdGVkQXRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBlZGl0Q29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBlZGl0ZWRDb21tZW50KSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGhyZWFkKFxuICAgICAgdGhyZWFkSWQsXG4gICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAodGhyZWFkKSA9PiBhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBlZGl0ZWRDb21tZW50KVxuICAgICk7XG4gIH1cbiAgZGVsZXRlQ29tbWVudCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkLCBjb21tZW50SWQsIGRlbGV0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpLFxuICAgICAgZGVsZXRlZEF0XG4gICAgKTtcbiAgfVxuICB1cGRhdGVUaHJlYWRBbmROb3RpZmljYXRpb24odGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbikge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubXV0YXRlVGhyZWFkc0RCKChkYikgPT4gZGIudXBzZXJ0SWZOZXdlcih0aHJlYWQpKTtcbiAgICAgIGlmIChpbmJveE5vdGlmaWNhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5ib3hOb3RpZmljYXRpb25zQ2FjaGUoKGNhY2hlKSA9PiAoe1xuICAgICAgICAgIC4uLmNhY2hlLFxuICAgICAgICAgIFtpbmJveE5vdGlmaWNhdGlvbi5pZF06IGluYm94Tm90aWZpY2F0aW9uXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyh0aHJlYWRzLCBpbmJveE5vdGlmaWNhdGlvbnMsIGRlbGV0ZWRUaHJlYWRzID0gW10sIGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSBbXSkge1xuICAgIHRoaXMuX3N0b3JlLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubXV0YXRlVGhyZWFkc0RCKFxuICAgICAgICAoZGIpID0+IGFwcGx5VGhyZWFkRGVsdGFVcGRhdGVzKGRiLCB7IG5ld1RocmVhZHM6IHRocmVhZHMsIGRlbGV0ZWRUaHJlYWRzIH0pXG4gICAgICApO1xuICAgICAgdGhpcy51cGRhdGVJbmJveE5vdGlmaWNhdGlvbnNDYWNoZShcbiAgICAgICAgKGNhY2hlKSA9PiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGNhY2hlLCB7XG4gICAgICAgICAgbmV3SW5ib3hOb3RpZmljYXRpb25zOiBpbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgZGVsZXRlZE5vdGlmaWNhdGlvbnM6IGRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgZXhpc3Rpbmcgbm90aWZpY2F0aW9uIHNldHRpbmcgZm9yIGEgcm9vbSB3aXRoIGEgbmV3IHZhbHVlLFxuICAgKiByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUocm9vbUlkLCBvcHRpbWlzdGljVXBkYXRlSWQsIHNldHRpbmdzKSB7XG4gICAgdGhpcy5fc3RvcmUuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB0aGlzLnNldE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG4gIGFkZE9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZSkge1xuICAgIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gICAgY29uc3QgbmV3VXBkYXRlID0geyAuLi5vcHRpbWlzdGljVXBkYXRlLCBpZCB9O1xuICAgIHRoaXMudXBkYXRlT3B0aW1pc3RpY1VwZGF0ZXNDYWNoZSgoY2FjaGUpID0+IFsuLi5jYWNoZSwgbmV3VXBkYXRlXSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKSB7XG4gICAgdGhpcy51cGRhdGVPcHRpbWlzdGljVXBkYXRlc0NhY2hlKFxuICAgICAgKGNhY2hlKSA9PiBjYWNoZS5maWx0ZXIoKG91KSA9PiBvdS5pZCAhPT0gb3B0aW1pc3RpY1VwZGF0ZUlkKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZmV0Y2hOb3RpZmljYXRpb25zRGVsdGFVcGRhdGUoc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdDtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSh7XG4gICAgICBzaW5jZTogbGFzdFJlcXVlc3RlZEF0LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgIHJlc3VsdC50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICB3YWl0VW50aWxOb3RpZmljYXRpb25zTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3RpZmljYXRpb25zLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIHdhaXRVbnRpbFJvb21UaHJlYWRzTG9hZGVkKHJvb21JZCwgcXVlcnkpIHtcbiAgICBjb25zdCB0aHJlYWRzRmV0Y2hlciA9IGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgIGNvbnN0IHJvb20gPSB0aGlzLl9jbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgaWYgKHJvb20gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihgUm9vbSAnJHtyb29tSWR9JyBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGAsIDQ3OSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb29tLmdldFRocmVhZHMoeyBjdXJzb3IsIHF1ZXJ5IH0pO1xuICAgICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgICAgcmVzdWx0LnRocmVhZHMsXG4gICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICk7XG4gICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPT09IHZvaWQgMCB8fCBsYXN0UmVxdWVzdGVkQXQgPiByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgICAgdGhpcy5fcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb21JZCwgcmVzdWx0LnJlcXVlc3RlZEF0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICB9O1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSk7XG4gICAgbGV0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fcm9vbVRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UodGhyZWFkc0ZldGNoZXIpO1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Jvb21UaHJlYWRzLnNldChxdWVyeUtleSwgcGFnaW5hdGVkUmVzb3VyY2UpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZS53YWl0VW50aWxMb2FkZWQoKTtcbiAgfVxuICBhc3luYyBmZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9yb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vbSA9IG5uKFxuICAgICAgdGhpcy5fY2xpZW50LmdldFJvb20ocm9vbUlkKSxcbiAgICAgIGBSb29tIHdpdGggaWQgJHtyb29tSWR9IGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YFxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVRocmVhZHNBbmROb3RpZmljYXRpb25zKFxuICAgICAgdXBkYXRlcy50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICB1cGRhdGVzLmluYm94Tm90aWZpY2F0aW9ucy51cGRhdGVkLFxuICAgICAgdXBkYXRlcy50aHJlYWRzLmRlbGV0ZWQsXG4gICAgICB1cGRhdGVzLmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgdXBkYXRlcy5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy5fcm9vbVRocmVhZHNMYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb21JZCwgdXBkYXRlcy5yZXF1ZXN0ZWRBdCk7XG4gICAgfVxuICB9XG4gIHdhaXRVbnRpbFVzZXJUaHJlYWRzTG9hZGVkKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSk7XG4gICAgY29uc3QgdGhyZWFkc0ZldGNoZXIgPSBhc3luYyAoY3Vyc29yKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9jbGllbnRba0ludGVybmFsXS5nZXRVc2VyVGhyZWFkc19leHBlcmltZW50YWwoe1xuICAgICAgICBjdXJzb3IsXG4gICAgICAgIHF1ZXJ5XG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlVGhyZWFkc0FuZE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3VzZXJUaHJlYWRzTGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VzZXJUaHJlYWRzTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0Q3Vyc29yO1xuICAgIH07XG4gICAgbGV0IHBhZ2luYXRlZFJlc291cmNlID0gdGhpcy5fdXNlclRocmVhZHMuZ2V0KHF1ZXJ5S2V5KTtcbiAgICBpZiAocGFnaW5hdGVkUmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UodGhyZWFkc0ZldGNoZXIpO1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSZXNvdXJjZS5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICgpID0+IChcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzdG9yZSBpdHNlbGYgZG9lcyBub3QgY2hhbmdlLCBidXQgaXQncyBvbmx5IHZlaGljbGUgYXRcbiAgICAgICAgLy8gdGhlIG1vbWVudCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyLCBzbyB3ZSdsbCBkbyBhIG5vLW9wIHVwZGF0ZSBoZXJlLlxuICAgICAgICB0aGlzLl9zdG9yZS5zZXQoKHN0b3JlKSA9PiAoeyAuLi5zdG9yZSB9KSlcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3VzZXJUaHJlYWRzLnNldChxdWVyeUtleSwgcGFnaW5hdGVkUmVzb3VyY2UpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSZXNvdXJjZS53YWl0VW50aWxMb2FkZWQoKTtcbiAgfVxuICBhc3luYyBmZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9jbGllbnRba0ludGVybmFsXS5nZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbCh7XG4gICAgICBzaW5jZTogbGFzdFJlcXVlc3RlZEF0LFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy5fbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUaHJlYWRzQW5kTm90aWZpY2F0aW9ucyhcbiAgICAgIHJlc3VsdC50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICB3YWl0VW50aWxSb29tVmVyc2lvbnNMb2FkZWQocm9vbUlkKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBtYWtlVmVyc2lvbnNRdWVyeUtleShyb29tSWQpO1xuICAgIGxldCByZXNvdXJjZSA9IHRoaXMuX3Jvb21WZXJzaW9ucy5nZXQocXVlcnlLZXkpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uc0ZldGNoZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLl9jbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IoXG4gICAgICAgICAgICBgUm9vbSAnJHtyb29tSWR9JyBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGAsXG4gICAgICAgICAgICA0NzlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5saXN0VGV4dFZlcnNpb25zKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vbVZlcnNpb25zKHJvb21JZCwgcmVzdWx0LnZlcnNpb25zKTtcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy5fcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLmdldChyb29tSWQpO1xuICAgICAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0ID4gcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICAgICAgdGhpcy5fcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHJlc3VsdC5yZXF1ZXN0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXNvdXJjZSA9IG5ldyBTaW5nbGVQYWdlUmVzb3VyY2UodmVyc2lvbnNGZXRjaGVyKTtcbiAgICB9XG4gICAgcmVzb3VyY2Uub2JzZXJ2YWJsZS5zdWJzY3JpYmUoXG4gICAgICAoKSA9PiAoXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc3RvcmUgaXRzZWxmIGRvZXMgbm90IGNoYW5nZSwgYnV0IGl0J3Mgb25seSB2ZWhpY2xlIGF0XG4gICAgICAgIC8vIHRoZSBtb21lbnQgdG8gdHJpZ2dlciBhIHJlLXJlbmRlciwgc28gd2UnbGwgZG8gYSBuby1vcCB1cGRhdGUgaGVyZS5cbiAgICAgICAgdGhpcy5fc3RvcmUuc2V0KChzdG9yZSkgPT4gKHsgLi4uc3RvcmUgfSkpXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9yb29tVmVyc2lvbnMuc2V0KHF1ZXJ5S2V5LCByZXNvdXJjZSk7XG4gICAgcmV0dXJuIHJlc291cmNlLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIGFzeW5jIGZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLl9yb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCByb29tW2tJbnRlcm5hbF0ubGlzdFRleHRWZXJzaW9uc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVJvb21WZXJzaW9ucyhyb29tSWQsIHVwZGF0ZXMudmVyc2lvbnMpO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCB1cGRhdGVzLnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLl9yb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uc2V0KHJvb21JZCwgdXBkYXRlcy5yZXF1ZXN0ZWRBdCk7XG4gICAgfVxuICB9XG4gIHdhaXRVbnRpbFJvb21Ob3RpZmljYXRpb25TZXR0aW5nc0xvYWRlZChyb29tSWQpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG1ha2VOb3RpZmljYXRpb25TZXR0aW5nc1F1ZXJ5S2V5KHJvb21JZCk7XG4gICAgbGV0IHJlc291cmNlID0gdGhpcy5fcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLmdldChxdWVyeUtleSk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vbSA9IHRoaXMuX2NsaWVudC5nZXRSb29tKHJvb21JZCk7XG4gICAgICAgIGlmIChyb29tID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihcbiAgICAgICAgICAgIGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCxcbiAgICAgICAgICAgIDQ3OVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcm9vbS5nZXROb3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnNldE5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgcmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZXNvdXJjZSA9IG5ldyBTaW5nbGVQYWdlUmVzb3VyY2Uobm90aWZpY2F0aW9uU2V0dGluZ3NGZXRjaGVyKTtcbiAgICB9XG4gICAgcmVzb3VyY2Uub2JzZXJ2YWJsZS5zdWJzY3JpYmUoXG4gICAgICAoKSA9PiAoXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc3RvcmUgaXRzZWxmIGRvZXMgbm90IGNoYW5nZSwgYnV0IGl0J3Mgb25seSB2ZWhpY2xlIGF0XG4gICAgICAgIC8vIHRoZSBtb21lbnQgdG8gdHJpZ2dlciBhIHJlLXJlbmRlciwgc28gd2UnbGwgZG8gYSBuby1vcCB1cGRhdGUgaGVyZS5cbiAgICAgICAgdGhpcy5fc3RvcmUuc2V0KChzdG9yZSkgPT4gKHsgLi4uc3RvcmUgfSkpXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9yb29tTm90aWZpY2F0aW9uU2V0dGluZ3Muc2V0KHF1ZXJ5S2V5LCByZXNvdXJjZSk7XG4gICAgcmV0dXJuIHJlc291cmNlLndhaXRVbnRpbExvYWRlZCgpO1xuICB9XG4gIGFzeW5jIHJlZnJlc2hSb29tTm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCByb29tID0gbm4oXG4gICAgICB0aGlzLl9jbGllbnQuZ2V0Um9vbShyb29tSWQpLFxuICAgICAgYFJvb20gd2l0aCBpZCAke3Jvb21JZH0gaXMgbm90IGF2YWlsYWJsZSBvbiBjbGllbnRgXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByb29tLmdldE5vdGlmaWNhdGlvblNldHRpbmdzKHsgc2lnbmFsIH0pO1xuICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uU2V0dGluZ3Mocm9vbUlkLCByZXN1bHQpO1xuICB9XG59O1xuZnVuY3Rpb24gaW50ZXJuYWxUb0V4dGVybmFsU3RhdGUoc3RhdGUsIHJhd1RocmVhZHNEQikge1xuICBjb25zdCB0aHJlYWRzREIgPSByYXdUaHJlYWRzREIuY2xvbmUoKTtcbiAgY29uc3QgY29tcHV0ZWQgPSB7XG4gICAgbm90aWZpY2F0aW9uc0J5SWQ6IHsgLi4uc3RhdGUubm90aWZpY2F0aW9uc0J5SWQgfSxcbiAgICBzZXR0aW5nc0J5Um9vbUlkOiB7IC4uLnN0YXRlLnNldHRpbmdzQnlSb29tSWQgfVxuICB9O1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygc3RhdGUub3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcImNyZWF0ZS10aHJlYWRcIjoge1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZWRpdC10aHJlYWQtbWV0YWRhdGFcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICBpZiAodGhyZWFkLnVwZGF0ZWRBdCA+IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIHVwZGF0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS51cGRhdGVkQXQsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLnRocmVhZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUubWV0YWRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoeyAuLi50aHJlYWQsIHJlc29sdmVkOiB0cnVlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXJrLXRocmVhZC1hcy11bnJlc29sdmVkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7IC4uLnRocmVhZCwgcmVzb2x2ZWQ6IGZhbHNlIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjcmVhdGUtY29tbWVudFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQpKTtcbiAgICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkXG4gICAgICAgICkuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseURlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIGRlbGV0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFkZC1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoXG4gICAgICAgICAgYXBwbHlBZGRSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZWFjdGlvblxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVtb3ZlLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseVJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlbW92ZWRBdFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIGNvbnN0IGlibiA9IGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGlmIChpYm4gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0gPSB7XG4gICAgICAgICAgLi4uaWJuLFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZCkge1xuICAgICAgICAgIGNvbnN0IGlibiA9IGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW2lkXTtcbiAgICAgICAgICBpZiAoaWJuID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdXRlZC5ub3RpZmljYXRpb25zQnlJZFtpZF0gPSB7XG4gICAgICAgICAgICAuLi5pYm4sXG4gICAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCI6IHtcbiAgICAgICAgZGVsZXRlIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgIGNvbXB1dGVkLm5vdGlmaWNhdGlvbnNCeUlkID0ge307XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGNvbXB1dGVkLnNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkLnNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdID0ge1xuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUuc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY2xlYW5lZE5vdGlmaWNhdGlvbnMgPSAoXG4gICAgLy8gU29ydCBzbyB0aGF0IHRoZSBtb3N0IHJlY2VudCBub3RpZmljYXRpb25zIGFyZSBmaXJzdFxuICAgIE9iamVjdC52YWx1ZXMoY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWQpLmZpbHRlcihcbiAgICAgIChpYm4pID0+IGlibi5raW5kID09PSBcInRocmVhZFwiID8gdGhyZWFkc0RCLmdldChpYm4udGhyZWFkSWQpICE9PSB2b2lkIDAgOiB0cnVlXG4gICAgKS5zb3J0KChhLCBiKSA9PiBiLm5vdGlmaWVkQXQuZ2V0VGltZSgpIC0gYS5ub3RpZmllZEF0LmdldFRpbWUoKSlcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhbmVkTm90aWZpY2F0aW9ucyxcbiAgICBub3RpZmljYXRpb25zQnlJZDogY29tcHV0ZWQubm90aWZpY2F0aW9uc0J5SWQsXG4gICAgc2V0dGluZ3NCeVJvb21JZDogY29tcHV0ZWQuc2V0dGluZ3NCeVJvb21JZCxcbiAgICB0aHJlYWRzREIsXG4gICAgdmVyc2lvbnNCeVJvb21JZDogc3RhdGUudmVyc2lvbnNCeVJvb21JZFxuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlUaHJlYWREZWx0YVVwZGF0ZXMoZGIsIHVwZGF0ZXMpIHtcbiAgdXBkYXRlcy5uZXdUaHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4gZGIudXBzZXJ0SWZOZXdlcih0aHJlYWQpKTtcbiAgdXBkYXRlcy5kZWxldGVkVGhyZWFkcy5mb3JFYWNoKCh7IGlkLCBkZWxldGVkQXQgfSkgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gZGIuZ2V0RXZlbklmRGVsZXRlZChpZCk7XG4gICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgIGRiLmRlbGV0ZShpZCwgZGVsZXRlZEF0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvbnNVcGRhdGVzKGV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zLCB1cGRhdGVzKSB7XG4gIGNvbnN0IHVwZGF0ZWRJbmJveE5vdGlmaWNhdGlvbnMgPSB7IC4uLmV4aXN0aW5nSW5ib3hOb3RpZmljYXRpb25zIH07XG4gIHVwZGF0ZXMubmV3SW5ib3hOb3RpZmljYXRpb25zLmZvckVhY2goKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgIGNvbnN0IGV4aXN0aW5nTm90aWZpY2F0aW9uID0gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdO1xuICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgZXhpc3RpbmdOb3RpZmljYXRpb24sXG4gICAgICAgIG5vdGlmaWNhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlZEluYm94Tm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdID0gbm90aWZpY2F0aW9uO1xuICB9KTtcbiAgdXBkYXRlcy5kZWxldGVkTm90aWZpY2F0aW9ucy5mb3JFYWNoKFxuICAgICh7IGlkIH0pID0+IGRlbGV0ZSB1cGRhdGVkSW5ib3hOb3RpZmljYXRpb25zW2lkXVxuICApO1xuICByZXR1cm4gdXBkYXRlZEluYm94Tm90aWZpY2F0aW9ucztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmJveE5vdGlmaWNhdGlvbnMoaW5ib3hOb3RpZmljYXRpb25BLCBpbmJveE5vdGlmaWNhdGlvbkIpIHtcbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEubm90aWZpZWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5ub3RpZmllZEF0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ICYmIGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA+IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAxIDogaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQgPyAtMSA6IDA7XG4gIH0gZWxzZSBpZiAoaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCB8fCBpbmJveE5vdGlmaWNhdGlvbkIucmVhZEF0KSB7XG4gICAgcmV0dXJuIGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcHBseVVwc2VydENvbW1lbnQodGhyZWFkLCBjb21tZW50KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChjb21tZW50LnRocmVhZElkICE9PSB0aHJlYWQuaWQpIHtcbiAgICBjb25zb2xlMi53YXJuKFxuICAgICAgYENvbW1lbnQgJHtjb21tZW50LmlkfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhyZWFkICR7dGhyZWFkLmlkfWBcbiAgICApO1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGV4aXN0aW5nQ29tbWVudDIpID0+IGV4aXN0aW5nQ29tbWVudDIuaWQgPT09IGNvbW1lbnQuaWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoXG4gICAgICBNYXRoLm1heCh0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlZFRocmVhZCA9IHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIGNvbW1lbnRzOiBbLi4udGhyZWFkLmNvbW1lbnRzLCBjb21tZW50XVxuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGNvbW1lbnQuZWRpdGVkQXQgPT09IHZvaWQgMCB8fCBleGlzdGluZ0NvbW1lbnQuZWRpdGVkQXQgPD0gY29tbWVudC5lZGl0ZWRBdCkge1xuICAgIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZCA/IGNvbW1lbnQgOiBleGlzdGluZ0NvbW1lbnQyXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCksXG4gICAgICAgICAgY29tbWVudC5lZGl0ZWRBdD8uZ2V0VGltZSgpIHx8IGNvbW1lbnQuY3JlYXRlZEF0LmdldFRpbWUoKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZWRUaHJlYWQ7XG4gIH1cbiAgcmV0dXJuIHRocmVhZDtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVsZXRlQ29tbWVudCh0aHJlYWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gIGlmICh0aHJlYWQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29tbWVudCA9IHRocmVhZC5jb21tZW50cy5maW5kKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKGV4aXN0aW5nQ29tbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCB1cGRhdGVkQ29tbWVudHMgPSB0aHJlYWQuY29tbWVudHMubWFwKFxuICAgIChjb21tZW50KSA9PiBjb21tZW50LmlkID09PSBjb21tZW50SWQgPyB7XG4gICAgICAuLi5jb21tZW50LFxuICAgICAgZGVsZXRlZEF0LFxuICAgICAgLy8gV2Ugb3B0aW1pc3RpY2FsbHkgcmVtb3ZlIHRoZSBjb21tZW50IGJvZHkgYW5kIGF0dGFjaG1lbnRzIHdoZW4gbWFya2luZyBpdCBhcyBkZWxldGVkXG4gICAgICBib2R5OiB2b2lkIDAsXG4gICAgICBhdHRhY2htZW50czogW11cbiAgICB9IDogY29tbWVudFxuICApO1xuICBpZiAodXBkYXRlZENvbW1lbnRzLmV2ZXJ5KChjb21tZW50KSA9PiBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBkZWxldGVkQXQsXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IHVwc2VydFJlYWN0aW9uKGNvbW1lbnQucmVhY3Rpb25zLCByZWFjdGlvbilcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVhY3Rpb24uY3JlYXRlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseVJlbW92ZVJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCBlbW9qaSwgdXNlcklkLCByZW1vdmVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICByZWFjdGlvbnM6IGNvbW1lbnQucmVhY3Rpb25zLm1hcChcbiAgICAgICAgKHJlYWN0aW9uKSA9PiByZWFjdGlvbi5lbW9qaSA9PT0gZW1vamkgPyB7XG4gICAgICAgICAgLi4ucmVhY3Rpb24sXG4gICAgICAgICAgdXNlcnM6IHJlYWN0aW9uLnVzZXJzLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gdXNlcklkKVxuICAgICAgICB9IDogcmVhY3Rpb25cbiAgICAgICkuZmlsdGVyKChyZWFjdGlvbikgPT4gcmVhY3Rpb24udXNlcnMubGVuZ3RoID4gMClcbiAgICAgIC8vIFJlbW92ZSByZWFjdGlvbnMgd2l0aCBubyB1c2VycyBsZWZ0XG4gICAgfSA6IGNvbW1lbnRcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50aHJlYWQsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHJlbW92ZWRBdC5nZXRUaW1lKCksIHRocmVhZC51cGRhdGVkQXQuZ2V0VGltZSgpKVxuICAgICksXG4gICAgY29tbWVudHM6IHVwZGF0ZWRDb21tZW50c1xuICB9O1xufVxuZnVuY3Rpb24gdXBzZXJ0UmVhY3Rpb24ocmVhY3Rpb25zLCByZWFjdGlvbikge1xuICBjb25zdCBleGlzdGluZ1JlYWN0aW9uID0gcmVhY3Rpb25zLmZpbmQoXG4gICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamlcbiAgKTtcbiAgaWYgKGV4aXN0aW5nUmVhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXG4gICAgICAuLi5yZWFjdGlvbnMsXG4gICAgICB7XG4gICAgICAgIGVtb2ppOiByZWFjdGlvbi5lbW9qaSxcbiAgICAgICAgY3JlYXRlZEF0OiByZWFjdGlvbi5jcmVhdGVkQXQsXG4gICAgICAgIHVzZXJzOiBbeyBpZDogcmVhY3Rpb24udXNlcklkIH1dXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBpZiAoZXhpc3RpbmdSZWFjdGlvbi51c2Vycy5zb21lKCh1c2VyKSA9PiB1c2VyLmlkID09PSByZWFjdGlvbi51c2VySWQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiByZWFjdGlvbnMubWFwKFxuICAgICAgKGV4aXN0aW5nUmVhY3Rpb24yKSA9PiBleGlzdGluZ1JlYWN0aW9uMi5lbW9qaSA9PT0gcmVhY3Rpb24uZW1vamkgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nUmVhY3Rpb24yLFxuICAgICAgICB1c2VyczogWy4uLmV4aXN0aW5nUmVhY3Rpb24yLnVzZXJzLCB7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH0gOiBleGlzdGluZ1JlYWN0aW9uMlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0aW9ucztcbn1cblxuLy8gc3JjL2xpdmVibG9ja3MudHN4XG52YXIgQ2xpZW50Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKG51bGwpO1xuZnVuY3Rpb24gbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgcmVzb2x2ZVVzZXJzIGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZm9yIHVzZXIgJyR7dXNlcklkfSdgKTtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdSb29tSW5mb0Vycm9yKHJvb21JZCkge1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGByZXNvbHZlUm9vbXNJbmZvIGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZm9yIHJvb20gJyR7cm9vbUlkfSdgXG4gICk7XG59XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxudmFyIF91bWJyZWxsYVN0b3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9leHRyYXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2VsZWN0VW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3Qgbm90aWZpY2F0aW9uIG9mIGluYm94Tm90aWZpY2F0aW9ucykge1xuICAgIGlmIChub3RpZmljYXRpb24ucmVhZEF0ID09PSBudWxsIHx8IG5vdGlmaWNhdGlvbi5yZWFkQXQgPCBub3RpZmljYXRpb24ubm90aWZpZWRBdCkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIGNvdW50OiBzZWxlY3RVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChyZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlVXNlcihzdGF0ZSwgdXNlcklkKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCFzdGF0ZS5kYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXNlcjogc3RhdGUuZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlUm9vbUluZm8oc3RhdGUsIHJvb21JZCkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghc3RhdGUuZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG1pc3NpbmdSb29tSW5mb0Vycm9yKHJvb21JZClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBpbmZvOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGxldCBidW5kbGUgPSBfYnVuZGxlcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFidW5kbGUpIHtcbiAgICBidW5kbGUgPSBtYWtlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoY2xpZW50KTtcbiAgICBfYnVuZGxlcy5zZXQoY2xpZW50LCBidW5kbGUpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCkge1xuICBsZXQgc3RvcmUgPSBfdW1icmVsbGFTdG9yZXMuZ2V0KGNsaWVudCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICBzdG9yZSA9IG5ldyBVbWJyZWxsYVN0b3JlKGNsaWVudCk7XG4gICAgX3VtYnJlbGxhU3RvcmVzLnNldChjbGllbnQsIHN0b3JlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBsZXQgZXh0cmFzID0gX2V4dHJhcy5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlTGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIF9leHRyYXMuc2V0KGNsaWVudCwgZXh0cmFzKTtcbiAgfVxuICByZXR1cm4gZXh0cmFzO1xufVxuZnVuY3Rpb24gbWFrZUxpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBub3RpZmljYXRpb25zUG9sbGVyID0gbWFrZVBvbGxlcihcbiAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUuZmV0Y2hOb3RpZmljYXRpb25zRGVsdGFVcGRhdGUoc2lnbmFsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFBvbGxpbmcgbmV3IGluYm94IG5vdGlmaWNhdGlvbnMgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maWcuTk9USUZJQ0FUSU9OU19QT0xMX0lOVEVSVkFMLFxuICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5OT1RJRklDQVRJT05TX01BWF9TVEFMRV9USU1FIH1cbiAgKTtcbiAgY29uc3QgdXNlclRocmVhZHNQb2xsZXIgPSBtYWtlUG9sbGVyKFxuICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoc2lnbmFsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFBvbGxpbmcgbmV3IHVzZXIgdGhyZWFkcyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZy5VU0VSX1RIUkVBRFNfUE9MTF9JTlRFUlZBTCxcbiAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuVVNFUl9USFJFQURTX01BWF9TVEFMRV9USU1FIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9yZSxcbiAgICBub3RpZmljYXRpb25zUG9sbGVyLFxuICAgIHVzZXJUaHJlYWRzUG9sbGVyXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMiA9IChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIGNvbnN0IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIgPSAoKSA9PiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIgPSAoKSA9PiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIgPSAoKSA9PiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpO1xuICBmdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIyKHByb3BzKSB7XG4gICAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIoKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudCB9LCBwcm9wcy5jaGlsZHJlbik7XG4gIH1cbiAgY29uc3Qgc2hhcmVkID0gY3JlYXRlU2hhcmVkQ29udGV4dChjbGllbnQpO1xuICBjb25zdCBidW5kbGUgPSB7XG4gICAgTGl2ZWJsb2Nrc1Byb3ZpZGVyOiBMaXZlYmxvY2tzUHJvdmlkZXIyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uczogKCkgPT4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBpZGVudGl0eSwgc2hhbGxvdzMpLFxuICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQyLFxuICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uOiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIsXG4gICAgdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zOiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICAgIC4uLnNoYXJlZC5jbGFzc2ljLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6ICgpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMixcbiAgICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICAgIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgICB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWw6IHVzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsLFxuICAgICAgLi4uc2hhcmVkLnN1c3BlbnNlXG4gICAgfVxuICB9O1xuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50LCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCB7IHN0b3JlLCBub3RpZmljYXRpb25zUG9sbGVyOiBwb2xsZXIgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgdm9pZCBzdG9yZS53YWl0VW50aWxOb3RpZmljYXRpb25zTG9hZGVkKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgc3RvcmUuZ2V0SW5ib3hOb3RpZmljYXRpb25zTG9hZGluZ1N0YXRlLFxuICAgIHN0b3JlLmdldEluYm94Tm90aWZpY2F0aW9uc0xvYWRpbmdTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCwgaWRlbnRpdHksIHNoYWxsb3czKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KFxuICAgIGNsaWVudCxcbiAgICBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCxcbiAgICBzaGFsbG93M1xuICApO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLndhaXRVbnRpbE5vdGlmaWNhdGlvbnNMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQoY2xpZW50KTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoXG4gICAgKGluYm94Tm90aWZpY2F0aW9uSWQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHJlYWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICByZWFkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUudXBkYXRlSW5ib3hOb3RpZmljYXRpb24oXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiAoeyAuLi5pbmJveE5vdGlmaWNhdGlvbiwgcmVhZEF0IH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnJlbW92ZU9wdGltaXN0aWNVcGRhdGUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCIsXG4gICAgICByZWFkQXRcbiAgICB9KTtcbiAgICBjbGllbnQubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnVwZGF0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uKSA9PiAoeyAuLi5pbmJveE5vdGlmaWNhdGlvbiwgcmVhZEF0IH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQsXG4gICAgICAgIGRlbGV0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnQuZGVsZXRlSW5ib3hOb3RpZmljYXRpb24oaW5ib3hOb3RpZmljYXRpb25JZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLWFsbC1pbmJveC1ub3RpZmljYXRpb25zXCIsXG4gICAgICBkZWxldGVkQXRcbiAgICB9KTtcbiAgICBjbGllbnQuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUuZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVPcHRpbWlzdGljVXBkYXRlKG9wdGltaXN0aWNVcGRhdGVJZCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW2NsaWVudF0pO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChjbGllbnQsIGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBnZXR0ZXIgPSBzdG9yZS5nZXRGdWxsU3RhdGU7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBzdGF0ZS5ub3RpZmljYXRpb25zQnlJZFtpbmJveE5vdGlmaWNhdGlvbklkXSA/PyByYWlzZShgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgbm90IGZvdW5kYCk7XG4gICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24ua2luZCAhPT0gXCJ0aHJlYWRcIikge1xuICAgICAgICByYWlzZShcbiAgICAgICAgICBgSW5ib3ggbm90aWZpY2F0aW9uIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uSWR9XCIgaXMgbm90IG9mIGtpbmQgXCJ0aHJlYWRcImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRocmVhZCA9IHN0YXRlLnRocmVhZHNEQi5nZXQoaW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWQpID8/IHJhaXNlKFxuICAgICAgICBgVGhyZWFkIHdpdGggSUQgXCIke2luYm94Tm90aWZpY2F0aW9uLnRocmVhZElkfVwiIG5vdCBmb3VuZCwgdGhpcyBpbmJveCBub3RpZmljYXRpb24gbWlnaHQgbm90IGJlIG9mIGtpbmQgXCJ0aHJlYWRcImBcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhyZWFkO1xuICAgIH0sXG4gICAgW2luYm94Tm90aWZpY2F0aW9uSWRdXG4gICk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgLy8gUmUtZXZhbHVhdGUgaWYgd2UgbmVlZCB0byB1cGRhdGUgYW55IHRpbWUgdGhlIG5vdGlmaWNhdGlvbiBjaGFuZ2VzIG92ZXIgdGltZVxuICAgIGdldHRlcixcbiAgICBnZXR0ZXIsXG4gICAgc2VsZWN0b3JcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnVzZXJzU3RvcmU7XG4gIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiB1c2Vyc1N0b3JlLmdldFN0YXRlKHVzZXJJZCksXG4gICAgW3VzZXJzU3RvcmUsIHVzZXJJZF1cbiAgKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VVc2VyKHN0YXRlLCB1c2VySWQpLFxuICAgIFt1c2VySWRdXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHVzZXJzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBnZXRVc2VyU3RhdGUsXG4gICAgc2VsZWN0b3IsXG4gICAgc2hhbGxvdzNcbiAgKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgdm9pZCB1c2Vyc1N0b3JlLmdldCh1c2VySWQpO1xuICB9LCBbdXNlcnNTdG9yZSwgdXNlcklkLCByZXN1bHRdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSB7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0udXNlcnNTdG9yZTtcbiAgY29uc3QgZ2V0VXNlclN0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHVzZXJzU3RvcmUuZ2V0U3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICBjb25zdCB1c2VyU3RhdGUgPSBnZXRVc2VyU3RhdGUoKTtcbiAgaWYgKCF1c2VyU3RhdGUgfHwgdXNlclN0YXRlLmlzTG9hZGluZykge1xuICAgIHRocm93IHVzZXJzU3RvcmUuZ2V0KHVzZXJJZCk7XG4gIH1cbiAgaWYgKHVzZXJTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHVzZXJTdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIXVzZXJTdGF0ZS5kYXRhKSB7XG4gICAgdGhyb3cgbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIGdldFVzZXJTdGF0ZVxuICApO1xuICBhc3NlcnQoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0KCFzdGF0ZS5lcnJvciwgXCJVbmV4cGVjdGVkIGVycm9yIHN0YXRlXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXNlcjogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb193aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSB7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnJvb21zSW5mb1N0b3JlO1xuICBjb25zdCBnZXRSb29tSW5mb1N0YXRlID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHJvb21zSW5mb1N0b3JlLmdldFN0YXRlKHJvb21JZCksXG4gICAgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdXG4gICk7XG4gIGNvbnN0IHNlbGVjdG9yID0gdXNlQ2FsbGJhY2syKFxuICAgIChzdGF0ZSkgPT4gc2VsZWN0b3JGb3JfdXNlUm9vbUluZm8oc3RhdGUsIHJvb21JZCksXG4gICAgW3Jvb21JZF1cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgcm9vbXNJbmZvU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFJvb21JbmZvU3RhdGUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBzaGFsbG93M1xuICApO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICB2b2lkIHJvb21zSW5mb1N0b3JlLmdldChyb29tSWQpO1xuICB9LCBbcm9vbXNJbmZvU3RvcmUsIHJvb21JZCwgcmVzdWx0XSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpIHtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0ucm9vbXNJbmZvU3RvcmU7XG4gIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gcm9vbXNJbmZvU3RvcmUuZ2V0U3RhdGUocm9vbUlkKSxcbiAgICBbcm9vbXNJbmZvU3RvcmUsIHJvb21JZF1cbiAgKTtcbiAgY29uc3Qgcm9vbUluZm9TdGF0ZSA9IGdldFJvb21JbmZvU3RhdGUoKTtcbiAgaWYgKCFyb29tSW5mb1N0YXRlIHx8IHJvb21JbmZvU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgcm9vbXNJbmZvU3RvcmUuZ2V0KHJvb21JZCk7XG4gIH1cbiAgaWYgKHJvb21JbmZvU3RhdGUuZXJyb3IpIHtcbiAgICB0aHJvdyByb29tSW5mb1N0YXRlLmVycm9yO1xuICB9XG4gIGlmICghcm9vbUluZm9TdGF0ZS5kYXRhKSB7XG4gICAgdGhyb3cgbWlzc2luZ1Jvb21JbmZvRXJyb3Iocm9vbUlkKTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIGdldFJvb21JbmZvU3RhdGVcbiAgKTtcbiAgYXNzZXJ0KHN0YXRlICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuZXJyb3IsIFwiVW5leHBlY3RlZCBlcnJvciBzdGF0ZVwiKTtcbiAgYXNzZXJ0KHN0YXRlLmRhdGEgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgcm9vbSBpbmZvIGRhdGFcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBpbmZvOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUNsaWVudDIgPSAoKSA9PiBjbGllbnQ7XG4gIHJldHVybiB7XG4gICAgY2xhc3NpYzoge1xuICAgICAgdXNlQ2xpZW50OiB1c2VDbGllbnQyLFxuICAgICAgdXNlVXNlcjogKHVzZXJJZCkgPT4gdXNlVXNlcl93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSxcbiAgICAgIHVzZVJvb21JbmZvOiAocm9vbUlkKSA9PiB1c2VSb29tSW5mb193aXRoQ2xpZW50KGNsaWVudCwgcm9vbUlkKSxcbiAgICAgIHVzZUlzSW5zaWRlUm9vbVxuICAgIH0sXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIHVzZUNsaWVudDogdXNlQ2xpZW50MixcbiAgICAgIHVzZVVzZXI6ICh1c2VySWQpID0+IHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKSxcbiAgICAgIHVzZVJvb21JbmZvOiAocm9vbUlkKSA9PiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIob3B0aW9ucykge1xuICBjb25zdCBleGlzdGluZyA9IHVzZUNsaWVudE9yTnVsbCgpO1xuICBpZiAoIW9wdGlvbnM/LmFsbG93TmVzdGluZyAmJiBleGlzdGluZyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbm5vdCBuZXN0IG11bHRpcGxlIExpdmVibG9ja3NQcm92aWRlciBpbnN0YW5jZXMgaW4gdGhlIHNhbWUgUmVhY3QgdHJlZS5cIlxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUNsaWVudE9yTnVsbCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQyKENsaWVudENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlQ2xpZW50KCkge1xuICByZXR1cm4gdXNlQ2xpZW50T3JOdWxsKCkgPz8gcmFpc2UoXCJMaXZlYmxvY2tzUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbn1cbmZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQocHJvcHMpIHtcbiAgdXNlRW5zdXJlTm9MaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb3BzLmNsaWVudCB9LCBwcm9wcy5jaGlsZHJlbik7XG59XG5mdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ubyB9ID0gcHJvcHM7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgcHVibGljQXBpS2V5OiB1c2VJbml0aWFsKG8ucHVibGljQXBpS2V5KSxcbiAgICB0aHJvdHRsZTogdXNlSW5pdGlhbChvLnRocm90dGxlKSxcbiAgICBsb3N0Q29ubmVjdGlvblRpbWVvdXQ6IHVzZUluaXRpYWwoby5sb3N0Q29ubmVjdGlvblRpbWVvdXQpLFxuICAgIGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0OiB1c2VJbml0aWFsKG8uYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQpLFxuICAgIHBvbHlmaWxsczogdXNlSW5pdGlhbChvLnBvbHlmaWxscyksXG4gICAgdW5zdGFibGVfZmFsbGJhY2tUb0hUVFA6IHVzZUluaXRpYWwoby51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCksXG4gICAgdW5zdGFibGVfc3RyZWFtRGF0YTogdXNlSW5pdGlhbChvLnVuc3RhYmxlX3N0cmVhbURhdGEpLFxuICAgIGF1dGhFbmRwb2ludDogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8uYXV0aEVuZHBvaW50KSxcbiAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oXG4gICAgICBvLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICApLFxuICAgIHJlc29sdmVVc2VyczogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8ucmVzb2x2ZVVzZXJzKSxcbiAgICByZXNvbHZlUm9vbXNJbmZvOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5yZXNvbHZlUm9vbXNJbmZvKSxcbiAgICBiYXNlVXJsOiB1c2VJbml0aWFsKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEhpZGRlbiBjb25maWcgb3B0aW9uc1xuICAgICAgby5iYXNlVXJsXG4gICAgKSxcbiAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmVuYWJsZURlYnVnTG9nZ2luZ1xuICAgIClcbiAgfTtcbiAgY29uc3QgY2xpZW50ID0gdXNlTWVtbygoKSA9PiBjcmVhdGVDbGllbnQob3B0aW9ucyksIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChMaXZlYmxvY2tzUHJvdmlkZXJXaXRoQ2xpZW50LCB7IGNsaWVudCB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBjcmVhdGVMaXZlYmxvY2tzQ29udGV4dChjbGllbnQpIHtcbiAgcmV0dXJuIGdldE9yQ3JlYXRlQ29udGV4dEJ1bmRsZShjbGllbnQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsKG9wdGlvbnMgPSB7XG4gIHF1ZXJ5OiB7XG4gICAgbWV0YWRhdGE6IHt9XG4gIH1cbn0pIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgc3RvcmUsIHVzZXJUaHJlYWRzUG9sbGVyOiBwb2xsZXIgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgdXNlRWZmZWN0MihcbiAgICAoKSA9PiB7XG4gICAgICB2b2lkIHN0b3JlLndhaXRVbnRpbFVzZXJUaHJlYWRzTG9hZGVkKG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9sbGVyLmRlYygpO1xuICAgIH07XG4gIH0sIFtwb2xsZXJdKTtcbiAgY29uc3QgZ2V0dGVyID0gdXNlQ2FsbGJhY2syKFxuICAgICgpID0+IHN0b3JlLmdldFVzZXJUaHJlYWRzTG9hZGluZ1N0YXRlKG9wdGlvbnMucXVlcnkpLFxuICAgIFtzdG9yZSwgb3B0aW9ucy5xdWVyeV1cbiAgKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5LFxuICAgIHNoYWxsb3cyXG4gICAgLy8gTk9URTogVXNpbmcgMi1sZXZlbC1kZWVwIHNoYWxsb3cgY2hlY2sgaGVyZSwgYmVjYXVzZSB0aGUgcmVzdWx0IG9mIHNlbGVjdFRocmVhZHMoKSBpcyBub3Qgc3RhYmxlIVxuICApO1xufVxuZnVuY3Rpb24gdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwob3B0aW9ucyA9IHtcbiAgcXVlcnk6IHtcbiAgICBtZXRhZGF0YToge31cbiAgfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsVXNlclRocmVhZHNMb2FkZWQob3B0aW9ucy5xdWVyeSkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyk7XG4gIGFzc2VydCghcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCBpZGVudGl0eSwgc2hhbGxvdzMpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZV93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoXG4gICAgdXNlQ2xpZW50KCksXG4gICAgaW5ib3hOb3RpZmljYXRpb25JZFxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoKSB7XG4gIHJldHVybiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gIHJldHVybiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbigpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2UoKSB7XG4gIHJldHVybiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9fd2l0aENsaWVudCh1c2VDbGllbnQoKSwgcm9vbUlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gIHJldHVybiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG52YXIgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkID0gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ7XG52YXIgX3VzZVVzZXIgPSB1c2VVc2VyO1xudmFyIF91c2VVc2VyU3VzcGVuc2UgPSB1c2VVc2VyU3VzcGVuc2U7XG52YXIgX3VzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCA9IHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDtcbnZhciBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwgPSB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbDtcblxuLy8gc3JjL3R5cGVzL2Vycm9ycy50c1xudmFyIENyZWF0ZVRocmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgdGhyZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDcmVhdGVUaHJlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIERlbGV0ZVRocmVhZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgdGhyZWFkIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJEZWxldGVUaHJlYWRFcnJvclwiO1xuICB9XG59O1xudmFyIEVkaXRUaHJlYWRNZXRhZGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJFZGl0IHRocmVhZCBtZXRhZGF0YSBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRWRpdFRocmVhZE1ldGFkYXRhRXJyb3JcIjtcbiAgfVxufTtcbnZhciBNYXJrVGhyZWFkQXNSZXNvbHZlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJNYXJrIHRocmVhZCBhcyByZXNvbHZlZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTWFya1RocmVhZEFzUmVzb2x2ZWRFcnJvclwiO1xuICB9XG59O1xudmFyIE1hcmtUaHJlYWRBc1VucmVzb2x2ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiTWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTWFya1RocmVhZEFzVW5yZXNvbHZlZEVycm9yXCI7XG4gIH1cbn07XG52YXIgQ3JlYXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJDcmVhdGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiQ3JlYXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRWRpdENvbW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiRWRpdCBjb21tZW50IGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJFZGl0Q29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgRGVsZXRlQ29tbWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoXCJEZWxldGUgY29tbWVudCBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiRGVsZXRlQ29tbWVudEVycm9yXCI7XG4gIH1cbn07XG52YXIgQWRkUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiQWRkIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJBZGRSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgUmVtb3ZlUmVhY3Rpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiUmVtb3ZlIHJlYWN0aW9uIGZhaWxlZC5cIik7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5uYW1lID0gXCJSZW1vdmVSZWFjdGlvbkVycm9yXCI7XG4gIH1cbn07XG52YXIgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIGNvbnRleHQpIHtcbiAgICBzdXBlcihcIk1hcmsgaW5ib3ggbm90aWZpY2F0aW9uIGFzIHJlYWQgZmFpbGVkLlwiKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm5hbWUgPSBcIk1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZEVycm9yXCI7XG4gIH1cbn07XG52YXIgVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSwgY29udGV4dCkge1xuICAgIHN1cGVyKFwiVXBkYXRlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmYWlsZWQuXCIpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3NFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvcm9vbS50c3hcbmltcG9ydCB7IHNoYWxsb3cgYXMgc2hhbGxvdzQgfSBmcm9tIFwiQGxpdmVibG9ja3MvY2xpZW50XCI7XG5pbXBvcnQge1xuICBhc3NlcnQgYXMgYXNzZXJ0MixcbiAgY29uc29sZSBhcyBjb25zb2xlMyxcbiAgY3JlYXRlQ29tbWVudElkLFxuICBjcmVhdGVUaHJlYWRJZCxcbiAgZGVwcmVjYXRlSWYsXG4gIGVycm9ySWYsXG4gIEh0dHBFcnJvciBhcyBIdHRwRXJyb3IyLFxuICBrSW50ZXJuYWwgYXMga0ludGVybmFsMyxcbiAgbWFrZUV2ZW50U291cmNlIGFzIG1ha2VFdmVudFNvdXJjZTIsXG4gIG1ha2VQb2xsZXIgYXMgbWFrZVBvbGxlcjIsXG4gIFNlcnZlck1zZ0NvZGVcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCAqIGFzIFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanNcIjtcblxuLy8gc3JjL3VzZS1zY3JvbGwtdG8tY29tbWVudC1vbi1sb2FkLWVmZmVjdC50c1xuaW1wb3J0ICogYXMgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsVG9Db21tZW50T25Mb2FkKHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgaWYgKHNob3VsZFNjcm9sbE9uTG9hZCA9PT0gZmFsc2UpIHJldHVybjtcbiAgaWYgKCFzdGF0ZS50aHJlYWRzKSByZXR1cm47XG4gIGNvbnN0IGlzV2luZG93RGVmaW5lZCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmICghaXNXaW5kb3dEZWZpbmVkKSByZXR1cm47XG4gIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgY29uc3QgY29tbWVudElkID0gaGFzaC5zbGljZSgxKTtcbiAgaWYgKCFjb21tZW50SWQuc3RhcnRzV2l0aChcImNtX1wiKSkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29tbWVudElkKTtcbiAgaWYgKGNvbW1lbnQgPT09IG51bGwpIHJldHVybjtcbiAgY29uc3QgY29tbWVudHMgPSBzdGF0ZS50aHJlYWRzLmZsYXRNYXAoKHRocmVhZCkgPT4gdGhyZWFkLmNvbW1lbnRzKTtcbiAgY29uc3QgaXNDb21tZW50SW5UaHJlYWRzID0gY29tbWVudHMuc29tZShcbiAgICAoY29tbWVudDIpID0+IGNvbW1lbnQyLmlkID09PSBjb21tZW50SWRcbiAgKTtcbiAgaWYgKCFpc0NvbW1lbnRJblRocmVhZHMpIHJldHVybjtcbiAgY29tbWVudC5zY3JvbGxJbnRvVmlldygpO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9Db21tZW50T25Mb2FkRWZmZWN0KHNob3VsZFNjcm9sbE9uTG9hZCwgc3RhdGUpIHtcbiAgUmVhY3QzLnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tIFdlIG9ubHkgd2FudCB0byBydW4gdGhpcyBlZmZlY3Qgb25jZVxuICAgIFtzdGF0ZS5pc0xvYWRpbmddXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxudmFyIFNNT09USF9ERUxBWSA9IDFlMztcbnZhciBub29wMyA9ICgpID0+IHtcbn07XG52YXIgaWRlbnRpdHkyID0gKHgpID0+IHg7XG52YXIgbWlzc2luZ191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChyZWFjdFZlcnNpb24sIHJvb21JZCkgPT4gYFdlIG5vdGljZWQgeW91XFx1MjAxOXJlIHVzaW5nIFJlYWN0ICR7cmVhY3RWZXJzaW9ufS4gUGxlYXNlIHBhc3MgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXQgdGhlIFJvb21Qcm92aWRlciBsZXZlbCB1bnRpbCB5b3VcXHUyMDE5cmUgcmVhZHkgdG8gdXBncmFkZSB0byBSZWFjdCAxODpcblxuICAgIGltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSBcInJlYWN0LWRvbVwiOyAgLy8gb3IgXCJyZWFjdC1uYXRpdmVcIlxuXG4gICAgPFJvb21Qcm92aWRlciBpZD0ke0pTT04uc3RyaW5naWZ5KFxuICByb29tSWRcbil9IC4uLiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcz17dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXN9PlxuICAgICAgLi4uXG4gICAgPC9Sb29tUHJvdmlkZXI+XG5cbldoeT8gUGxlYXNlIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS90cm91Ymxlc2hvb3Rpbmcjc3RhbGUtcHJvcHMtem9tYmllLWNoaWxkIGZvciBtb3JlIGluZm9ybWF0aW9uYDtcbnZhciBzdXBlcmZsdW91c191bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IFwiWW91IGRvblxcdTIwMTl0IG5lZWQgdG8gcGFzcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB0byBSb29tUHJvdmlkZXIgYW55bW9yZSwgc2luY2UgeW91XFx1MjAxOXJlIG9uIFJlYWN0IDE4KyBhbHJlYWR5LlwiO1xuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUyKHMsIGdzLCBnc3MpIHtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihzLCBncywgZ3NzLCBpZGVudGl0eTIpO1xufVxudmFyIFNUQUJMRV9FTVBUWV9MSVNUID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5mdW5jdGlvbiBhbHdheXNFbXB0eUxpc3QoKSB7XG4gIHJldHVybiBTVEFCTEVfRU1QVFlfTElTVDtcbn1cbmZ1bmN0aW9uIGFsd2F5c051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0b3JGb3JfdXNlT3RoZXJzQ29ubmVjdGlvbklkcyhvdGhlcnMpIHtcbiAgcmV0dXJuIG90aGVycy5tYXAoKHVzZXIpID0+IHVzZXIuY29ubmVjdGlvbklkKTtcbn1cbmZ1bmN0aW9uIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSkge1xuICBjb25zdCBjYW5ub3RVc2VVbnRpbCA9IFwiVGhpcyBtdXRhdGlvbiBjYW5ub3QgYmUgdXNlZCB1bnRpbFwiO1xuICBjb25zdCBuZWVkc1ByZXNlbmNlID0gYCR7Y2Fubm90VXNlVW50aWx9IGNvbm5lY3RlZCB0byB0aGUgTGl2ZWJsb2NrcyByb29tYDtcbiAgY29uc3QgbmVlZHNTdG9yYWdlID0gYCR7Y2Fubm90VXNlVW50aWx9IHN0b3JhZ2UgaGFzIGJlZW4gbG9hZGVkYDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc3RvcmFnZSgpIHtcbiAgICAgIGNvbnN0IG11dGFibGVSb290ID0gcm9vbS5nZXRTdG9yYWdlU25hcHNob3QoKTtcbiAgICAgIGlmIChtdXRhYmxlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNTdG9yYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdXRhYmxlUm9vdDtcbiAgICB9LFxuICAgIGdldCBzZWxmKCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHJvb20uZ2V0U2VsZigpO1xuICAgICAgaWYgKHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzUHJlc2VuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBnZXQgb3RoZXJzKCkge1xuICAgICAgY29uc3Qgb3RoZXJzID0gcm9vbS5nZXRPdGhlcnMoKTtcbiAgICAgIGlmIChyb29tLmdldFNlbGYoKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmVlZHNQcmVzZW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXJzO1xuICAgIH0sXG4gICAgc2V0TXlQcmVzZW5jZTogcm9vbS51cGRhdGVQcmVzZW5jZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZChyb29tKSB7XG4gIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgaWYgKHNlbGYgPT09IG51bGwgfHwgc2VsZi5pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlbGYuaWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFwaUVycm9yKGVycikge1xuICBjb25zdCBtZXNzYWdlID0gYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZXJyLnN0YXR1c306ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgaWYgKGVyci5kZXRhaWxzPy5lcnJvciA9PT0gXCJGT1JCSURERU5cIikge1xuICAgIGNvbnN0IGRldGFpbGVkTWVzc2FnZSA9IFttZXNzYWdlLCBlcnIuZGV0YWlscy5zdWdnZXN0aW9uLCBlcnIuZGV0YWlscy5kb2NzXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICBjb25zb2xlMy5lcnJvcihkZXRhaWxlZE1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG52YXIgX2V4dHJhczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfYnVuZGxlczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGxldCBidW5kbGUgPSBfYnVuZGxlczIuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMyLnNldChjbGllbnQsIGJ1bmRsZSk7XG4gIH1cbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KSB7XG4gIGxldCBleHRyYXMgPSBfZXh0cmFzMi5nZXQoY2xpZW50KTtcbiAgaWYgKCFleHRyYXMpIHtcbiAgICBleHRyYXMgPSBtYWtlUm9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIF9leHRyYXMyLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgY29tbWVudHNFcnJvckV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlMigpO1xuICBmdW5jdGlvbiBvbk11dGF0aW9uRmFpbHVyZShpbm5lckVycm9yLCBvcHRpbWlzdGljVXBkYXRlSWQsIGNyZWF0ZVB1YmxpY0Vycm9yKSB7XG4gICAgc3RvcmUucmVtb3ZlT3B0aW1pc3RpY1VwZGF0ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yMikge1xuICAgICAgY29uc3QgZXJyb3IgPSBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5ub3RpZnkoY3JlYXRlUHVibGljRXJyb3IoZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyRXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3IyKSB7XG4gICAgICBoYW5kbGVBcGlFcnJvcihpbm5lckVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgaW5uZXJFcnJvcjtcbiAgfVxuICBjb25zdCB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdmVyc2lvbnNQb2xsZXJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByb29tTm90aWZpY2F0aW9uU2V0dGluZ3NQb2xsZXJzQnlSb29tSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQocm9vbUlkKSB7XG4gICAgbGV0IHBvbGxlciA9IHRocmVhZHNQb2xsZXJzQnlSb29tSWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKCFwb2xsZXIpIHtcbiAgICAgIHBvbGxlciA9IG1ha2VQb2xsZXIyKFxuICAgICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBuZXcgdGhyZWFkcyBmb3IgJyR7cm9vbUlkfScgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLlJPT01fVEhSRUFEU19QT0xMX0lOVEVSVkFMLFxuICAgICAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuUk9PTV9USFJFQURTX01BWF9TVEFMRV9USU1FIH1cbiAgICAgICk7XG4gICAgICB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkLnNldChyb29tSWQsIHBvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiBwb2xsZXI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZChyb29tSWQpIHtcbiAgICBsZXQgcG9sbGVyID0gdmVyc2lvbnNQb2xsZXJzQnlSb29tSWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKCFwb2xsZXIpIHtcbiAgICAgIHBvbGxlciA9IG1ha2VQb2xsZXIyKFxuICAgICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaFJvb21WZXJzaW9uc0RlbHRhVXBkYXRlKHJvb21JZCwgc2lnbmFsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUzLndhcm4oYFBvbGxpbmcgbmV3IGhpc3RvcnkgdmVyc2lvbnMgZm9yICcke3Jvb21JZH0nIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZy5ISVNUT1JZX1ZFUlNJT05TX1BPTExfSU5URVJWQUwsXG4gICAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5ISVNUT1JZX1ZFUlNJT05TX01BWF9TVEFMRV9USU1FIH1cbiAgICAgICk7XG4gICAgICB2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZC5zZXQocm9vbUlkLCBwb2xsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9sbGVyO1xuICB9XG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkKHJvb21JZCkge1xuICAgIGxldCBwb2xsZXIgPSByb29tTm90aWZpY2F0aW9uU2V0dGluZ3NQb2xsZXJzQnlSb29tSWQuZ2V0KHJvb21JZCk7XG4gICAgaWYgKCFwb2xsZXIpIHtcbiAgICAgIHBvbGxlciA9IG1ha2VQb2xsZXIyKFxuICAgICAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5yZWZyZXNoUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2lnbmFsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUzLndhcm4oYFBvbGxpbmcgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZvciAnJHtyb29tSWR9JyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcuTk9USUZJQ0FUSU9OX1NFVFRJTkdTX1BPTExfSU5URVJWQUwsXG4gICAgICAgIHsgbWF4U3RhbGVUaW1lTXM6IGNvbmZpZy5OT1RJRklDQVRJT05fU0VUVElOR1NfTUFYX1NUQUxFX1RJTUUgfVxuICAgICAgKTtcbiAgICAgIHJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcnNCeVJvb21JZC5zZXQocm9vbUlkLCBwb2xsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9sbGVyO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcmUsXG4gICAgY29tbWVudHNFcnJvckV2ZW50U291cmNlOiBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2Uub2JzZXJ2YWJsZSxcbiAgICBvbk11dGF0aW9uRmFpbHVyZSxcbiAgICBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQsXG4gICAgZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZCxcbiAgICBnZXRPckNyZWF0ZU5vdGlmaWNhdGlvbnNTZXR0aW5nc1BvbGxlckZvclJvb21JZFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBmdW5jdGlvbiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChMaXZlYmxvY2tzUHJvdmlkZXJXaXRoQ2xpZW50LCB7IGNsaWVudCwgYWxsb3dOZXN0aW5nOiB0cnVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSb29tUHJvdmlkZXIsIHsgLi4ucHJvcHMgfSkpO1xuICB9XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIFJvb21Db250ZXh0LFxuICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyX3dpdGhJbXBsaWNpdExpdmVibG9ja3NQcm92aWRlcixcbiAgICB1c2VSb29tLFxuICAgIHVzZVN0YXR1cyxcbiAgICB1c2VTdG9yYWdlU3RhdHVzLFxuICAgIHVzZUJhdGNoLFxuICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgIHVzZU90aGVyc0xpc3RlbmVyLFxuICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgIHVzZUhpc3RvcnksXG4gICAgdXNlVW5kbyxcbiAgICB1c2VSZWRvLFxuICAgIHVzZUNhblJlZG8sXG4gICAgdXNlQ2FuVW5kbyxcbiAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICB1c2VTdG9yYWdlLFxuICAgIHVzZVNlbGYsXG4gICAgdXNlTXlQcmVzZW5jZSxcbiAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgIHVzZU90aGVycyxcbiAgICB1c2VPdGhlcnNNYXBwZWQsXG4gICAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgICB1c2VPdGhlcixcbiAgICB1c2VNdXRhdGlvbixcbiAgICB1c2VUaHJlYWRzLFxuICAgIHVzZUNyZWF0ZVRocmVhZCxcbiAgICB1c2VEZWxldGVUaHJlYWQsXG4gICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICB1c2VFZGl0Q29tbWVudCxcbiAgICB1c2VEZWxldGVDb21tZW50LFxuICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgIHVzZVJlbW92ZVJlYWN0aW9uLFxuICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgIHVzZUF0dGFjaG1lbnRVcmwsXG4gICAgdXNlSGlzdG9yeVZlcnNpb25zLFxuICAgIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSxcbiAgICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC4uLnNoYXJlZC5jbGFzc2ljLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBSb29tQ29udGV4dCxcbiAgICAgIFJvb21Qcm92aWRlcjogUm9vbVByb3ZpZGVyX3dpdGhJbXBsaWNpdExpdmVibG9ja3NQcm92aWRlcixcbiAgICAgIHVzZVJvb20sXG4gICAgICB1c2VTdGF0dXMsXG4gICAgICB1c2VTdG9yYWdlU3RhdHVzOiB1c2VTdG9yYWdlU3RhdHVzU3VzcGVuc2UsXG4gICAgICB1c2VCYXRjaCxcbiAgICAgIHVzZUJyb2FkY2FzdEV2ZW50LFxuICAgICAgdXNlT3RoZXJzTGlzdGVuZXIsXG4gICAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgICB1c2VIaXN0b3J5LFxuICAgICAgdXNlVW5kbyxcbiAgICAgIHVzZVJlZG8sXG4gICAgICB1c2VDYW5SZWRvLFxuICAgICAgdXNlQ2FuVW5kbyxcbiAgICAgIHVzZVN0b3JhZ2VSb290LFxuICAgICAgdXNlU3RvcmFnZTogdXNlU3RvcmFnZVN1c3BlbnNlLFxuICAgICAgdXNlU2VsZjogdXNlU2VsZlN1c3BlbnNlLFxuICAgICAgdXNlTXlQcmVzZW5jZSxcbiAgICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgICB1c2VPdGhlcnM6IHVzZU90aGVyc1N1c3BlbnNlLFxuICAgICAgdXNlT3RoZXJzTWFwcGVkOiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHM6IHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyOiB1c2VPdGhlclN1c3BlbnNlLFxuICAgICAgdXNlTXV0YXRpb24sXG4gICAgICB1c2VUaHJlYWRzOiB1c2VUaHJlYWRzU3VzcGVuc2UsXG4gICAgICB1c2VDcmVhdGVUaHJlYWQsXG4gICAgICB1c2VEZWxldGVUaHJlYWQsXG4gICAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgICB1c2VNYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQsXG4gICAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgICAgdXNlRWRpdENvbW1lbnQsXG4gICAgICB1c2VEZWxldGVDb21tZW50LFxuICAgICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgICB1c2VSZW1vdmVSZWFjdGlvbixcbiAgICAgIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gICAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgICB1c2VBdHRhY2htZW50VXJsOiB1c2VBdHRhY2htZW50VXJsU3VzcGVuc2UsXG4gICAgICAvLyBUT0RPOiB1c2VIaXN0b3J5VmVyc2lvbkRhdGE6IHVzZUhpc3RvcnlWZXJzaW9uRGF0YVN1c3BlbnNlLFxuICAgICAgdXNlSGlzdG9yeVZlcnNpb25zOiB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSxcbiAgICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nczogdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gICAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAuLi5zaGFyZWQuc3VzcGVuc2VcbiAgICB9LFxuICAgIHVzZUNvbW1lbnRzRXJyb3JMaXN0ZW5lclxuICB9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwga0ludGVybmFsMywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBbY2FjaGVdID0gUmVhY3Q0LnVzZVN0YXRlKFxuICAgICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgKTtcbiAgY29uc3Qgc3RhYmxlRW50ZXJSb29tID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChyb29tSWQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChyb29tSWQpO1xuICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgIGNvbnN0IHJ2ID0gY2xpZW50LmVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgb3JpZ0xlYXZlID0gcnYubGVhdmU7XG4gICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgb3JpZ0xlYXZlKCk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShyb29tSWQpO1xuICAgICAgfTtcbiAgICAgIGNhY2hlLnNldChyb29tSWQsIHJ2KTtcbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIFtjbGllbnQsIGNhY2hlXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgIFJvb21Qcm92aWRlcklubmVyLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3RhYmxlRW50ZXJSb29tXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVySW5uZXIocHJvcHMpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgaWQ6IHJvb21JZCwgc3RhYmxlRW50ZXJSb29tIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcm9vbUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IGlzIHJlcXVpcmVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtcmVhY3QvUm9vbVByb3ZpZGVyLWlkLXByb3BlcnR5LWlzLXJlcXVpcmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmcocm9vbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlkIHByb3BlcnR5IHNob3VsZCBiZSBhIHN0cmluZy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG1ham9yUmVhY3RWZXJzaW9uID0gcGFyc2VJbnQoUmVhY3Q0LnZlcnNpb24pIHx8IDE7XG4gICAgY29uc3Qgb2xkUmVhY3RWZXJzaW9uID0gbWFqb3JSZWFjdFZlcnNpb24gPCAxODtcbiAgICBlcnJvcklmKFxuICAgICAgb2xkUmVhY3RWZXJzaW9uICYmIHByb3BzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID09PSB2b2lkIDAsXG4gICAgICBtaXNzaW5nX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKG1ham9yUmVhY3RWZXJzaW9uLCByb29tSWQpXG4gICAgKTtcbiAgICBkZXByZWNhdGVJZihcbiAgICAgICFvbGRSZWFjdFZlcnNpb24gJiYgcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgIT09IHZvaWQgMCxcbiAgICAgIHN1cGVyZmx1b3VzX3Vuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXG4gICAgKTtcbiAgfVxuICBjb25zdCBmcm96ZW5Qcm9wcyA9IHVzZUluaXRpYWwoe1xuICAgIGluaXRpYWxQcmVzZW5jZTogcHJvcHMuaW5pdGlhbFByZXNlbmNlLFxuICAgIGluaXRpYWxTdG9yYWdlOiBwcm9wcy5pbml0aWFsU3RvcmFnZSxcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogcHJvcHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG4gICAgYXV0b0Nvbm5lY3Q6IHByb3BzLmF1dG9Db25uZWN0ID8/IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgfSk7XG4gIGNvbnN0IFt7IHJvb20gfSwgc2V0Um9vbUxlYXZlUGFpcl0gPSBSZWFjdDQudXNlU3RhdGUoXG4gICAgKCkgPT4gc3RhYmxlRW50ZXJSb29tKHJvb21JZCwge1xuICAgICAgLi4uZnJvemVuUHJvcHMsXG4gICAgICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgIC8vIERlbGliZXJhdGVseSB1c2luZyBmYWxzZSBoZXJlIG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSBiZWxvd1xuICAgIH0pXG4gICk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDb21tZW50RXZlbnQobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gU2VydmVyTXNnQ29kZS5USFJFQURfREVMRVRFRCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCByb29tLmdldFRocmVhZChtZXNzYWdlLnRocmVhZElkKTtcbiAgICAgIGlmICghaW5mby50aHJlYWQpIHtcbiAgICAgICAgc3RvcmUuZGVsZXRlVGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24gfSA9IGluZm87XG4gICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0b3JlLmdldEZ1bGxTdGF0ZSgpLnRocmVhZHNEQi5nZXRFdmVuSWZEZWxldGVkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfRURJVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX01FVEFEQVRBX1VQREFURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfVVBEQVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fQURERUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0RFTEVURUQ6XG4gICAgICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkgYnJlYWs7XG4gICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkQW5kTm90aWZpY2F0aW9uKHRocmVhZCwgaW5ib3hOb3RpZmljYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9DUkVBVEVEOlxuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZEFuZE5vdGlmaWNhdGlvbih0aHJlYWQsIGluYm94Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb20uZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgIChtZXNzYWdlKSA9PiB2b2lkIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKVxuICAgICk7XG4gIH0sIFtjbGllbnQsIHJvb21dKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcGFpciA9IHN0YWJsZUVudGVyUm9vbShyb29tSWQsIGZyb3plblByb3BzKTtcbiAgICBzZXRSb29tTGVhdmVQYWlyKHBhaXIpO1xuICAgIGNvbnN0IHsgcm9vbTogcm9vbTIsIGxlYXZlIH0gPSBwYWlyO1xuICAgIGlmIChmcm96ZW5Qcm9wcy5hdXRvQ29ubmVjdCkge1xuICAgICAgcm9vbTIuY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGVhdmUoKTtcbiAgICB9O1xuICB9LCBbcm9vbUlkLCBmcm96ZW5Qcm9wcywgc3RhYmxlRW50ZXJSb29tXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUm9vbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJvb20gfSwgcHJvcHMuY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdXNlUm9vbSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb21Pck51bGwoKTtcbiAgaWYgKHJvb20gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tUHJvdmlkZXIgaXMgbWlzc2luZyBmcm9tIHRoZSBSZWFjdCB0cmVlLlwiKTtcbiAgfVxuICByZXR1cm4gcm9vbTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXR1cygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSByb29tLmdldFN0YXR1cztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzKG9wdGlvbnMpIHtcbiAgY29uc3Qgc21vb3RoID0gdXNlSW5pdGlhbChvcHRpb25zPy5zbW9vdGggPz8gZmFsc2UpO1xuICBpZiAoc21vb3RoKSB7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1c0ltbWVkaWF0ZSgpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzSW1tZWRpYXRlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU3RhdHVzO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSBSZWFjdDQudXNlU3RhdGUocm9vbS5nZXRTdG9yYWdlU3RhdHVzKTtcbiAgY29uc3Qgb2xkU3RhdHVzID0gdXNlTGF0ZXN0KHJvb20uZ2V0U3RvcmFnZVN0YXR1cygpKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCB1bnN1YiA9IHJvb20uZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKChuZXdTdGF0dXMpID0+IHtcbiAgICAgIGlmIChvbGRTdGF0dXMuY3VycmVudCA9PT0gXCJzeW5jaHJvbml6aW5nXCIgJiYgbmV3U3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKG5ld1N0YXR1cyksIFNNT09USF9ERUxBWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgc2V0U3RhdHVzKG5ld1N0YXR1cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdW5zdWIoKTtcbiAgICB9O1xuICB9LCBbcm9vbSwgb2xkU3RhdHVzXSk7XG4gIHJldHVybiBzdGF0dXM7XG59XG5mdW5jdGlvbiB1c2VCYXRjaCgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS5iYXRjaDtcbn1cbmZ1bmN0aW9uIHVzZUJyb2FkY2FzdEV2ZW50KCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChldmVudCwgb3B0aW9ucyA9IHsgc2hvdWxkUXVldWVFdmVudElmTm90UmVhZHk6IGZhbHNlIH0pID0+IHtcbiAgICAgIHJvb20uYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3Jvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdChcbiAgICAoKSA9PiByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KSksXG4gICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBSZWFjdDQudXNlRWZmZWN0KFxuICAgICgpID0+IHJvb20uZXZlbnRzLmxvc3RDb25uZWN0aW9uLnN1YnNjcmliZShcbiAgICAgIChldmVudCkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50KVxuICAgICksXG4gICAgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFcnJvckxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICBSZWFjdDQudXNlRWZmZWN0KFxuICAgICgpID0+IHJvb20uZXZlbnRzLmVycm9yLnN1YnNjcmliZSgoZSkgPT4gc2F2ZWRDYWxsYmFjay5jdXJyZW50KGUpKSxcbiAgICBbcm9vbSwgc2F2ZWRDYWxsYmFja11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50KGV2ZW50RGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfSwgW3Jvb20sIHNhdmVkQ2FsbGJhY2tdKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gIHJldHVybiB1c2VSb29tKCkuaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIHVzZVVuZG8oKSB7XG4gIHJldHVybiB1c2VIaXN0b3J5KCkudW5kbztcbn1cbmZ1bmN0aW9uIHVzZVJlZG8oKSB7XG4gIHJldHVybiB1c2VIaXN0b3J5KCkucmVkbztcbn1cbmZ1bmN0aW9uIHVzZUNhblVuZG8oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICBjb25zdCBjYW5VbmRvID0gcm9vbS5oaXN0b3J5LmNhblVuZG87XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBjYW5VbmRvLCBjYW5VbmRvKTtcbn1cbmZ1bmN0aW9uIHVzZUNhblJlZG8oKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLmhpc3Rvcnkuc3Vic2NyaWJlO1xuICBjb25zdCBjYW5SZWRvID0gcm9vbS5oaXN0b3J5LmNhblJlZG87XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBjYW5SZWRvLCBjYW5SZWRvKTtcbn1cbmZ1bmN0aW9uIHVzZVNlbGYobWF5YmVTZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zZWxmLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFNlbGY7XG4gIGNvbnN0IHNlbGVjdG9yID0gbWF5YmVTZWxlY3RvciA/PyBpZGVudGl0eTI7XG4gIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAobWUpID0+IG1lICE9PSBudWxsID8gc2VsZWN0b3IobWUpIDogbnVsbCxcbiAgICBbc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzTnVsbDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU15UHJlc2VuY2UoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0UHJlc2VuY2U7XG4gIGNvbnN0IHByZXNlbmNlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbiAgY29uc3Qgc2V0UHJlc2VuY2UgPSByb29tLnVwZGF0ZVByZXNlbmNlO1xuICByZXR1cm4gW3ByZXNlbmNlLCBzZXRQcmVzZW5jZV07XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVNeVByZXNlbmNlKCkge1xuICByZXR1cm4gdXNlUm9vbSgpLnVwZGF0ZVByZXNlbmNlO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzKHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLm90aGVycy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRPdGhlcnM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gYWx3YXlzRW1wdHlMaXN0O1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICBzZWxlY3RvciA/PyBpZGVudGl0eTIsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyKSA9PiBbb3RoZXIuY29ubmVjdGlvbklkLCBpdGVtU2VsZWN0b3Iob3RoZXIpXSksXG4gICAgW2l0ZW1TZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGVxID0gaXRlbUlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChhdHVwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYXR1cGxlWzBdID09PSBidHVwbGVbMF0gJiYgZXEoYXR1cGxlWzFdLCBidHVwbGVbMV0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbaXRlbUlzRXF1YWxdXG4gICk7XG4gIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCkge1xuICByZXR1cm4gdXNlT3RoZXJzKHNlbGVjdG9yRm9yX3VzZU90aGVyc0Nvbm5lY3Rpb25JZHMsIHNoYWxsb3c0KTtcbn1cbnZhciBOT1RfRk9VTkQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChvdGhlcnMpID0+IHtcbiAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZCk7XG4gICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgW2Nvbm5lY3Rpb25JZCwgc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICByZXR1cm4gcHJldiA9PT0gY3VycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICByZXR1cm4gZXEocHJldiwgY3Vycik7XG4gICAgfSxcbiAgICBbaXNFcXVhbF1cbiAgKTtcbiAgY29uc3Qgb3RoZXIgPSB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vIHN1Y2ggb3RoZXIgdXNlciB3aXRoIGNvbm5lY3Rpb24gaWQgJHtjb25uZWN0aW9uSWR9IGV4aXN0c2BcbiAgICApO1xuICB9XG4gIHJldHVybiBvdGhlcjtcbn1cbmZ1bmN0aW9uIHVzZU11dGFibGVTdG9yYWdlUm9vdCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdDtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICByZXR1cm4gW3VzZU11dGFibGVTdG9yYWdlUm9vdCgpXTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgcm9vdE9yTnVsbCA9IHVzZU11dGFibGVTdG9yYWdlUm9vdCgpO1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHJvb3RPck51bGwyKSA9PiByb290T3JOdWxsMiAhPT0gbnVsbCA/IHNlbGVjdG9yKHJvb3RPck51bGwyKSA6IG51bGwsXG4gICAgW3NlbGVjdG9yXVxuICApO1xuICBjb25zdCBzdWJzY3JpYmUgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG9uU3RvcmVDaGFuZ2UpID0+IHJvb3RPck51bGwgIT09IG51bGwgPyByb29tLnN1YnNjcmliZShyb290T3JOdWxsLCBvblN0b3JlQ2hhbmdlLCB7IGlzRGVlcDogdHJ1ZSB9KSA6IG5vb3AzLFxuICAgIFtyb29tLCByb290T3JOdWxsXVxuICApO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IFJlYWN0NC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGNvbnN0IGltbSA9IHJvb3QudG9JbW11dGFibGUoKTtcbiAgICAgIHJldHVybiBpbW07XG4gICAgfVxuICB9LCBbcm9vdE9yTnVsbF0pO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcjIoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNdXRhdGlvbihjYWxsYmFjaywgZGVwcykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZU1lbW8oXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByb29tLmJhdGNoKFxuICAgICAgICAgICgpID0+IChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgIG1ha2VNdXRhdGlvbkNvbnRleHQocm9vbSksXG4gICAgICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW3Jvb20sIC4uLmRlcHNdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VUaHJlYWRzKG9wdGlvbnMgPSB7XG4gIHF1ZXJ5OiB7IG1ldGFkYXRhOiB7fSB9XG59KSB7XG4gIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZCB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBwb2xsZXIgPSBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4ge1xuICAgICAgdm9pZCBzdG9yZS53YWl0VW50aWxSb29tVGhyZWFkc0xvYWRlZChyb29tLmlkLCBvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHBvbGxlci5kZWMoKTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCBnZXR0ZXIgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gc3RvcmUuZ2V0Um9vbVRocmVhZHNMb2FkaW5nU3RhdGUocm9vbS5pZCwgb3B0aW9ucy5xdWVyeSksXG4gICAgW3N0b3JlLCByb29tLmlkLCBvcHRpb25zLnF1ZXJ5XVxuICApO1xuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0dGVyLFxuICAgIGdldHRlcixcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzJcbiAgICAvLyBOT1RFOiBVc2luZyAyLWxldmVsLWRlZXAgc2hhbGxvdyBjaGVjayBoZXJlLCBiZWNhdXNlIHRoZSByZXN1bHQgb2Ygc2VsZWN0VGhyZWFkcygpIGlzIG5vdCBzdGFibGUhXG4gICk7XG4gIHVzZVNjcm9sbFRvQ29tbWVudE9uTG9hZEVmZmVjdChzY3JvbGxPbkxvYWQsIHN0YXRlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlQ29tbWVudHNFcnJvckxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgY29uc3QgeyBjb21tZW50c0Vycm9yRXZlbnRTb3VyY2UgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZS5zdWJzY3JpYmUoc2F2ZWRDYWxsYmFjay5jdXJyZW50KTtcbiAgfSwgW3NhdmVkQ2FsbGJhY2ssIGNvbW1lbnRzRXJyb3JFdmVudFNvdXJjZV0pO1xufVxuZnVuY3Rpb24gdXNlQ3JlYXRlVGhyZWFkKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gb3B0aW9ucy5hdHRhY2htZW50cztcbiAgICAgIGNvbnN0IHRocmVhZElkID0gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBuZXdDb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQocm9vbSksXG4gICAgICAgIGJvZHksXG4gICAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyA/PyBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG5ld1RocmVhZCA9IHtcbiAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICB0eXBlOiBcInRocmVhZFwiLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHVwZGF0ZWRBdDogY3JlYXRlZEF0LFxuICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBjb21tZW50czogW25ld0NvbW1lbnRdLFxuICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiY3JlYXRlLXRocmVhZFwiLFxuICAgICAgICB0aHJlYWQ6IG5ld1RocmVhZCxcbiAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIHJvb20uY3JlYXRlVGhyZWFkKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgbWV0YWRhdGEsIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKHRocmVhZCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmNyZWF0ZVRocmVhZChvcHRpbWlzdGljVXBkYXRlSWQsIHRocmVhZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycjIpID0+IG5ldyBDcmVhdGVUaHJlYWRFcnJvcihlcnIyLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3VGhyZWFkO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVRocmVhZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUuZ2V0RnVsbFN0YXRlKCkudGhyZWFkc0RCLmdldCh0aHJlYWRJZCk7XG4gICAgICBpZiAoZXhpc3Rpbmc/LmNvbW1lbnRzPy5bMF0/LnVzZXJJZCAhPT0gdXNlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgdGhlIHRocmVhZCBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHRocmVhZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS10aHJlYWRcIixcbiAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgZGVsZXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgfSk7XG4gICAgICByb29tLmRlbGV0ZVRocmVhZCh0aHJlYWRJZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyMikgPT4gbmV3IERlbGV0ZVRocmVhZEVycm9yKGVycjIsIHsgcm9vbUlkOiByb29tLmlkLCB0aHJlYWRJZCB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucy5tZXRhZGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aHJlYWRJZCA9IG9wdGlvbnMudGhyZWFkSWQ7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGE7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICByb29tLmVkaXRUaHJlYWRNZXRhZGF0YSh7IHRocmVhZElkLCBtZXRhZGF0YSB9KS50aGVuKFxuICAgICAgICAobWV0YWRhdGEyKSA9PiAoXG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgYnkgdGhlIHJlYWwgdGhpbmdcbiAgICAgICAgICBzdG9yZS5wYXRjaFRocmVhZChcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgeyBtZXRhZGF0YTogbWV0YWRhdGEyIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgRWRpdFRocmVhZE1ldGFkYXRhRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZUNvbW1lbnQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBib2R5LCBhdHRhY2htZW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBjb21tZW50SWQgPSBjcmVhdGVDb21tZW50SWQoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcklkOiBnZXRDdXJyZW50VXNlcklkKHJvb20pLFxuICAgICAgICBib2R5LFxuICAgICAgICByZWFjdGlvbnM6IFtdLFxuICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMgPz8gW11cbiAgICAgIH07XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwiY3JlYXRlLWNvbW1lbnRcIixcbiAgICAgICAgY29tbWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICByb29tLmNyZWF0ZUNvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50SWRzIH0pLnRoZW4oXG4gICAgICAgIChuZXdDb21tZW50KSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlQ29tbWVudChuZXdDb21tZW50LCBvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnIyKSA9PiBuZXcgQ3JlYXRlQ29tbWVudEVycm9yKGVycjIsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFZGl0Q29tbWVudCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgYXR0YWNobWVudHMgfSkgPT4ge1xuICAgICAgY29uc3QgZWRpdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHN0b3JlLmdldEZ1bGxTdGF0ZSgpLnRocmVhZHNEQi5nZXRFdmVuSWZEZWxldGVkKHRocmVhZElkKTtcbiAgICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSB0aHJlYWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbWVudCA9IGV4aXN0aW5nLmNvbW1lbnRzLmZpbmQoXG4gICAgICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICAgICAgKTtcbiAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDAgfHwgY29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlMy53YXJuKFxuICAgICAgICAgIGBJbnRlcm5hbCB1bmV4cGVjdGVkIGJlaGF2aW9yLiBDYW5ub3QgZWRpdCBjb21tZW50IFwiJHtjb21tZW50SWR9XCIgaW4gdGhyZWFkIFwiJHt0aHJlYWRJZH1cIiBiZWNhdXNlIHRoZSBjb21tZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZS5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImVkaXQtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50OiB7XG4gICAgICAgICAgLi4uY29tbWVudCxcbiAgICAgICAgICBlZGl0ZWRBdCxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyA/PyBbXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIHJvb20uZWRpdENvbW1lbnQoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50SWRzIH0pLnRoZW4oXG4gICAgICAgIChlZGl0ZWRDb21tZW50KSA9PiB7XG4gICAgICAgICAgc3RvcmUuZWRpdENvbW1lbnQodGhyZWFkSWQsIG9wdGltaXN0aWNVcGRhdGVJZCwgZWRpdGVkQ29tbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgRWRpdENvbW1lbnRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVDb21tZW50KCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkIH0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLmFkZE9wdGltaXN0aWNVcGRhdGUoe1xuICAgICAgICB0eXBlOiBcImRlbGV0ZS1jb21tZW50XCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBjb21tZW50SWQsXG4gICAgICAgIGRlbGV0ZWRBdCxcbiAgICAgICAgcm9vbUlkOiByb29tLmlkXG4gICAgICB9KTtcbiAgICAgIHJvb20uZGVsZXRlQ29tbWVudCh7IHRocmVhZElkLCBjb21tZW50SWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGRlbGV0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgRGVsZXRlQ29tbWVudEVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlQWRkUmVhY3Rpb24oKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0Q3VycmVudFVzZXJJZChyb29tKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJhZGQtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgcmVhY3Rpb246IHtcbiAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcm9vbS5hZGRSZWFjdGlvbih7IHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgIChhZGRlZFJlYWN0aW9uKSA9PiB7XG4gICAgICAgICAgc3RvcmUuYWRkUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGFkZGVkUmVhY3Rpb24sXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IEFkZFJlYWN0aW9uRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbW92ZVJlYWN0aW9uKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKHJvb20pO1xuICAgICAgY29uc3QgcmVtb3ZlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlLXJlYWN0aW9uXCIsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBjb21tZW50SWQsXG4gICAgICAgIGVtb2ppLFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIHJlbW92ZWRBdFxuICAgICAgfSk7XG4gICAgICByb29tLnJlbW92ZVJlYWN0aW9uKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIHJlbW92ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgUmVtb3ZlUmVhY3Rpb25FcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBlbW9qaVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzUmVhZCgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICBzdG9yZS5nZXRGdWxsU3RhdGUoKS5ub3RpZmljYXRpb25zQnlJZFxuICAgICAgKS5maW5kKFxuICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24yKSA9PiBpbmJveE5vdGlmaWNhdGlvbjIua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbjIudGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICApO1xuICAgICAgaWYgKCFpbmJveE5vdGlmaWNhdGlvbikgcmV0dXJuO1xuICAgICAgY29uc3Qgbm93ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkLFxuICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgfSk7XG4gICAgICByb29tLm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbi5pZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZUluYm94Tm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb24uaWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24yKSA9PiAoeyAuLi5pbmJveE5vdGlmaWNhdGlvbjIsIHJlYWRBdDogbm93IH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgICAgKGVycm9yKSA9PiBuZXcgTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICByb29tLm1hcmtUaHJlYWRBc1Jlc29sdmVkKHRocmVhZElkKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgKGVycm9yKSA9PiBuZXcgTWFya1RocmVhZEFzUmVzb2x2ZWRFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgcm9vbUlkOiByb29tLmlkLFxuICAgICAgICAgICAgdGhyZWFkSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY1VwZGF0ZUlkID0gc3RvcmUuYWRkT3B0aW1pc3RpY1VwZGF0ZSh7XG4gICAgICAgIHR5cGU6IFwibWFyay10aHJlYWQtYXMtdW5yZXNvbHZlZFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIHJvb20ubWFya1RocmVhZEFzVW5yZXNvbHZlZCh0aHJlYWRJZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLnBhdGNoVGhyZWFkKFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICB7IHJlc29sdmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgdXBkYXRlZEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZCxcbiAgICAgICAgICAoZXJyb3IpID0+IG5ldyBNYXJrVGhyZWFkQXNVbnJlc29sdmVkRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgICAgIHRocmVhZElkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VUaHJlYWRTdWJzY3JpcHRpb24odGhyZWFkSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHsgc3RvcmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBub3RpZmljYXRpb24gPSBzdGF0ZS5jbGVhbmVkTm90aWZpY2F0aW9ucy5maW5kKFxuICAgICAgICAoaW5ib3hOb3RpZmljYXRpb24pID0+IGluYm94Tm90aWZpY2F0aW9uLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgaW5ib3hOb3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZElkXG4gICAgICApO1xuICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc0RCLmdldCh0aHJlYWRJZCk7XG4gICAgICBpZiAobm90aWZpY2F0aW9uID09PSB2b2lkIDAgfHwgdGhyZWFkID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcIm5vdC1zdWJzY3JpYmVkXCIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJzdWJzY3JpYmVkXCIsXG4gICAgICAgIHVucmVhZFNpbmNlOiBub3RpZmljYXRpb24ucmVhZEF0XG4gICAgICB9O1xuICAgIH0sXG4gICAgW3RocmVhZElkXVxuICApO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBzdG9yZS5nZXRGdWxsU3RhdGUsXG4gICAgc3RvcmUuZ2V0RnVsbFN0YXRlLFxuICAgIHNlbGVjdG9yXG4gICk7XG59XG5mdW5jdGlvbiB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKSB7XG4gIGNvbnN0IHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSwgZ2V0T3JDcmVhdGVOb3RpZmljYXRpb25zU2V0dGluZ3NQb2xsZXJGb3JSb29tSWQgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcG9sbGVyID0gZ2V0T3JDcmVhdGVOb3RpZmljYXRpb25zU2V0dGluZ3NQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIFJlYWN0NC51c2VFZmZlY3QoXG4gICAgKCkgPT4ge1xuICAgICAgdm9pZCBzdG9yZS53YWl0VW50aWxSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NMb2FkZWQocm9vbS5pZCk7XG4gICAgfVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb2xsZXIuZGVjKCk7XG4gICAgfTtcbiAgfSwgW3BvbGxlcl0pO1xuICBjb25zdCBnZXR0ZXIgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gc3RvcmUuZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3NMb2FkaW5nU3RhdGUocm9vbS5pZCksXG4gICAgW3N0b3JlLCByb29tLmlkXVxuICApO1xuICBjb25zdCBzZXR0aW5ncyA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBzdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0dGVyLFxuICAgIGdldHRlcixcbiAgICBpZGVudGl0eTIsXG4gICAgc2hhbGxvdzJcbiAgKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzdG9yZSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgdXNlKHN0b3JlLndhaXRVbnRpbFJvb21Ob3RpZmljYXRpb25TZXR0aW5nc0xvYWRlZChyb29tLmlkKSk7XG4gIGNvbnN0IFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXSA9IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpO1xuICBhc3NlcnQyKCFzZXR0aW5ncy5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0Mighc2V0dGluZ3MuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiBSZWFjdDQudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIFtzZXR0aW5ncywgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzXTtcbiAgfSwgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSh2ZXJzaW9uSWQpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdDQudXNlU3RhdGUoe1xuICAgIGlzTG9hZGluZzogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgY29uc3QgbG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcm9vbVtrSW50ZXJuYWwzXS5nZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbG9hZGluZyB0aGlzIHZlcnNpb25cIlxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2b2lkIGxvYWQoKTtcbiAgfSwgW3Jvb20sIHZlcnNpb25JZF0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5VmVyc2lvbnMoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IHN0b3JlLCBnZXRPckNyZWF0ZVZlcnNpb25zUG9sbGVyRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHBvbGxlciA9IGdldE9yQ3JlYXRlVmVyc2lvbnNQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4gcG9sbGVyLmRlYygpO1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IGdldHRlciA9IFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoKSA9PiBzdG9yZS5nZXRSb29tVmVyc2lvbnNMb2FkaW5nU3RhdGUocm9vbS5pZCksXG4gICAgW3N0b3JlLCByb29tLmlkXVxuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KFxuICAgICgpID0+IHtcbiAgICAgIHZvaWQgc3RvcmUud2FpdFVudGlsUm9vbVZlcnNpb25zTG9hZGVkKHJvb20uaWQpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKFxuICAgIHN0b3JlLnN1YnNjcmliZSxcbiAgICBnZXR0ZXIsXG4gICAgZ2V0dGVyLFxuICAgIGlkZW50aXR5MixcbiAgICBzaGFsbG93MlxuICApO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsUm9vbVZlcnNpb25zTG9hZGVkKHJvb20uaWQpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlSGlzdG9yeVZlcnNpb25zKCk7XG4gIGFzc2VydDIoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0MighcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIFJlYWN0NC51c2VDYWxsYmFjayhcbiAgICAoc2V0dGluZ3MpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljVXBkYXRlSWQgPSBzdG9yZS5hZGRPcHRpbWlzdGljVXBkYXRlKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbS51cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc19jb25maXJtT3B0aW1pc3RpY1VwZGF0ZShcbiAgICAgICAgICAgIHJvb20uaWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlSWQsXG4gICAgICAgICAgICBzZXR0aW5nczJcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZUlkLFxuICAgICAgICAgIChlcnJvcikgPT4gbmV3IFVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzRXJyb3IoZXJyb3IsIHtcbiAgICAgICAgICAgIHJvb21JZDogcm9vbS5pZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tXVxuICApO1xufVxuZnVuY3Rpb24gZW5zdXJlTm90U2VydmVyU2lkZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3QgdXNlIHRoZSBTdXNwZW5zZSB2ZXJzaW9uIG9mIHRoaXMgaG9vayBvbiB0aGUgc2VydmVyIHNpZGUuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdGhlbSBvbiB0aGUgY2xpZW50IHNpZGUuXFxuRm9yIHRpcHMsIHNlZSBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtcmVhY3Qjc3VzcGVuc2UtYXZvaWQtc3NyXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU2VsZihcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnMoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uocm9vbS53YWl0VW50aWxTdG9yYWdlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZShvcHRpb25zKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zID0ge1xuICBxdWVyeTogeyBtZXRhZGF0YToge30gfVxufSkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICB1c2Uoc3RvcmUud2FpdFVudGlsUm9vbVRocmVhZHNMb2FkZWQocm9vbS5pZCwgb3B0aW9ucy5xdWVyeSkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VUaHJlYWRzKG9wdGlvbnMpO1xuICBhc3NlcnQyKCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydDIoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZUF0dGFjaG1lbnRVcmwoc3RhdGUpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBhc3NlcnQyKHN0YXRlLmRhdGEgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3NpbmcgYXR0YWNobWVudCBVUkxcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1cmw6IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgYXR0YWNobWVudFVybHNTdG9yZSB9ID0gcm9vbVtrSW50ZXJuYWwzXTtcbiAgY29uc3QgZ2V0QXR0YWNobWVudFVybFN0YXRlID0gUmVhY3Q0LnVzZUNhbGxiYWNrKFxuICAgICgpID0+IGF0dGFjaG1lbnRVcmxzU3RvcmUuZ2V0U3RhdGUoYXR0YWNobWVudElkKSxcbiAgICBbYXR0YWNobWVudFVybHNTdG9yZSwgYXR0YWNobWVudElkXVxuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2b2lkIGF0dGFjaG1lbnRVcmxzU3RvcmUuZ2V0KGF0dGFjaG1lbnRJZCk7XG4gIH0sIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMihcbiAgICBhdHRhY2htZW50VXJsc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlLFxuICAgIHNlbGVjdG9yRm9yX3VzZUF0dGFjaG1lbnRVcmwsXG4gICAgc2hhbGxvdzRcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUF0dGFjaG1lbnRVcmxTdXNwZW5zZShhdHRhY2htZW50SWQpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBhdHRhY2htZW50VXJsc1N0b3JlIH0gPSByb29tW2tJbnRlcm5hbDNdO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSBSZWFjdDQudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gYXR0YWNobWVudFVybHNTdG9yZS5nZXRTdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxTdGF0ZSA9IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSgpO1xuICBpZiAoIWF0dGFjaG1lbnRVcmxTdGF0ZSB8fCBhdHRhY2htZW50VXJsU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybHNTdG9yZS5nZXQoYXR0YWNobWVudElkKTtcbiAgfVxuICBpZiAoYXR0YWNobWVudFVybFN0YXRlLmVycm9yKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybFN0YXRlLmVycm9yO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIGF0dGFjaG1lbnRVcmxzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGVcbiAgKTtcbiAgYXNzZXJ0MihzdGF0ZSAhPT0gdm9pZCAwLCBcIlVuZXhwZWN0ZWQgbWlzc2luZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0Mighc3RhdGUuaXNMb2FkaW5nLCBcIlVuZXhwZWN0ZWQgbG9hZGluZyBzdGF0ZVwiKTtcbiAgYXNzZXJ0Mighc3RhdGUuZXJyb3IsIFwiVW5leHBlY3RlZCBlcnJvciBzdGF0ZVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVybDogc3RhdGUuZGF0YSxcbiAgICBlcnJvcjogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb29tQ29udGV4dChjbGllbnQpIHtcbiAgcmV0dXJuIGdldE9yQ3JlYXRlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KTtcbn1cbnZhciBfUm9vbVByb3ZpZGVyID0gUm9vbVByb3ZpZGVyO1xudmFyIF91c2VCcm9hZGNhc3RFdmVudCA9IHVzZUJyb2FkY2FzdEV2ZW50O1xudmFyIF91c2VPdGhlcnNMaXN0ZW5lciA9IHVzZU90aGVyc0xpc3RlbmVyO1xudmFyIF91c2VSb29tID0gdXNlUm9vbTtcbnZhciBfdXNlSXNJbnNpZGVSb29tID0gdXNlSXNJbnNpZGVSb29tO1xudmFyIF91c2VBZGRSZWFjdGlvbiA9IHVzZUFkZFJlYWN0aW9uO1xudmFyIF91c2VNdXRhdGlvbiA9IHVzZU11dGF0aW9uO1xudmFyIF91c2VDcmVhdGVUaHJlYWQgPSB1c2VDcmVhdGVUaHJlYWQ7XG52YXIgX3VzZURlbGV0ZVRocmVhZCA9IHVzZURlbGV0ZVRocmVhZDtcbnZhciBfdXNlRWRpdFRocmVhZE1ldGFkYXRhID0gdXNlRWRpdFRocmVhZE1ldGFkYXRhO1xudmFyIF91c2VFdmVudExpc3RlbmVyID0gdXNlRXZlbnRMaXN0ZW5lcjtcbnZhciBfdXNlTXlQcmVzZW5jZSA9IHVzZU15UHJlc2VuY2U7XG52YXIgX3VzZU90aGVyc01hcHBlZCA9IHVzZU90aGVyc01hcHBlZDtcbnZhciBfdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UgPSB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZTtcbnZhciBfdXNlVGhyZWFkcyA9IHVzZVRocmVhZHM7XG52YXIgX3VzZVRocmVhZHNTdXNwZW5zZSA9IHVzZVRocmVhZHNTdXNwZW5zZTtcbnZhciBfdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzO1xudmFyIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSA9IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlO1xudmFyIF91c2VIaXN0b3J5VmVyc2lvbnMgPSB1c2VIaXN0b3J5VmVyc2lvbnM7XG52YXIgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlID0gdXNlSGlzdG9yeVZlcnNpb25zU3VzcGVuc2U7XG52YXIgX3VzZU90aGVyID0gdXNlT3RoZXI7XG5mdW5jdGlvbiBfdXNlT3RoZXJzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZU90aGVycyguLi5hcmdzKTtcbn1cbnZhciBfdXNlT3RoZXJTdXNwZW5zZSA9IHVzZU90aGVyU3VzcGVuc2U7XG5mdW5jdGlvbiBfdXNlT3RoZXJzU3VzcGVuc2UoLi4uYXJncykge1xuICByZXR1cm4gdXNlT3RoZXJzU3VzcGVuc2UoLi4uYXJncyk7XG59XG52YXIgX3VzZVN0b3JhZ2UgPSB1c2VTdG9yYWdlO1xudmFyIF91c2VTdG9yYWdlU3VzcGVuc2UgPSB1c2VTdG9yYWdlU3VzcGVuc2U7XG5mdW5jdGlvbiBfdXNlU2VsZiguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VTZWxmKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gX3VzZVNlbGZTdXNwZW5zZSguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VTZWxmU3VzcGVuc2UoLi4uYXJncyk7XG59XG52YXIgX3VzZVN0b3JhZ2VSb290ID0gdXNlU3RvcmFnZVJvb3Q7XG52YXIgX3VzZVVwZGF0ZU15UHJlc2VuY2UgPSB1c2VVcGRhdGVNeVByZXNlbmNlO1xuXG5leHBvcnQge1xuICBSb29tQ29udGV4dCxcbiAgQ2xpZW50Q29udGV4dCxcbiAgZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudCxcbiAgdXNlQ2xpZW50LFxuICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0LFxuICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlLFxuICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlLFxuICB1c2VSb29tSW5mbyxcbiAgdXNlUm9vbUluZm9TdXNwZW5zZSxcbiAgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkLFxuICBfdXNlVXNlcixcbiAgX3VzZVVzZXJTdXNwZW5zZSxcbiAgX3VzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgX3VzZVVzZXJUaHJlYWRzU3VzcGVuc2VfZXhwZXJpbWVudGFsLFxuICBDcmVhdGVUaHJlYWRFcnJvcixcbiAgdXNlU3RhdHVzLFxuICB1c2VTdG9yYWdlU3RhdHVzLFxuICB1c2VCYXRjaCxcbiAgdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcixcbiAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgdXNlSGlzdG9yeSxcbiAgdXNlVW5kbyxcbiAgdXNlUmVkbyxcbiAgdXNlQ2FuVW5kbyxcbiAgdXNlQ2FuUmVkbyxcbiAgdXNlT3RoZXJzQ29ubmVjdGlvbklkcyxcbiAgdXNlQ29tbWVudHNFcnJvckxpc3RlbmVyLFxuICB1c2VDcmVhdGVDb21tZW50LFxuICB1c2VFZGl0Q29tbWVudCxcbiAgdXNlRGVsZXRlQ29tbWVudCxcbiAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gIHVzZU1hcmtUaHJlYWRBc1JlYWQsXG4gIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICB1c2VNYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gIHVzZUhpc3RvcnlWZXJzaW9uRGF0YSxcbiAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UsXG4gIHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZSxcbiAgdXNlQXR0YWNobWVudFVybCxcbiAgdXNlQXR0YWNobWVudFVybFN1c3BlbnNlLFxuICBjcmVhdGVSb29tQ29udGV4dCxcbiAgX1Jvb21Qcm92aWRlcixcbiAgX3VzZUJyb2FkY2FzdEV2ZW50LFxuICBfdXNlT3RoZXJzTGlzdGVuZXIsXG4gIF91c2VSb29tLFxuICBfdXNlSXNJbnNpZGVSb29tLFxuICBfdXNlQWRkUmVhY3Rpb24sXG4gIF91c2VNdXRhdGlvbixcbiAgX3VzZUNyZWF0ZVRocmVhZCxcbiAgX3VzZURlbGV0ZVRocmVhZCxcbiAgX3VzZUVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgX3VzZUV2ZW50TGlzdGVuZXIsXG4gIF91c2VNeVByZXNlbmNlLFxuICBfdXNlT3RoZXJzTWFwcGVkLFxuICBfdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gIF91c2VUaHJlYWRzLFxuICBfdXNlVGhyZWFkc1N1c3BlbnNlLFxuICBfdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICBfdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UsXG4gIF91c2VIaXN0b3J5VmVyc2lvbnMsXG4gIF91c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSxcbiAgX3VzZU90aGVyLFxuICBfdXNlT3RoZXJzLFxuICBfdXNlT3RoZXJTdXNwZW5zZSxcbiAgX3VzZU90aGVyc1N1c3BlbnNlLFxuICBfdXNlU3RvcmFnZSxcbiAgX3VzZVN0b3JhZ2VTdXNwZW5zZSxcbiAgX3VzZVNlbGYsXG4gIF91c2VTZWxmU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlUm9vdCxcbiAgX3VzZVVwZGF0ZU15UHJlc2VuY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1BN0dKTk40TC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@liveblocks/react/dist/chunk-A7GJNN4L.mjs\n"));

/***/ })

});